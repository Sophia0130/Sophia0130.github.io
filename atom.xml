<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>绿小蕤</title>
  <icon>https://www.gravatar.com/avatar/e4d7a8bd1cb84fb3b4123916b4ea2f6b</icon>
  <subtitle>好逸恶劳,贪生怕死</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-21T06:20:13.180Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>绿小蕤</name>
    <email>528036346@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++学习：强制类型转换</title>
    <link href="http://yoursite.com/2018/10/21/C-%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2018/10/21/C-学习：强制类型转换/</id>
    <published>2018-10-21T06:12:41.000Z</published>
    <updated>2018-10-21T06:20:13.180Z</updated>
    
    <content type="html"><![CDATA[<p>z最近晕乎乎的，这部分的内容看得很不明白，只能理解非常浅显，我要加油了 ！</p><p>参考这篇博客：<a href="https://blog.csdn.net/ydar95/article/details/69822540" target="_blank" rel="noopener">https://blog.csdn.net/ydar95/article/details/69822540</a></p><ul><li>去const属性用const_cast</li><li>基本类型转换用static_cast</li><li>多态类之间的类型转换用daynamic_cast</li><li>不同类型的指针类型转换用reinterpreter_cast</li></ul><a id="more"></a><p><br></p><h2 id="C风格"><a href="#C风格" class="headerlink" title="C风格"></a>C风格</h2><p><code>TypeName b = (TypeName)a;</code></p><p><br></p><h2 id="C-风格"><a href="#C-风格" class="headerlink" title="C++风格"></a>C++风格</h2><h3 id="1-const-cast"><a href="#1-const-cast" class="headerlink" title="1. const_cast"></a>1. const_cast</h3><p><strong>去掉类型的 const、volatile 属性</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeWord</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tmp = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(buf);</span><br><span class="line">    tmp[<span class="number">0</span>] = <span class="string">'9'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">"123456789"</span>;</span><br><span class="line">    changeWord(buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-static-cast"><a href="#2-static-cast" class="headerlink" title="2. static_cast"></a>2. static_cast</h3><p>类似于C风格的强制转换</p><ol><li><p>派生类和子类之间转换</p><ul><li><strong>派生类的指针或引用转换成基类是安全的</strong></li></ul></li></ol><ul><li><strong>基类指针或引用转换成派生类是不安全的</strong></li></ul><ol start="2"><li><p>基本数据类型之间的转换，enum, struct, int, char, float 之间的转换</p></li><li><p><strong>static_cast不能去掉类型的const、volitale属性 (用const_cast)</strong></p></li><li><p>c++ 的任何的隐式转换都是使用 static_cast 来实现</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 常规用法 */</span></span><br><span class="line"><span class="keyword">float</span> f_pi=<span class="number">3.141592f</span></span><br><span class="line"><span class="keyword">int</span>   i_pi=<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(f_pi); <span class="comment">// i_pi 的值为 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* class 的上下行转换 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  上行 Sub -&gt; Base</span></span><br><span class="line"><span class="comment">//编译通过，安全</span></span><br><span class="line">Sub sub;</span><br><span class="line">Base *base_ptr = <span class="keyword">static_cast</span>&lt;Base*&gt;(&amp;sub);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//  下行 Base -&gt; Sub</span></span><br><span class="line"><span class="comment">//编译通过，不安全</span></span><br><span class="line">Base base;</span><br><span class="line">Sub *sub_ptr = <span class="keyword">static_cast</span>&lt;Sub*&gt;(&amp;base);</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-dynamic-cast"><a href="#3-dynamic-cast" class="headerlink" title="3. dynamic_cast"></a>3. dynamic_cast</h3><p>一般是用在基类和派生类的转换上，也与编译器的属性设置有关</p><p>在进行下行转换时，dynamic_cast具有类型检查的功能，比 static_cast更安全</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base() &#123;&#125;</span><br><span class="line">    ~Base() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm Base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">i_am_virtual_foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sub() &#123;&#125;</span><br><span class="line">    ~Sub() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm Sub"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">i_am_virtual_foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sub-&gt;Base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Sub * sub = <span class="keyword">new</span> Sub();</span><br><span class="line">    sub-&gt;print();</span><br><span class="line">    Base* sub2base = <span class="keyword">dynamic_cast</span>&lt;Base*&gt;(sub);</span><br><span class="line">    <span class="keyword">if</span> (sub2base != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        sub2base-&gt;print();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;sub-&gt;base&gt; sub2base val is: "</span> &lt;&lt; sub2base &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Base-&gt;Sub"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Base *base = <span class="keyword">new</span> Base();</span><br><span class="line">    base-&gt;print();</span><br><span class="line">    Sub  *base2sub = <span class="keyword">dynamic_cast</span>&lt;Sub*&gt;(base);</span><br><span class="line">    <span class="keyword">if</span> (base2sub != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        base2sub-&gt;print();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"&lt;base-&gt;sub&gt; base2sub val is: "</span>&lt;&lt; base2sub &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> sub;</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* vs2017 输出为</span></span><br><span class="line"><span class="comment">Sub-&gt;Base</span></span><br><span class="line"><span class="comment">I'm Sub</span></span><br><span class="line"><span class="comment">I'm Base</span></span><br><span class="line"><span class="comment">&lt;sub-&gt;base&gt; sub2base val is: 00B9E080   // 注:这个地址是系统分配的,每次不一定一样</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Base-&gt;Sub</span></span><br><span class="line"><span class="comment">I'm Base</span></span><br><span class="line"><span class="comment">&lt;base-&gt;sub&gt; base2sub val is: 00000000   // 对此类错误的转换赋值为nullptr</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><br></p><p>运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表</p><p>当一个类中拥有至少一个虚函数，那么编译器就会构建出一个虚函数表，来指示这些函数的地址，假如继承该类的子类定义并实现了一个同名并具有同样函数签名的方法重写了基类中的方法，那么虚函数表会将该函数指向新的地址。此时多态性就体现出来了</p><p><br></p><h3 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4. reinterpret_cast"></a>4. reinterpret_cast</h3><p>无关类型转换，将指针转换为其它指针类型、将数字转换为指针或将指针转换为数字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重解析类型转换，前置进行类型转换 </span></span><br><span class="line">    <span class="keyword">char</span> *p1  = <span class="string">"hello world"</span>;                       </span><br><span class="line">    <span class="keyword">int</span>  *p2  = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> *&gt;(p1);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p2&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 输出一串我也看不懂的数字</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;z最近晕乎乎的，这部分的内容看得很不明白，只能理解非常浅显，我要加油了 ！&lt;/p&gt;
&lt;p&gt;参考这篇博客：&lt;a href=&quot;https://blog.csdn.net/ydar95/article/details/69822540&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/ydar95/article/details/69822540&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;去const属性用const_cast&lt;/li&gt;
&lt;li&gt;基本类型转换用static_cast&lt;/li&gt;
&lt;li&gt;多态类之间的类型转换用daynamic_cast&lt;/li&gt;
&lt;li&gt;不同类型的指针类型转换用reinterpreter_cast&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习：const、static、extern</title>
    <link href="http://yoursite.com/2018/10/20/C-%E5%AD%A6%E4%B9%A0%EF%BC%9Aconst%E3%80%81static%E3%80%81extern/"/>
    <id>http://yoursite.com/2018/10/20/C-学习：const、static、extern/</id>
    <published>2018-10-20T09:57:25.000Z</published>
    <updated>2018-10-20T10:18:18.258Z</updated>
    
    <content type="html"><![CDATA[<p>最粗略的理解</p><p>const：存储的内容不变</p><p>static：存储的位置不变</p><p>参考了好多篇其它博客，但是找不到了……</p><a id="more"></a><p><br></p><h2 id="（一）const"><a href="#（一）const" class="headerlink" title="（一）const"></a>（一）const</h2><p><strong>常量限定符</strong></p><h3 id="一、const-修饰基本数据类型"><a href="#一、const-修饰基本数据类型" class="headerlink" title="一、const 修饰基本数据类型"></a>一、const 修饰基本数据类型</h3><h4 id="1-修饰一般常量及数组"><a href="#1-修饰一般常量及数组" class="headerlink" title="1.修饰一般常量及数组"></a>1.修饰一般常量及数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">10</span>;                        <span class="keyword">int</span> <span class="keyword">const</span> a=<span class="number">10</span>;</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">int</span> arr[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;              <span class="keyword">int</span> <span class="keyword">const</span> arr[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-修饰指针变量-（重点-常量指针、指针常量）"><a href="#2-修饰指针变量-（重点-常量指针、指针常量）" class="headerlink" title="2.修饰指针变量*  （重点-常量指针、指针常量）"></a>2.修饰指针变量*  （重点-常量指针、指针常量）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* a = &amp; [<span class="number">1</span>]          <span class="comment">//指针指向的数据为常量，不能更改内容  //常量指针</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *a = &amp; [<span class="number">2</span>]          <span class="comment">//指针指向的数据为常量，不能更改内容  //常量指针</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> a = &amp; [<span class="number">3</span>]          <span class="comment">//指针指向的数据非常量，指针指向的地址不能变  //指针常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> a = &amp; [<span class="number">4</span>]    <span class="comment">//常量指针和指针常量</span></span><br></pre></td></tr></table></figure><p>常量指针：指针指向的数据为常量，不能变</p><p>指针常量：指针指向的地址不能变</p><p><br></p><h4 id="3-修饰引用变量-amp"><a href="#3-修饰引用变量-amp" class="headerlink" title="3.修饰引用变量&amp;"></a>3.修饰引用变量&amp;</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> &amp;a=x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;a=x;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="二、函数与-const"><a href="#二、函数与-const" class="headerlink" title="二、函数与 const"></a>二、函数与 const</h3><h4 id="1-作为参数的-const-修饰符"><a href="#1-作为参数的-const-修饰符" class="headerlink" title="1. 作为参数的 const 修饰符"></a>1. 作为参数的 const 修饰符</h4><p>不能对传递进来的指针的内容进行改变，保护了原指针所指向的内容</p><h4 id="2-作为函数返回值的-const-修饰符"><a href="#2-作为函数返回值的-const-修饰符" class="headerlink" title="2. 作为函数返回值的 const 修饰符"></a>2. 作为函数返回值的 const 修饰符</h4><p><br></p><h3 id="三、类与-const"><a href="#三、类与-const" class="headerlink" title="三、类与 const"></a>三、类与 const</h3><h4 id="1-类的-const-数据成员"><a href="#1-类的-const-数据成员" class="headerlink" title="1. 类的 const 数据成员"></a>1. 类的 const 数据成员</h4><p>只在某个对象生存期内是常量，而对于整个类而言却是可变的</p><p><br></p><h4 id="2-类的-const-成员函数（常量成员函数）"><a href="#2-类的-const-成员函数（常量成员函数）" class="headerlink" title="2. 类的 const 成员函数（常量成员函数）"></a>2. 类的 const 成员函数（常量成员函数）</h4><p><strong>类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（非静态数据成员）作改变</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"const"</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"normal"</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    CTest a;  </span><br><span class="line">    a.show();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> CTest b;  </span><br><span class="line">    b.show();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-const-对象与-const-成员函数"><a href="#3-const-对象与-const-成员函数" class="headerlink" title="3. const 对象与 const 成员函数"></a>3. const 对象与 const 成员函数</h4><p>const 成员函数：可以访问非const对象的所有数据成员，也可以访问const对象内的所有数据成员</p><p>非const 成员函数：可以访问非const对象的所有数据成员，但<strong>不可以访问const对象的任意数据成员</strong></p><p><br></p><h2 id="（二）static"><a href="#（二）static" class="headerlink" title="（二）static"></a>（二）static</h2><h3 id="1-静态全局变量"><a href="#1-静态全局变量" class="headerlink" title="1. 静态全局变量"></a>1. 静态全局变量</h3><p>在全局数据区分配内存，不是在栈区，未经初始化的静态全局变量会被自动初始化为0</p><ul><li>全局变量：</li></ul><p>只需在一个源文件中定义，就可以<strong>作用于所有的源文件</strong></p><p>其他不包含全局变量定义的源文件需要用 <strong>extern 关键字再次声明这个全局变量</strong></p><ul><li>静态全局变量：</li></ul><p><strong>作用于定义它的文件里</strong>，不能作用到其它文件里，具有文件作用域</p><p>比如，两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量</p><p><br></p><h3 id="2-静态局部变量"><a href="#2-静态局部变量" class="headerlink" title="2. 静态局部变量"></a>2. 静态局部变量</h3><p>在全局数据区分配内存，不是在栈区，未经初始化的静态全局变量会被自动初始化为0</p><p>静态局部变量被首次初始化以后，函数调用不再进行初始化</p><p>实现在多次函数调用时，对变量的值进行保存</p><p><br></p><h3 id="3-静态函数"><a href="#3-静态函数" class="headerlink" title="3. 静态函数"></a>3. 静态函数</h3><p>类似于静态全局变量，<strong>只能在声明它的文件当中可见</strong>，不能被其它文件使用</p><p><br></p><h3 id="4-类与-static"><a href="#4-类与-static" class="headerlink" title="4. 类与 static"></a>4. 类与 static</h3><p>静态成员数据、静态成员函数被该类的所有对象所共有的</p><p>静态成员函数 <strong>不具有this指针</strong>，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数</p><p><br></p><p>注意</p><ul><li>static成员变量：不能在类的内部初始化，在类的内部只是声明，<strong>定义必须在类定义体的外部</strong></li><li>const成员变量：也不能在类定义处初始化，只能<strong>通过构造函数初始化列表初始化</strong></li></ul><p><br></p><h2 id="（三）extern"><a href="#（三）extern" class="headerlink" title="（三）extern"></a>（三）extern</h2><ol><li><p>extern 可以置于变量或者函数前，表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义</p><p>（感觉有点像头文件的功能）</p></li><li><p>extern 也可用来进行<strong>链接指定</strong>（在C++环境下使用C函数时）</p></li></ol><p><code>extern &quot;C&quot; void fun(int a, int b);</code></p><p>告诉编译器在编译fun这个函数名时，是按着C的规则而不是C++</p><p><br></p><p><strong>C++ 编译函数名时，为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称</strong></p><p>在C++环境下使用C函数的时候，常常会出现编译器无法找到obj模块中的C函数定义，链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，按照C的规则编译函数名</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最粗略的理解&lt;/p&gt;
&lt;p&gt;const：存储的内容不变&lt;/p&gt;
&lt;p&gt;static：存储的位置不变&lt;/p&gt;
&lt;p&gt;参考了好多篇其它博客，但是找不到了……&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习：指针和引用</title>
    <link href="http://yoursite.com/2018/10/20/C-%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2018/10/20/C-学习：指针和引用/</id>
    <published>2018-10-20T03:38:15.000Z</published>
    <updated>2018-10-20T03:41:04.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h2><ol><li>指针：存储的是变量的地址</li><li>引用：和原变量实质上是同一东西，只不过是原变量的一个别名</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;<span class="keyword">int</span> *p=&amp;a;  <span class="comment">// p的值是a的地址</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;<span class="keyword">int</span> &amp;b=a;   <span class="comment">// a、b占据同一块内存</span></span><br></pre></td></tr></table></figure><a id="more"></a><p><br></p><h2 id="amp-和"><a href="#amp-和" class="headerlink" title="&amp;和*"></a>&amp;和*</h2><h3 id="1-amp-符号"><a href="#1-amp-符号" class="headerlink" title="1. &amp; 符号"></a>1. &amp; 符号</h3><ul><li>取址符，用于返回变量的实际地址</li><li>定义变量的引用，不代表取地址</li></ul><p><br></p><h3 id="2-符号"><a href="#2-符号" class="headerlink" title="2. * 符号"></a>2. * 符号</h3><p>用于返回地址所指向的变量（p存储的是变量的地址，*p表示该地址所指向的变量）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a;  </span><br><span class="line">  <span class="keyword">int</span> *aPtr; </span><br><span class="line">  a=<span class="number">7</span>;</span><br><span class="line">  aPtr = &amp;a;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"a="</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;                 <span class="comment">// a的值</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"*aPtr="</span>&lt;&lt;*aPtr&lt;&lt;<span class="built_in">endl</span>;         <span class="comment">// a的值，aPtr存放a的地址，取该地址指向的变量</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"&amp;*aPtr = "</span>&lt;&lt;&amp;*aPtr&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// a的地址，*aPtr指向a，&amp;*aPtr=&amp;a  </span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"*&amp;aPtr = "</span>&lt;&lt;*&amp;aPtr &lt;&lt;<span class="built_in">endl</span>; <span class="comment">// a的地址，&amp;aPtr取aPtr的地址，*&amp;aPtr就是aPtr中存放的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="指针和引用作为参数传递"><a href="#指针和引用作为参数传递" class="headerlink" title="指针和引用作为参数传递"></a>指针和引用作为参数传递</h2><p>1.指针作为参数传递</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> *p)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// p得到main传入的NULL</span></span><br><span class="line">　　<span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">　　p=&amp;a;</span><br><span class="line">　　<span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">" "</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">    test(p);       <span class="comment">// 传入的是NULL</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"指针p为NULL"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果为：</span></span><br><span class="line"><span class="comment">//0x22ff44 1</span></span><br><span class="line"><span class="comment">//指针p为NULL</span></span><br></pre></td></tr></table></figure><p><br></p><p>2.引用作为参数传递</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="string">" "</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="string">" "</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    test(a);  <span class="comment">// </span></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果为：</span></span><br><span class="line"><span class="comment">//0x22ff44 1</span></span><br><span class="line"><span class="comment">//0x22ff44 1</span></span><br></pre></td></tr></table></figure><p><br></p><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><ol><li><strong>可以有 const 指针，但是没有 const 引用</strong>  （？？）</li><li>指针可以有多级，但是引用只能是一级</li><li>指针的值可以为空，但是引用的值不能为NULL，并且<strong>引用在定义的时候必须初始化</strong></li><li>指针的值在初始化后可以改变，即指向其它的存储单元，而<strong>引用在初始化后就不会再改变</strong></li><li>“sizeof引用”得到的是所指向的变量的大小，而”sizeof指针”得到的是指针本身的大小</li><li>指针和引用的自增(++)运算意义不一样（？？）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;指针和引用&quot;&gt;&lt;a href=&quot;#指针和引用&quot; class=&quot;headerlink&quot; title=&quot;指针和引用&quot;&gt;&lt;/a&gt;指针和引用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;指针：存储的是变量的地址&lt;/li&gt;
&lt;li&gt;引用：和原变量实质上是同一东西，只不过是原变量的一个别名&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *p=&amp;amp;a;  &lt;span class=&quot;comment&quot;&gt;// p的值是a的地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;amp;b=a;   &lt;span class=&quot;comment&quot;&gt;// a、b占据同一块内存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习：内存管理</title>
    <link href="http://yoursite.com/2018/10/19/C-%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/10/19/C-学习：内存管理/</id>
    <published>2018-10-19T13:58:27.000Z</published>
    <updated>2018-10-19T14:00:09.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>学习笔记参考：<a href="https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/" target="_blank" rel="noopener">https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/</a></p><a id="more"></a><p><br></p><h2 id="一、内存分配"><a href="#一、内存分配" class="headerlink" title="一、内存分配"></a>一、内存分配</h2><p>C++中，内存分成<strong>5个区</strong>，和 C 的内存分配不太一样，整体上一致</p><p><br></p><ol><li><p><strong>栈</strong>：由编译器在需要时自动分配和释放。通常用来存储局部变量、函数参数、返回地址等</p></li><li><p><strong>堆</strong>：由程序员分配释放，程序员没有释放掉，那么在程序结束后，操作系统会自动回收</p></li><li><p><strong>自由存储区</strong>：是C++中通过 new/delete 动态分配和释放对象的抽象概念</p></li><li><p><strong>全局/静态存储区</strong>：全局变量和静态变量被分配到同一块内存中</p></li><li><p><strong>常量存储区</strong>：存放的是常量，不允许修改</p><p>​</p></li></ol><p><img src="http://img.it610.com/image/info5/eae8b1536ec547d1ab59f6dab3b79347.jpg" alt="“c 语言 内存 分配”的图片搜索结果"></p><p><br></p><h2 id="二、动态内存分配和静态内存分配"><a href="#二、动态内存分配和静态内存分配" class="headerlink" title="二、动态内存分配和静态内存分配"></a>二、动态内存分配和静态内存分配</h2><h3 id="1-时间不同"><a href="#1-时间不同" class="headerlink" title="1. 时间不同"></a>1. 时间不同</h3><p>静态分配发生在程序编译和连接的时候</p><p>动态分配则发生在程序调入和执行的时候</p><h3 id="2-空间不同"><a href="#2-空间不同" class="headerlink" title="2. 空间不同"></a>2. 空间不同</h3><p>堆都是动态分配的，没有静态分配的堆</p><p>栈有静态分配和动态分配</p><p><br></p><h2 id="三、堆和栈的区别"><a href="#三、堆和栈的区别" class="headerlink" title="三、堆和栈的区别"></a>三、堆和栈的区别</h2><h3 id="1-管理方式"><a href="#1-管理方式" class="headerlink" title="1. 管理方式"></a>1. 管理方式</h3><p>栈：由<strong>编译器</strong>自动管理</p><p>堆：由程序员控制，容易产生内存泄漏</p><h3 id="2-碎片问题"><a href="#2-碎片问题" class="headerlink" title="2. 碎片问题"></a>2. 碎片问题</h3><p>堆：频繁的 <code>new/delete</code> 会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低</p><p>栈：是先进后出的队列，不可能有一个内存块从栈中间弹出</p><h3 id="3-生长方向"><a href="#3-生长方向" class="headerlink" title="3. 生长方向"></a>3. 生长方向</h3><p>堆：生长方向是向上的，也就是向着内存地址增加的方向</p><p>栈：生长方向是向下的，是向着内存地址减小的方向增长</p><h3 id="4-分配方式"><a href="#4-分配方式" class="headerlink" title="4. 分配方式"></a>4. 分配方式</h3><p>堆：动态分配，没有静态分配的堆</p><p>栈：静态分配和动态分配，静态分配是编译器完成</p><h3 id="5-分配效率"><a href="#5-分配效率" class="headerlink" title="5. 分配效率"></a>5. 分配效率</h3><p><strong>堆的效率比栈要低得多</strong></p><p>栈：计算机底层会对栈提供支持，分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行</p><p>堆：由C/C++函数库提供</p><p>例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间</p><p><br></p><h2 id="四、new-delete-和-malloc-free-的区别"><a href="#四、new-delete-和-malloc-free-的区别" class="headerlink" title="四、new/delete 和 malloc/free 的区别"></a>四、new/delete 和 malloc/free 的区别</h2><p><a href="https://blog.csdn.net/Hackbuteer1/article/details/6789164" target="_blank" rel="noopener">https://blog.csdn.net/Hackbuteer1/article/details/6789164</a></p><h3 id="1-new-delete"><a href="#1-new-delete" class="headerlink" title="1. new/delete"></a>1. new/delete</h3><p>是C++的<strong>运算符</strong>，无须指定内存块的大小</p><p>内存分配成功时，返回的是对象类型的指针，无须进行类型转换</p><p>注意：</p><p>1.用new 创建对象数组，那么只能使用对象的无参数构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Obj *objects = new Obj[100];           // 创建100 个动态对象</span><br><span class="line">Obj *objects = new Obj[100](1);        // 错误写法，创建100 个动态对象的同时赋初值1</span><br></pre></td></tr></table></figure><p>2.用delete 释放对象数组时，留意不要丢了符号‘[]’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete []objects;   // 正确的用法</span><br><span class="line">delete objects;     // 错误的用法，只释放了一个对象</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-malloc与free"><a href="#2-malloc与free" class="headerlink" title="2. malloc与free"></a>2. malloc与free</h3><p>是C++/C 语言的<strong>标准库函数</strong>，<strong>需要显式地指出所需内存大小</strong> ，因为并不知道申请的内存是什么类型，只关心内存的总字节数</p><p>存分配成功则是返回void <em> ，**需要通过强制类型转换将void</em>指针转换成所需类型**</p><p>对于非内部数据类的对象而言，即<strong>用户自定义的对象，无法用 malloc/free 动态管理对象</strong>（我的理解，自己定义了一个类，可以用new实例化该类，但是不能用malloc为该类分配内存，更不能执行构造函数、析构函数）</p><p><br></p><h3 id="3-对象动态管理"><a href="#3-对象动态管理" class="headerlink" title="3. 对象动态管理"></a>3. 对象动态管理</h3><p>对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数</p><p>由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free</p><p>运算符new能完成动态内存分配和初始化工作，运算符delete能完成清理与释放内存工作</p><p><br></p><h2 id="五、内存错误"><a href="#五、内存错误" class="headerlink" title="五、内存错误"></a>五、内存错误</h2><h3 id="1-内存分配未成功"><a href="#1-内存分配未成功" class="headerlink" title="1. 内存分配未成功"></a>1. 内存分配未成功</h3><p>内存分配未成功，就使用</p><p>常用解决办法是，在使用内存之前检查指针是否为<code>NULL</code></p><h3 id="2-内存越界"><a href="#2-内存越界" class="headerlink" title="2. 内存越界"></a>2. 内存越界</h3><p>例如在使用数组时经常发生下标“多1”或者“少1”的操作</p><h3 id="3-内存泄露（指针不存在）"><a href="#3-内存泄露（指针不存在）" class="headerlink" title="3. 内存泄露（指针不存在）"></a>3. 内存泄露（指针不存在）</h3><p>申请的内存空间没有被正确释放，<strong>而指向这块内存空间的指针不再存在</strong></p><p>含有这种错误的函数每被调用一次就丢失一块内存</p><h3 id="4-释放内存却继续使用"><a href="#4-释放内存却继续使用" class="headerlink" title="4. 释放内存却继续使用"></a>4. 释放内存却继续使用</h3><p>函数  <code>return</code> 了指向栈内存的指针或者引用，但是该内存在函数体结束时就已经被自动销毁了</p><h3 id="5-野指针（指针指向错误的内存）"><a href="#5-野指针（指针指向错误的内存）" class="headerlink" title="5. 野指针（指针指向错误的内存）"></a>5. 野指针（指针指向错误的内存）</h3><p>（1）释放了内存后，指针仍然指向这个已删除的对象，没有将指针设为 <code>NULL</code></p><p>（2）指针未被初始化就被引用，<strong>指向一个未知的地址</strong></p><p><strong>与空指针不同，野指针无法通过简单地判断是否为 NULL 来避免</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h1&gt;&lt;p&gt;学习笔记参考：&lt;a href=&quot;https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习：C和C++的I/O库区别</title>
    <link href="http://yoursite.com/2018/10/19/C-%E5%AD%A6%E4%B9%A0%EF%BC%9AC%E5%92%8CC-%E7%9A%84I-O%E5%BA%93%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/10/19/C-学习：C和C-的I-O库区别/</id>
    <published>2018-10-19T07:16:53.000Z</published>
    <updated>2018-10-19T07:18:23.829Z</updated>
    
    <content type="html"><![CDATA[<p>PS：下面是我个人对两种I/O库的理解</p><p>C语言的输入输出：需要标准流和输入输出函数共同实现，这是个过程</p><p>C++的输入输出：实例化ios类为对象，这是面向对象</p><p>最近看的两个项目，一个是C，一个是C++，突然发现真的有很多不同</p><a id="more"></a><p><br></p><h1 id="C语言—标准I-O"><a href="#C语言—标准I-O" class="headerlink" title="C语言—标准I/O"></a>C语言—标准I/O</h1><p>C语言的I/O相关函数封装在头文件 \&lt;stdio.h></p><p><br></p><h3 id="1-三个标准流"><a href="#1-三个标准流" class="headerlink" title="1. 三个标准流"></a>1. 三个标准流</h3><p>PS：我对流的理解，是数据源源不断的流动，标准应该是指某种规则</p><ul><li><p>标准输入流 stdin：从键盘输入 </p></li><li><p>标准输出流 stdout：默认是输出到屏幕 </p><p>stdout 是行缓冲的，输出会放在一个buffer里面，<strong>只有到换行的时候，才会输出到屏幕</strong></p></li></ul><ul><li><p>标准错误流 stderr：默认是输出到屏幕</p><p>stderr 是无缓冲的，会直接输出</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"Hello"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"World!"</span>);</span><br><span class="line">return0;</span><br><span class="line">&#125;  <span class="comment">// 输出结果：World!Hello</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-格式化输入、输出"><a href="#2-格式化输入、输出" class="headerlink" title="2. 格式化输入、输出"></a>2. 格式化输入、输出</h3><h4 id="（1）格式化输入"><a href="#（1）格式化输入" class="headerlink" title="（1）格式化输入"></a>（1）格式化输入</h4><ul><li>scanf：从控制台输入 </li><li>fscanf ：从文件输入 </li><li>sscanf ：从指定字符串输入</li></ul><h4 id="（2）格式化输出"><a href="#（2）格式化输出" class="headerlink" title="（2）格式化输出"></a>（2）格式化输出</h4><ul><li>printf：向屏幕这样的标准输出设备输出</li><li>sprintf：格式化输出到一个字符串</li><li>fprintf：格式化输出到流 stream指定的文件</li></ul><p><br></p><h3 id="3-标准流和格式化输入输出函数的关系"><a href="#3-标准流和格式化输入输出函数的关系" class="headerlink" title="3. 标准流和格式化输入输出函数的关系"></a>3. 标准流和格式化输入输出函数的关系</h3><p>PS：段小洋说不能单独讲流或输入输出，应该就是输入输出流，两者是绑定的，但是我就是想把它分开来，这样好理解嘛 ~</p><p><strong>C语言把所有的设备（比如显示器、键鼠、U盘等）都当做文件</strong>，把所有的东西都当作文件来处理</p><p>程序与文件交互时，会默认创建 stdin、stdout、stderr 三个文件</p><p>比如，stdin先接收键盘的数据，然后通过输入函数将数据输入到程序里</p><p><br></p><h1 id="C-—标准I-O"><a href="#C-—标准I-O" class="headerlink" title="C++—标准I/O"></a>C++—标准I/O</h1><p><a href="https://www.cnblogs.com/xumengpiaoyun/archive/2013/04/21/3034195.html" target="_blank" rel="noopener">https://www.cnblogs.com/xumengpiaoyun/archive/2013/04/21/3034195.html</a></p><p><br></p><ul><li>标准I/O：对系统指定的<strong>标准设备</strong>的输入和输出（键盘输入数据，输出到显示屏幕）</li><li>文件I/O：<strong>外存磁盘文件</strong>为对象进行输入和输出（从磁盘文件输入数据，数据输出到磁盘文件）</li><li>字符串I/O：对内存中指定的空间进行输入和输出</li></ul><p><br></p><h3 id="1-I-O类库中的常用流类"><a href="#1-I-O类库中的常用流类" class="headerlink" title="1. I/O类库中的常用流类"></a>1. I/O类库中的常用流类</h3><p><img src="https://images0.cnblogs.com/blog/476361/201304/21180804-68564fc8ad1b4472b8ba6012d51c6db3.jpg" alt="img"></p><p><br></p><h3 id="2-头文件"><a href="#2-头文件" class="headerlink" title="2.头文件"></a>2.头文件</h3><p>iostream类库的即可分别由不同的头文件来实现，命名空间为 std</p><ul><li>iostream：标准I/O，对系统指定的标准设备的输入和输出（比如键盘输入数据，输出到显示屏幕）</li><li>fstream：文件I/O，以磁盘文件为对象的输入和输出（从磁盘文件输入数据，数据输出到磁盘文件）</li><li>strstream：字符串I/O，对内存中指定的空间的输入和输出</li></ul><p><br></p><p>PS：标准输入输出流、格式化输入输出都是对流类实例化为对象</p><h3 id="3-标准输入流"><a href="#3-标准输入流" class="headerlink" title="3. 标准输入流"></a>3. 标准输入流</h3><ul><li>cin流对象：从输入流提取数据，遇到空格或者回车就终止。</li><li>cin.get()</li></ul><ul><li><p>cin.getline()</p><p><br></p></li></ul><h3 id="4-标准输出流"><a href="#4-标准输出流" class="headerlink" title="4. 标准输出流"></a>4. 标准输出流</h3><ul><li>cout 流对象：可以传送到显示器输出，也可以<strong>重定向到磁盘文件</strong></li><li>cerr 流对象：只能在显示器输出，<strong>不经过缓冲区</strong></li><li>clog 流对象：在显示器显示错误信息，<strong>缓冲区满</strong> 后或者遇 <strong>endl</strong> 时向显示器输出</li></ul><p><br></p><h3 id="5-格式化输入输出"><a href="#5-格式化输入输出" class="headerlink" title="5. 格式化输入输出"></a>5. 格式化输入输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//控制格式化, 输出</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default bool values : "</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span></span><br><span class="line">&lt;&lt; <span class="string">"\nalpha bool values : "</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span></span><br><span class="line">&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"no reset bool : "</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//没有重置</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::noboolalpha &lt;&lt; <span class="string">"reset bool : "</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//重置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//整数的基, 显示, 大写</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::showbase;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default : "</span> &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="number">1024</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//默认</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"octal : "</span> &lt;&lt; oct &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="number">1024</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//8进制</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::uppercase &lt;&lt; <span class="string">"hex : "</span> &lt;&lt; hex &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="number">1024</span></span><br><span class="line">&lt;&lt; <span class="built_in">std</span>::nouppercase &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//16进制</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"decimal : "</span>  &lt;&lt; dec&lt;&lt; <span class="number">20</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="number">1024</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//10进制</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::noshowbase;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：下面是我个人对两种I/O库的理解&lt;/p&gt;
&lt;p&gt;C语言的输入输出：需要标准流和输入输出函数共同实现，这是个过程&lt;/p&gt;
&lt;p&gt;C++的输入输出：实例化ios类为对象，这是面向对象&lt;/p&gt;
&lt;p&gt;最近看的两个项目，一个是C，一个是C++，突然发现真的有很多不同&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习：内存对齐</title>
    <link href="http://yoursite.com/2018/10/19/C-%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <id>http://yoursite.com/2018/10/19/C-学习：内存对齐/</id>
    <published>2018-10-19T07:13:24.000Z</published>
    <updated>2018-10-19T07:13:47.034Z</updated>
    
    <content type="html"><![CDATA[<p>PS：这篇博客写得很详细，下面的学习笔记都是参考其完成</p><p> <a href="https://blog.csdn.net/markl22222/article/details/38051483" target="_blank" rel="noopener">https://blog.csdn.net/markl22222/article/details/38051483</a></p><a id="more"></a><h2 id="一、内存对齐-Data-structure-alignment"><a href="#一、内存对齐-Data-structure-alignment" class="headerlink" title="一、内存对齐 Data structure alignment"></a>一、内存对齐 Data structure alignment</h2><p>PS：WiKi 的定义很清楚，内存对齐就是数据在电脑中的存储方式</p><p>Data structure alignment refers to the way <strong>data is arranged and accessed in computer memory</strong>. </p><p>It consists of three separate but related issues:</p><ul><li>data alignment</li><li>data structure padding</li><li>packing</li></ul><p><br></p><h3 id="1-内存对齐（Data-structure-alignment）"><a href="#1-内存对齐（Data-structure-alignment）" class="headerlink" title="1. 内存对齐（Data structure alignment）"></a>1. 内存对齐（Data structure alignment）</h3><p>是一个数据类型所存放的<strong>内存地址的属性</strong>，这个属性是一个无符号整数，并且这个整数必须是2的N次方 1、2、4、8、……</p><p>比如，<strong>一个数据类型的内存对齐为8，是指这个数据类型定义出来的所有变量，其内存地址都是8的倍数</strong></p><h3 id="2-自然对齐（naturally-aligned）"><a href="#2-自然对齐（naturally-aligned）" class="headerlink" title="2. 自然对齐（naturally aligned）"></a>2. 自然对齐（naturally aligned）</h3><p>基本数据类型的对齐属性，和这个数据类型的大小相等时，这种对齐方式称作自然对齐</p><p>比如，一个4字节大小的int型数据，默认情况下它的内存对齐也是4</p><p><br></p><h2 id="二、为什么要用内存对齐？"><a href="#二、为什么要用内存对齐？" class="headerlink" title="二、为什么要用内存对齐？"></a>二、为什么要用内存对齐？</h2><p><strong>考虑到CPU处理内存的方式</strong></p><p>32位的x86 CPU，一个时钟周期可以读取4个连续的内存单元，即4字节，使用字节对齐将会提高系统的性能，也就是CPU读取内存数据的效率。</p><p>比如，一个int放在奇数内存位置上，将4个字节读出，32位CPU就需要两次，但对齐之后一次就可以。</p><p><br></p><h2 id="三、数据填充-Data-Structure-Padding"><a href="#三、数据填充-Data-Structure-Padding" class="headerlink" title="三、数据填充 Data Structure Padding"></a>三、数据填充 Data Structure Padding</h2><p>内存对齐可能会让数据在内存里的存放不是紧挨着的，而是可能会出现一些空隙</p><p>举个例子：</p><p>1.定义一个结构体，如果直接相加占用内存是16，sizeof 的结果其实更大，这是因为，为了保证这个结构体里的每个成员都应该在它对齐的内存位置上，而在某些位置插入了Padding</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;         <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="keyword">int</span> b;          <span class="comment">// 4 bytes</span></span><br><span class="line">    <span class="keyword">short</span> c;        <span class="comment">// 2 bytes</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> d;    <span class="comment">// 8 bytes</span></span><br><span class="line">    <span class="keyword">char</span> e;         <span class="comment">// 1 byte</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.填充后的结果</p><p>当然，<strong>不同平台下会使用不同的默认对齐值</strong>，下面这个只是一种方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;         <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="keyword">char</span> pad_0[<span class="number">3</span>];  <span class="comment">// Padding 3</span></span><br><span class="line">    <span class="keyword">int</span> b;          <span class="comment">// 4 bytes</span></span><br><span class="line">    <span class="keyword">short</span> c;        <span class="comment">// 2 bytes</span></span><br><span class="line">    <span class="keyword">char</span> pad_1[<span class="number">6</span>];  <span class="comment">// Padding 6</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> d;    <span class="comment">// 8 bytes</span></span><br><span class="line">    <span class="keyword">char</span> e;         <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="keyword">char</span> pad_2[<span class="number">7</span>];  <span class="comment">// Padding 7</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3.结构体类型本身的内存对齐</p><p>为了保证结构体内的每个成员都能够放在它自然对齐的位置上，对这个结构体本身来说最理想的内存对齐数值应该是结构体里内存对齐数值最大的成员的内存对齐数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：这篇博客写得很详细，下面的学习笔记都是参考其完成&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://blog.csdn.net/markl22222/article/details/38051483&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/markl22222/article/details/38051483&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习：类</title>
    <link href="http://yoursite.com/2018/10/19/C-%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/10/19/C-学习：类/</id>
    <published>2018-10-19T07:08:35.000Z</published>
    <updated>2018-10-19T07:11:46.060Z</updated>
    
    <content type="html"><![CDATA[<ol><li>类与对象</li><li>继承</li><li>重载</li><li>多态</li><li>抽象类</li><li><a id="more"></a></li></ol><p><br></p><h1 id="一、类与对象"><a href="#一、类与对象" class="headerlink" title="一、类与对象"></a>一、类与对象</h1><p><br></p><h2 id="1-成员函数"><a href="#1-成员函数" class="headerlink" title="1. 成员函数"></a>1. 成员函数</h2><p>定义</p><ul><li>在类定义内部定义（默认 inline）</li><li>在类的外部使用<strong>范围解析运算符 ::</strong> 来定义</li></ul><p><br></p><h2 id="2-类访问修饰符"><a href="#2-类访问修饰符" class="headerlink" title="2. 类访问修饰符"></a>2. 类访问修饰符</h2><ul><li>public：数据和函数在类的外部是可访问的，可以不使用任何成员函数来访问工有数据</li><li>private：</li><li><ul><li>数据和函数在类的外部是不可访问的</li><li><strong>只有类和友元函数可以访问私有成员，不能被派生类访问</strong></li></ul></li><li>（PS：没有使用任何访问修饰符，类的成员将被假定为私有成员）</li><li>protected：数据和函数在类的外部是不可访问的，<strong>在派生类（即子类）中是可访问的</strong></li></ul><p><br></p><h2 id="3-构造函数与析构函数"><a href="#3-构造函数与析构函数" class="headerlink" title="3. 构造函数与析构函数"></a>3. 构造函数与析构函数</h2><ol><li><p>构造函数的名称与类的名称完全相同，并且<strong>不会返回任何类型，也不会返回 void</strong>   </p><p>可以使用初始化列表来初始化字段</p></li><li><p>析构函数的名称与类的名称完全相同，只是在前面加了 ~，不会返回任何值，也不能带有任何参数</p><p>析构函数完成对象被删除前的一些清理工作</p></li></ol><p><br></p><h2 id="4-拷贝构造函数"><a href="#4-拷贝构造函数" class="headerlink" title="4. 拷贝构造函数"></a>4. 拷贝构造函数</h2><p>拷贝构造函数是一种特殊的构造函数，使用同一类中之前创建的对象来初始化新创建的对象</p><p>拷贝造函数的名称与类的名称完全相同，并且不会返回任何类型，其<strong>参数是同类对象的引用</strong></p><p><br></p><h2 id="5-友元函数"><a href="#5-友元函数" class="headerlink" title="5. 友元函数"></a>5. 友元函数</h2><p>类的友元函数<strong>『并不是成员函数』</strong>，是定义在类外部，但<strong>有权访问类的所有私有和保护成员</strong></p><p>在类定义中该函数原型前使用关键字 <strong>friend</strong></p><p><br></p><h2 id="6-内联函数"><a href="#6-内联函数" class="headerlink" title="6. 内联函数"></a>6. 内联函数</h2><p>如果一个函数是内联的，那么在编译时，编译器会把出现内联函数调用表达式的地方，用内联函数的函数体进行替换</p><p>在函数名前面放置关键字 <strong>inline</strong></p><p>内联函数是为了解决程序中函数调用的效率问题，就是<strong>空间换时间</strong>，所以内联函数一般都是小函数</p><p>注意：</p><ul><li><p>在内联函数内不允许使用循环语句和开关语句</p></li><li><p>内联函数的定义必须出现在内联函数第一次调用之前</p></li><li><p><strong>在类内部定义的函数会默认声明为inline函数，所有不用显示地去声明inline</strong></p><p><br></p></li></ul><h2 id="7-this-指针"><a href="#7-this-指针" class="headerlink" title="7. this 指针"></a>7. this 指针</h2><p>每一个对象都能通过 this 指针来访问自己的地址</p><p>this指针是所有成员函数的隐含参数，<strong>在成员函数内部，this指针可以用来指向目前调用的对象</strong></p><p>友元函数没有 this 指针，因为不是类的成员</p><p><br></p><h2 id="8-静态成员"><a href="#8-静态成员" class="headerlink" title="8. 静态成员"></a>8. 静态成员</h2><p>静态成员在类的所有对象中是共享的</p><h3 id="1）-静态成员数据"><a href="#1）-静态成员数据" class="headerlink" title="1） 静态成员数据"></a>1） 静态成员数据</h3><p>如果不存在初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零</p><p><strong>不能把静态数据的初始化放在类的定义</strong>中，而是在类的外部使用范围解析运算符 :: 来进行初始化</p><p><br></p><h3 id="2）-静态成员函数"><a href="#2）-静态成员函数" class="headerlink" title="2） 静态成员函数"></a>2） 静态成员函数</h3><p>静态成员函<strong>与类的对象是独立的</strong>，<strong>在类对象不存在的情况下也能被调用</strong></p><p><strong>『静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数，且没有 this 指针』</strong></p><p>这个例子挺好的：<a href="http://www.runoob.com/cplusplus/cpp-static-members.html" target="_blank" rel="noopener">http://www.runoob.com/cplusplus/cpp-static-members.html</a></p><p><br></p><h1 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h1><h2 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h2><p>一个类可以派生自多个类，即一个（子类/派生类）可以有多个（父类/基类）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;派生类名&gt;:</span>&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="2-继承方式不同，基类成员在派生类中的访问属性不同"><a href="#2-继承方式不同，基类成员在派生类中的访问属性不同" class="headerlink" title="2. 继承方式不同，基类成员在派生类中的访问属性不同"></a>2. 继承方式不同，基类成员在派生类中的访问属性不同</h2><p>三种继承方式，使得基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：</p><ul><li>public 继承：public, protected, private</li><li>protected 继承：protected, protected, private</li><li>private 继承：private, private, private</li></ul><p><br></p><h2 id="3-派生类中构造函数和析构函数的调用"><a href="#3-派生类中构造函数和析构函数的调用" class="headerlink" title="3. 派生类中构造函数和析构函数的调用"></a>3. 派生类中构造函数和析构函数的调用</h2><ul><li>创建子类时先调用父类的构造函数然后再调用自己的构造函数</li><li>子类先调用自身的析构函数再调用父类的析构函数</li></ul><p><br></p><h3 id="1）构造函数不能是虚函数"><a href="#1）构造函数不能是虚函数" class="headerlink" title="1）构造函数不能是虚函数"></a>1）构造函数不能是虚函数</h3><p>从继承来讲，总是要先构造父类对象,然后才能是子类对象</p><p>虚函数的作用在于通过父类的指针或者引用，来调用子类的成员函数，而构造函数是在创建对象时<strong>自动调用</strong>，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数</p><p><br></p><h3 id="2）通常将基类的析构函数定义为虚函数的原因"><a href="#2）通常将基类的析构函数定义为虚函数的原因" class="headerlink" title="2）通常将基类的析构函数定义为虚函数的原因"></a>2）通常将基类的析构函数定义为虚函数的原因</h3><ul><li>当派生类指针指向派生类时，先调用派生类的析构函数再调用基类的析构函数</li><li>当基类指针指向派生类对象实现多态时，在析构时<strong>为了防止只析构基类而不析构派生类</strong>，一般会将基类析构函数定义为虚基类，这样就会先调用派生类析构函数，再调用基类析构函数</li></ul><p><br></p><h1 id="三、函数重载和运算符重载"><a href="#三、函数重载和运算符重载" class="headerlink" title="三、函数重载和运算符重载"></a>三、函数重载和运算符重载</h1><p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义不同</p><p>重载的运算符其实是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符构成</p><p>并且重载运算符这个特殊函数是有返回类型和参数列表</p><p><br></p><p>注意：</p><ul><li>运算重载符不可以改变操作数的个数</li><li>运算重载符不可以改变优先级</li><li>运算重载符不可以改变结合性</li><li>有些运算符是不可重载的 </li></ul><p><br></p><h1 id="四、多态"><a href="#四、多态" class="headerlink" title="四、多态"></a>四、多态</h1><p>多态发生的条件：<strong>多态只在『基类指针或引用指向派生类对象』的时候才发生，并且基类函数是虚函数</strong></p><p><br></p><h2 id="1-基类、派生类指针指向的对象"><a href="#1-基类、派生类指针指向的对象" class="headerlink" title="1. 基类、派生类指针指向的对象"></a>1. 基类、派生类指针指向的对象</h2><ul><li>基类指针指向派生类对象，是安全的</li><li>派生类指针指向基类对象，会产生编译错误</li><li>派生类指针指向派生类对象，调用的是派生类的成员</li></ul><h2 id="2-虚函数"><a href="#2-虚函数" class="headerlink" title="2. 虚函数"></a>2. 虚函数</h2><p>在基类中使用关键字 <strong>virtual</strong> 声明的函数，派生类中重新定义基类中定义的虚函数</p><p>虚函数使用条件是当<strong>『基类指针指向派生类对象』</strong>时，会告诉编译器不要<strong>静态链接</strong>到基类的虚函数，而是根据所调用的对象类型<strong>动态链接</strong>到派生类中的成员函数</p><p>基类的指针指向派生类的对象，当调用同名的成员函数时：</p><ul><li>如果在基类中成员函数为虚函数，那么基类指针调用的就是派生类的同名函数</li><li>如果基类中成员函数为非虚函数，则调用的是基类的成员函数</li></ul><h2 id="3-纯虚函数"><a href="#3-纯虚函数" class="headerlink" title="3. 纯虚函数"></a>3. 纯虚函数</h2><p>在基类中不给虚函数提供有意义的定义实现，纯虚函数的意义在于定义抽象类</p><p>声明是在普通的虚函数后面加上”=0”  <code>virtual int area() = 0;</code></p><p><br></p><h1 id="五、抽象类"><a href="#五、抽象类" class="headerlink" title="五、抽象类"></a>五、抽象类</h1><p>抽象类：如果类中<strong>至少有一个函数被声明为纯虚函数</strong>，则这个类就是抽象类</p><p>抽象类不能被用于实例化对象</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;类与对象&lt;/li&gt;
&lt;li&gt;继承&lt;/li&gt;
&lt;li&gt;重载&lt;/li&gt;
&lt;li&gt;多态&lt;/li&gt;
&lt;li&gt;抽象类&lt;/li&gt;
&lt;li&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习：标准库和标准模板库</title>
    <link href="http://yoursite.com/2018/10/19/C-%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/"/>
    <id>http://yoursite.com/2018/10/19/C-学习：标准库和标准模板库/</id>
    <published>2018-10-19T07:06:09.000Z</published>
    <updated>2018-10-19T07:08:01.720Z</updated>
    
    <content type="html"><![CDATA[<p>C++标准库包括标准模板库STL</p><a id="more"></a><p><br></p><h2 id="一、标准库"><a href="#一、标准库" class="headerlink" title="一、标准库"></a>一、标准库</h2><ul><li>C++ 标准库头文件 \&lt;xxx>，C++标准库中涵盖C库功能的子库，通常头文件以c开头\&lt;cxxx></li><li>C 标准库头文件 \&lt;xxx.h></li></ul><p>注意：<strong>不同操作西都有其自己的 C++ 标准库实现</strong>， C++编译器在实现 C++ 标准库过程中必须依赖不同操作系统所提供的系统调用接口</p><p><br></p><h2 id="二、标准模板库"><a href="#二、标准模板库" class="headerlink" title="二、标准模板库"></a>二、标准模板库</h2><p>C++标准库包括标准模板库STL</p><p>STL的代码从广义上分为三类：<strong>algorithm（算法）、container（容器）和 iterator（迭代器）</strong>，几乎所有的代码都采用了模板类和模板函数的方式</p><p><br></p><p><strong>容器</strong></p><table><thead><tr><th>数据结构</th><th>描述</th><th>头文件</th></tr></thead><tbody><tr><td>向量(vector)</td><td>连续存储的元素</td><td><vector></vector></td></tr><tr><td>列表(list)</td><td>由节点组成的双向链表，每个结点包含着一个元素</td><td><list></list></td></tr><tr><td>双队列(deque)</td><td>连续存储的指向不同元素的指针所组成的数组</td><td><deque></deque></td></tr><tr><td>集合(set)</td><td>由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序</td><td><set></set></td></tr><tr><td>多重集合(multiset)</td><td>允许存在两个次序相等的元素的集合</td><td><set></set></td></tr><tr><td>栈(stack)</td><td>后进先出的值的排列</td><td><stack></stack></td></tr><tr><td>队列(queue)</td><td>先进先出的执的排列</td><td><queue></queue></td></tr><tr><td>优先队列(priority_queue)</td><td>元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列</td><td><queue></queue></td></tr><tr><td>映射(map)</td><td>由{键，值}对组成的集合，以某种作用于键对上的谓词排列</td><td><map></map></td></tr><tr><td>多重映射(multimap)</td><td>允许键对有相等的次序的映射</td><td><map></map></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++标准库包括标准模板库STL&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统启动过程</title>
    <link href="http://yoursite.com/2018/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/10/18/操作系统启动过程/</id>
    <published>2018-10-18T14:13:16.000Z</published>
    <updated>2018-10-19T03:38:45.413Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统启动过程</p><p><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/02/booting.html</a></p><ol><li>BIOS 硬件自检</li><li>根据启动顺序，定位到存储设备</li><li>根据主引导记录中的分区表（存储设备的第一个扇区），定位到主分区</li></ol><a id="more"></a><h2 id="一、BIOS"><a href="#一、BIOS" class="headerlink" title="一、BIOS"></a>一、BIOS</h2><p>计算机通电后，第一件事就是读取被刷入ROM芯片的开机程序，这块芯片里的程序叫做<strong>『基本输入输出系统，Basic Input/Output System，BIOS』</strong></p><p>BIOS 程序首先检查，计算机硬件能否满足运行的基本条件，这叫做<strong>『硬件自检，Power-On Self-Test，POST』</strong></p><h2 id="二、主引导记录"><a href="#二、主引导记录" class="headerlink" title="二、主引导记录"></a>二、主引导记录</h2><h3 id="1-启动顺序"><a href="#1-启动顺序" class="headerlink" title="1. 启动顺序"></a>1. 启动顺序</h3><p>BIOS 根据启动顺序，把控制权转交给启动顺序排在第一位的储存设备，读取该设备的第一个扇区，即主引导记录，进行下一阶段的启动程序</p><p>启动顺序，Boot Sequence：外部储存设备的排序，排在前面的设备就是优先转交控制权的设备</p><p>主引导记录，Master boot record，MBR：计算机读取该设备的<strong>第一个扇区</strong>，也就是最前面的512个字节</p><p>如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动。如果不是，表明设备不能用于启动，控制权于是被转交给启动顺序中的下一个设备</p><h3 id="2-主引导记录"><a href="#2-主引导记录" class="headerlink" title="2. 主引导记录"></a>2. 主引导记录</h3><p>第一个扇区，即最前面的512个字节，就叫做<strong>『主引导记录，Master boot record，MBR』</strong>主要是告诉计算机到硬盘的哪一个位置去找操作系统。</p><p>主引导记录由三个部分组成：</p><p>（1） 第1-446字节：调用操作系统的机器码</p><p>（2） 第447-510字节：分区表</p><p>可以将硬盘分成若干个区安装不同的操作系统，一个硬盘最多只能分四个一级分区，又叫 <strong>“主分区”</strong></p><p>（3） 第511-512字节：主引导记录签名（0x55和0xAA）</p><h2 id="三、硬盘启动"><a href="#三、硬盘启动" class="headerlink" title="三、硬盘启动"></a>三、硬盘启动</h2><p>计算机的控制权转交给硬盘的某个分区</p><h3 id="1-卷引导记录"><a href="#1-卷引导记录" class="headerlink" title="1. 卷引导记录"></a>1. 卷引导记录</h3><p>四个主分区里面，只有一个是激活的</p><p>计算机会读取激活分区的第一个扇区，叫做”卷引导记录”，作用是告诉计算机，操作系统在这个分区里的位置，计算机加载操作系统</p><h3 id="2-启动管理器"><a href="#2-启动管理器" class="headerlink" title="2. 启动管理器"></a>2. 启动管理器</h3><p>计算机读取”主引导记录”前面1-446个字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot loader），由用户选择启动哪一个操作系统</p><h2 id="四、操作系统"><a href="#四、操作系统" class="headerlink" title="四、操作系统"></a>四、操作系统</h2><p>控制权转交给操作系统后，<strong>操作系统的内核首先被载入内存</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统启动过程&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/02/booting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ruanyifeng.com/blog/2013/02/booting.html&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BIOS 硬件自检&lt;/li&gt;
&lt;li&gt;根据启动顺序，定位到存储设备&lt;/li&gt;
&lt;li&gt;根据主引导记录中的分区表（存储设备的第一个扇区），定位到主分区&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>处理器</title>
    <link href="http://yoursite.com/2018/10/18/%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://yoursite.com/2018/10/18/处理器/</id>
    <published>2018-10-18T01:34:38.000Z</published>
    <updated>2018-10-18T02:04:59.204Z</updated>
    
    <content type="html"><![CDATA[<p>指令集和处理器架构：<a href="https://www.zhihu.com/question/23474438" target="_blank" rel="noopener">https://www.zhihu.com/question/23474438</a></p><p>（我的理解：处理器架构是指硬件设计，对应相应指令集，即二进制机器码，实现某种功能，两者是配套的）</p><a id="more"></a><p><br></p><h2 id="一、指令集"><a href="#一、指令集" class="headerlink" title="一、指令集"></a>一、指令集</h2><p>指令集，规定处理器相应操作，通过指令集去控制处理器实现相应功能，但处理器是一堆硬件电路，只能识别二进制数据，所以指令集是由一堆二进制数据组成</p><p>（我的理解： CPU 读入调用指令集的命令，通过指令集来实现具体的功能）</p><p><br></p><h2 id="二、处理器架构"><a href="#二、处理器架构" class="headerlink" title="二、处理器架构"></a>二、处理器架构</h2><p><strong>处理器架构是用硬件电路实现指令集所规定的操作运算，所以是指令集决定了处理器的架构</strong></p><p>四大CPU体系架构：</p><ul><li>x86 ：Intel、AMD（复杂指令集）</li><li>ARM架构：ARM公司（精简指令集）</li><li>PowerPC架构：IBM公司（精简指令集）</li><li>MIPS架构（精简指令集）</li></ul><p><br></p><p>Intel 处理器分类：<a href="https://www.zhihu.com/question/32669957" target="_blank" rel="noopener">https://www.zhihu.com/question/32669957</a></p><p><img src="https://pic3.zhimg.com/v2-73ba36e9a085e8f666d039a1a465e44a_r.jpg" alt="preview"></p><p><br></p><h2 id="三、汇编语言"><a href="#三、汇编语言" class="headerlink" title="三、汇编语言"></a>三、汇编语言</h2><p>汇编语言是为了方便人类操作指令集，所以汇编语言是和指令集配套</p><p>汇编语言通过汇编器转为二进制</p><p><br></p><h2 id="四、操作系统"><a href="#四、操作系统" class="headerlink" title="四、操作系统"></a>四、操作系统</h2><p>指令集是二进制，操作系统其实是应用程序，普通应用程序和操作系统都需要经过编译器，编译为二进</p><p>不同CPU对应的指令集不一样，对应的编译器也不一样，所以相同高级语言用不同编译器编译得到的二进制代码是不同的</p><p>windows 只能在x86架构的CPU上运行，因为Windows系统设计的时候是基于x86架构</p><p>Linux 可以运行在不同架构的CPU，因为Linux 的不同版本可以支持不同架构的指令集</p><p>（我的理解：编译器最后编译生成的二进制就是各条指令集）</p><p><br></p><h2 id="五、汇编器和编译器的区别"><a href="#五、汇编器和编译器的区别" class="headerlink" title="五、汇编器和编译器的区别"></a>五、汇编器和编译器的区别</h2><p>汇编器，用来编译汇编语言的</p><p>编译器的作用是，将源文件，这是已经是二进制代码了。，最后由连接器（Linker），将目标代码连接起来，这样就形成了可执行文件</p><h2 id="六、CPU性能指标"><a href="#六、CPU性能指标" class="headerlink" title="六、CPU性能指标"></a>六、CPU性能指标</h2><h3 id="1-字长"><a href="#1-字长" class="headerlink" title="1.字长"></a>1.字长</h3><p>单位时间内CPU能处理的二进制数据的位数，32位、64位</p><h3 id="2-主频"><a href="#2-主频" class="headerlink" title="2.主频"></a>2.主频</h3><p>CPU内的动作都是按<strong>时钟周期</strong>计算，一秒内有几个时钟周期，主频就是多少赫兹</p><h3 id="3-外频"><a href="#3-外频" class="headerlink" title="3.外频"></a>3.外频</h3><p>外频是由主板为CPU提供的基准时钟频率，就是主板规定CPU<strong>1秒内对外进行数据交换的次数</strong></p><h2 id="七、核心数、线程数"><a href="#七、核心数、线程数" class="headerlink" title="七、核心数、线程数"></a>七、核心数、线程数</h2><p>核心数：指硬件上存在着几个核心个数。比如，双核就是包括2个相对独立的CPU核心单元组，四核就包含4个相对独立的CPU核心单元组。</p><p>线程数：线程数概念仅仅只针对Intel的CPU才有用，因为它是通过Intel<strong>超线程</strong>技术来实现的，就是可以<strong>模拟出的CPU核心数</strong>，一个核心可以对应两个线程，即可以同时运行两个线程</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;指令集和处理器架构：&lt;a href=&quot;https://www.zhihu.com/question/23474438&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/23474438&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（我的理解：处理器架构是指硬件设计，对应相应指令集，即二进制机器码，实现某种功能，两者是配套的）&lt;/p&gt;
    
    </summary>
    
    
      <category term="硬件" scheme="http://yoursite.com/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>远程登陆</title>
    <link href="http://yoursite.com/2018/10/17/%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86/"/>
    <id>http://yoursite.com/2018/10/17/远程登陆/</id>
    <published>2018-10-17T12:57:24.000Z</published>
    <updated>2018-10-17T13:00:11.323Z</updated>
    
    <content type="html"><![CDATA[<ul><li>局域网远程控制：<a href="https://jingyan.baidu.com/article/84b4f565d448f760f6da32e2.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/84b4f565d448f760f6da32e2.html</a></li></ul><ul><li>SSH 远程登陆：<a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a></li></ul><p>（可以不在同一个局域网）</p><p>PS：最近实在忙，没时间研究，只能用到什么，先记录下来</p><a id="more"></a><p><br></p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>SSH是一种网络协议，用于计算机之间的加密登录，采用了公钥加密</p><p>GitHub 就是用SSH</p><p><br></p><h3 id="1-公开密钥加密"><a href="#1-公开密钥加密" class="headerlink" title="1. 公开密钥加密"></a>1. 公开密钥加密</h3><p>公开密钥加密也称为非对称加密，需要两个密钥，一个是公开密钥，另一个是私有密。其中一个密钥把明文加密后所得的密文，只能用相对应的另一个密钥才能解密得到原本的明文，由于加密和解密需要两个不同的密钥，故称为<strong>非对称加密</strong>。</p><p>原理：</p><p>（1）远程主机收到用户的登录请求，把自己的<strong>公钥</strong>发给用户</p><p>（2）用户使用这个公钥，将<strong>登录密码</strong>加密后，发送回来</p><p>（3）远程主机用自己的<strong>私钥</strong>，解密登录密码，如果密码正确，就同意用户登录</p><p><br></p><h3 id="2-中间人攻击"><a href="#2-中间人攻击" class="headerlink" title="2. 中间人攻击"></a>2. 中间人攻击</h3><p>如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。</p><p>如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码，再用这个密码登录远程主机。</p><p><br></p><h3 id="3-公钥登陆"><a href="#3-公钥登陆" class="headerlink" title="3. 公钥登陆"></a>3. 公钥登陆</h3><p>使用密码登录，非常麻烦，SSH 还提供了公钥登录，省去输入密码的步骤</p><p>原理：</p><p>用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;局域网远程控制：&lt;a href=&quot;https://jingyan.baidu.com/article/84b4f565d448f760f6da32e2.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://jingyan.baidu.com/article/84b4f565d448f760f6da32e2.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;SSH 远程登陆：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（可以不在同一个局域网）&lt;/p&gt;
&lt;p&gt;PS：最近实在忙，没时间研究，只能用到什么，先记录下来&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文本文件和二进制文件</title>
    <link href="http://yoursite.com/2018/09/20/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/09/20/文本文件和二进制文件/</id>
    <published>2018-09-20T08:02:13.000Z</published>
    <updated>2018-09-20T08:03:39.520Z</updated>
    
    <content type="html"><![CDATA[<p>二进制文件和文本文件的区别 ：<a href="https://www.jianshu.com/p/af0b4f8b030e" target="_blank" rel="noopener">https://www.jianshu.com/p/af0b4f8b030e</a></p><a id="more"></a><p><br></p><h4 id="（1）文本文件"><a href="#（1）文本文件" class="headerlink" title="（1）文本文件"></a>（1）文本文件</h4><ul><li><p>基于字符编码的文件，常见的编码有 ASCII 编码，UNICODE 编码</p></li><li><p><strong>只能存储 char 型字符变量</strong></p></li><li><p>数据通常是固定长度，以ASCII为例，每个字符都是1个字节</p></li><li><p>文本文件编辑器就可以读写</p></li><li><p>进行编辑的最小单位是字节(byte)</p></li><li><p>纯文本文件没有控制格式的信息，实际上也是一种<strong>特殊的二进制文件</strong></p><p><br></p></li></ul><h4 id="（2）二进制文件"><a href="#（2）二进制文件" class="headerlink" title="（2）二进制文件"></a>（2）二进制文件</h4><ul><li>基于值编码的文件</li><li><strong>可以存储 char/int/short/long/float/……各种变量值</strong></li><li>不同变量占据长度不同，short占两个字节，int占四个字节，float占8个字节……</li><li>二进制文件<strong>需要特别的解码器</strong>，比如bmp文件需要图像查看器，rmvb需要播放器</li><li>进行编辑的最小单位则是位(bit)（但，不会直接通过手工的方式对二进制文件进行编辑）</li><li>二进制文件，都往往有一个头 head，提供文件信息和解释方式</li></ul><p><strong>记事本</strong>只能够识别字符类型，支持文本文件而不支持二进制文件。如果用记事本打开文本文件一切正常，如果打开的是二进制文件就会出现乱码，但也有不乱码的地方，那些地方都是<strong>字符编码</strong>的，而对于int、double 等类型所对应的值都是乱码的。</p><p>PS：字符编码有 ASCII、Unicode、GBK 和 UTF-8 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二进制文件和文本文件的区别 ：&lt;a href=&quot;https://www.jianshu.com/p/af0b4f8b030e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/af0b4f8b030e&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CUDA和OpenCL</title>
    <link href="http://yoursite.com/2018/09/17/CUDA%E5%92%8COpenCL/"/>
    <id>http://yoursite.com/2018/09/17/CUDA和OpenCL/</id>
    <published>2018-09-17T07:24:35.000Z</published>
    <updated>2018-09-17T07:26:39.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要-OpenCL-和-CUDA？"><a href="#为什么需要-OpenCL-和-CUDA？" class="headerlink" title="为什么需要 OpenCL 和 CUDA？"></a>为什么需要 OpenCL 和 CUDA？</h2><p>当不使用异构系统架构，数据在 CPU和GPU之间的流动，会造成很大的开销。</p><p>由于CPU和GPU拥有独立的地址空间，当控制数据在CPU和GPU之间流动时， CPU代码通过系统调用向GPU发送任务，此类系统调用一般由GPU驱动程序管理，这么多的环节造成了很大的调用开销。</p><a id="more"></a><p><br></p><h2 id="OpenCL-和-CUDA"><a href="#OpenCL-和-CUDA" class="headerlink" title="OpenCL 和 CUDA"></a>OpenCL 和 CUDA</h2><h3 id="1-流程"><a href="#1-流程" class="headerlink" title="1. 流程"></a>1. 流程</h3><p>CUDA 和 OpenCL 的开发模型基本一致，都是由 Host 和 Device 组成</p><ul><li>Host：CPU 和Host存储空间，串行代码</li><li>Device: GPU 和Device存储空间，并行代码</li></ul><p>对于异构系统，程序首先执行 Host 程序，然后由 Host 程序激活 Device 程序执行kernel，<strong>kernel 程序是指 Device 设备上执行的代码</strong>，它是直接在设备上执行，受具体设备的限制。</p><p><br></p><h3 id="2-从程序理解流程"><a href="#2-从程序理解流程" class="headerlink" title="2. 从程序理解流程"></a>2. 从程序理解流程</h3><p>PS：只是非常简单的对数据的理解</p><ul><li>从 CPU 拷贝数据到 GPU</li><li>调用 kernel 来操作存储在 GPU 的数据</li><li>将操作结果从 GPU 拷贝至 CPU</li></ul><p><br></p><h3 id="3-OpenCL-和-CUDA-的区别"><a href="#3-OpenCL-和-CUDA-的区别" class="headerlink" title="3. OpenCL 和 CUDA 的区别"></a>3. OpenCL 和 CUDA 的区别</h3><ul><li>OpenCL 是一个开源的标准，通用性好</li><li>CUDA 只针对NVIDIA的GPU产品</li></ul><p>CUDA 和 OpenCL 的差别主要表现在调用 Device 的 API 的差异</p><p>cl-CUDA</p><p>在通用Lisp程序中使用NVIDIA CUDA的库</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么需要-OpenCL-和-CUDA？&quot;&gt;&lt;a href=&quot;#为什么需要-OpenCL-和-CUDA？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要 OpenCL 和 CUDA？&quot;&gt;&lt;/a&gt;为什么需要 OpenCL 和 CUDA？&lt;/h2&gt;&lt;p&gt;当不使用异构系统架构，数据在 CPU和GPU之间的流动，会造成很大的开销。&lt;/p&gt;
&lt;p&gt;由于CPU和GPU拥有独立的地址空间，当控制数据在CPU和GPU之间流动时， CPU代码通过系统调用向GPU发送任务，此类系统调用一般由GPU驱动程序管理，这么多的环节造成了很大的调用开销。&lt;/p&gt;
    
    </summary>
    
    
      <category term="硬件" scheme="http://yoursite.com/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>caffe框架</title>
    <link href="http://yoursite.com/2018/09/16/caffe%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2018/09/16/caffe框架/</id>
    <published>2018-09-16T01:03:36.000Z</published>
    <updated>2018-09-16T01:05:40.019Z</updated>
    
    <content type="html"><![CDATA[<p>PS：我是没有打算使用 caffe，所以这篇博文不适合当作入门教材</p><p>但是tiny dnn的一个模块里面提供了caffe训练网络的接口，顺便就学习了一下，还是很有收获的</p><a id="more"></a><p><br></p><h2 id="一、caffe主要结构"><a href="#一、caffe主要结构" class="headerlink" title="一、caffe主要结构"></a>一、caffe主要结构</h2><p>这部分是完全参考了这篇博文：</p><p><a href="http://noahsnail.com/2016/12/05/2016-12-5-Caffe%E7%9A%84%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">http://noahsnail.com/2016/12/05/2016-12-5-Caffe%E7%9A%84%E6%A1%86%E6%9E%B6/</a></p><p>caffe代码本身非常模块化，主要由4部分组成Blob，Layer，Net 和 Solver</p><ul><li>Blob</li></ul><p>Blob主要用来表示网络中的数据，包括训练数据，网络各层自身的参数，网络之间传递的数据都是通过Blob来实现的，同时Blob数据也支持在CPU与GPU上存储，能够在两者之间做同步。</p><ul><li>Layer</li></ul><p>Layer是对神经网络中各种层的一个抽象，包括卷积层和下采样层，还有全连接层和各种激活函数层等等。同时每种Layer都实现了前向传播和反向传播，并通过Blob来传递数据。</p><ul><li>Net</li></ul><p>Net是对整个神经网络的表示，由各种Layer前后连接组合而成，也是要构建的网络模型。</p><ul><li>Solver</li></ul><p>Solver定义了针对Net网络模型的求解方法，记录神经网络的训练过程，保存神经网络模型参数，中断并恢复网络的训练过程。通过配置文件自定义Solver，能够实现不同的神经网络求解方式。</p><p><br></p><h2 id="二、caffe采用读入配置文件的方式进行训练"><a href="#二、caffe采用读入配置文件的方式进行训练" class="headerlink" title="二、caffe采用读入配置文件的方式进行训练"></a>二、caffe采用读入配置文件的方式进行训练</h2><ul><li><p>caffe.proto文件编写</p></li><li><p>编译生成caffe.pb.cc与caffe.pb.h文件</p></li><li><p>编写网络结构与模型训练的配置文件</p><ul><li><p><strong>slover.prototxt</strong>：</p><p>描述网络训练时的各种参数文件，如训练的策略，学习率的变化率，模型保存的频率等</p></li><li><p><strong>net.prototxt：</strong></p><p>描述网络的网络结构</p></li></ul></li></ul><ul><li>训练结果输出到 caffemodel</li></ul><p><br></p><p><strong>其中关于caffe.proto文件的作用：</strong></p><ul><li>定义的结构化数据，用于构建Caffe网络，即<strong>.prototxt文件中的每个字段名要在caffe.proto中存在</strong></li><li>负责.caffemodel数据文件的存储和读取</li><li>每次向Caffe中增加新的层，相应的caffe.proto文件也需调整</li><li>注意选择Protobuf的版本要与Caffe中的一致</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：我是没有打算使用 caffe，所以这篇博文不适合当作入门教材&lt;/p&gt;
&lt;p&gt;但是tiny dnn的一个模块里面提供了caffe训练网络的接口，顺便就学习了一下，还是很有收获的&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="caffe" scheme="http://yoursite.com/tags/caffe/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/09/15/Google-Protocol-Buffers/"/>
    <id>http://yoursite.com/2018/09/15/Google-Protocol-Buffers/</id>
    <published>2018-09-15T09:12:19.410Z</published>
    <updated>2018-10-19T03:38:06.292Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux（五）—— .o、.a、.so</title>
    <link href="http://yoursite.com/2018/09/13/Linux%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94-o%E3%80%81-a%E3%80%81-so/"/>
    <id>http://yoursite.com/2018/09/13/Linux（五）——-o、-a、-so/</id>
    <published>2018-09-13T12:58:35.000Z</published>
    <updated>2018-09-13T13:00:27.412Z</updated>
    
    <content type="html"><![CDATA[<p>PS：Linux与windows的对应起来看</p><p><a href="https://blog.csdn.net/chlele0105/article/details/23691147" target="_blank" rel="noopener">https://blog.csdn.net/chlele0105/article/details/23691147</a></p><a id="more"></a><h2 id="windows下obj、lib、dll"><a href="#windows下obj、lib、dll" class="headerlink" title="windows下obj、lib、dll"></a>windows下obj、lib、dll</h2><ol><li><p>lib  是静态链接库的库文件</p></li><li><p>dll  是动态链接库的库文件</p></li><li><p>obj 是中间代码</p><p>因为不可能一次得到目标文件，一个exe需要很多的cpp文件生成，而编译器一次只能编译一个cpp文件，这样编译器编译好一个cpp以后会将其编译成obj，当所有必须要的cpp都编译成obj以后，再统一link成所需要的exe</p></li></ol><p><br></p><h2 id="linux下-o、-a、-so"><a href="#linux下-o、-a、-so" class="headerlink" title="linux下 .o、.a、.so"></a>linux下 .o、.a、.so</h2><ul><li><p>.o      是目标文件，相当于windows中的.obj文件 </p></li><li><p>.a      是静态库，是好多个.o合在一起，用于静态连接 ，相当于windows下的lib</p></li><li><p>.so    是共享库（shared object）用于动态链接，相当于windows下的dll </p><p>相对于静态函数库，共享函数库在编译的时候，并没有被编译进目标代码中</p><p>当程序执行到相关函数时才调用共享函数库里相应的函数</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：Linux与windows的对应起来看&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/chlele0105/article/details/23691147&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/chlele0105/article/details/23691147&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CMake（三）—— Linux下使用CMake</title>
    <link href="http://yoursite.com/2018/09/13/CMake%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8CMake/"/>
    <id>http://yoursite.com/2018/09/13/CMake（三）——-Linux下使用CMake/</id>
    <published>2018-09-13T09:16:21.000Z</published>
    <updated>2018-09-13T09:19:01.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CMake在Linux下的使用"><a href="#CMake在Linux下的使用" class="headerlink" title="CMake在Linux下的使用"></a>CMake在Linux下的使用</h2><ol><li>工程文件下包含你需要的cpp和CMakeLists.txt</li><li>在工程目录下打开终端</li></ol><ul><li><code>mkdir build</code>        新建一个文件夹放编译的文件（和cpp、CMakeLists.txt分开放）</li><li><code>cd ./build</code>          进入该文件目录</li><li><code>cmake ../</code>            build目录下生成一系列文件</li><li><code>make</code>                     在build目录下生成可执行文件</li><li><code>./可执行文件</code>        执行可执行文件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CMake在Linux下的使用&quot;&gt;&lt;a href=&quot;#CMake在Linux下的使用&quot; class=&quot;headerlink&quot; title=&quot;CMake在Linux下的使用&quot;&gt;&lt;/a&gt;CMake在Linux下的使用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;工程文件下包含你需要的c
      
    
    </summary>
    
    
      <category term="CMake" scheme="http://yoursite.com/tags/CMake/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu（三）—— opencv、cheese安装</title>
    <link href="http://yoursite.com/2018/09/13/ubuntu%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-opencv%E3%80%81cheese%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2018/09/13/ubuntu（三）——-opencv、cheese安装/</id>
    <published>2018-09-13T07:55:56.000Z</published>
    <updated>2018-09-17T06:40:58.386Z</updated>
    
    <content type="html"><![CDATA[<p>PS：那天晚上opencv从九点半开始装到十点半，人都快要崩溃了，结果第二天又重新编译了一遍，感觉自己真的是一个人在黑暗中摸索 ~</p><a id="more"></a><p><br></p><h2 id="一、安装-opencv"><a href="#一、安装-opencv" class="headerlink" title="一、安装 opencv"></a>一、安装 opencv</h2><ol><li><p>ubuntu 安装 opencv 的流程</p><p><a href="https://blog.csdn.net/JohinieLi/article/details/79885820" target="_blank" rel="noopener">https://blog.csdn.net/JohinieLi/article/details/79885820</a></p></li><li><p>测试opencv是否安装成功   </p><p>使用 <code>smaples/cpp/example_cmake</code> 中的样例去测试opencv是否安装成    </p><p>在打开摄像头时，其实程序运行正确，打开了摄像头反而报错了      </p><p> ERROR: V4L/V4L2: VIDIOC_S_CROP                   </p><p><strong>是依赖的库 libv4l-dev 没有装</strong>，所以需要对opencv重新编译      </p></li><li><p>opencv重新编译，解决方法如下：</p><p>opencv 在 ubuntu 中需要的依赖   <a href="https://blog.csdn.net/suochao90/article/details/7530233" target="_blank" rel="noopener">https://blog.csdn.net/suochao90/article/details/7530233</a></p><p>安装完依赖库，对opencv 重新编译  <a href="https://blog.csdn.net/m0_37811342/article/details/802278" target="_blank" rel="noopener">https://blog.csdn.net/m0_37811342/article/details/802278</a></p></li><li><p>但是程序提示 select time out，后来才知道是 wecamera 的驱动没有装</p><p>如果之前没有装webcamera的驱动 ~ 请看第二部分cheese</p></li></ol><p><br></p><h2 id="二、Ubuntu中通过Cheese支持Webcam"><a href="#二、Ubuntu中通过Cheese支持Webcam" class="headerlink" title="二、Ubuntu中通过Cheese支持Webcam"></a>二、Ubuntu中通过Cheese支持Webcam</h2><p>PS：刚开始我不能理解，为什么主机上已经装过摄像头驱动，虚拟机还要装一遍，那是我对驱动是什么没有理解 ~ </p><h3 id="1-驱动"><a href="#1-驱动" class="headerlink" title="1. 驱动"></a>1. 驱动</h3><p>『<strong>驱动程序提供了硬件到操作系统的一个接口。</strong>』（注意：是<strong>操作系统</strong>！！！）</p><p>相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作。</p><p>正因为这个原因，驱动程序在系统中的所占的地位十分重要，一般当操作系统安装完毕后，首要的便是安装硬件设备的驱动程序。</p><p><br></p><h3 id="2-通过Cheese支持Webcam"><a href="#2-通过Cheese支持Webcam" class="headerlink" title="2. 通过Cheese支持Webcam"></a>2. 通过Cheese支持Webcam</h3><p><a href="https://blog.csdn.net/JNingWei/article/details/79945300" target="_blank" rel="noopener">https://blog.csdn.net/JNingWei/article/details/79945300</a></p><p>大多数webcam生产商并不为Linux系统提供驱动，包括Ununtu</p><p>解决方法就是：『<strong>可以通过安装cheese来激活Ubuntu自带的摄像头UVC驱动</strong>』（不过需要保证，摄像头是支持 UVC驱动）</p><p><br></p><h3 id="3-cheese安装"><a href="#3-cheese安装" class="headerlink" title="3. cheese安装"></a>3. cheese安装</h3><p>PS：刚开始以为 cheese 是硬件驱动程序，后来才明白过来，它不过是个拍照录像的应用程序，但是可以通过安装这个应用程序，来激活ubuntu自带的摄像头驱动</p><ol><li><p>安装<br><code>sudo apt-get install cheese</code></p></li><li><p>虚拟机设置里面将USB兼容性改为3.0</p></li><li><p>测试</p><p><code>cheese</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：那天晚上opencv从九点半开始装到十点半，人都快要崩溃了，结果第二天又重新编译了一遍，感觉自己真的是一个人在黑暗中摸索 ~&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="ubuntu" scheme="http://yoursite.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu（二）—— sublime的python环境搭建</title>
    <link href="http://yoursite.com/2018/09/13/ubuntu%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-sublime%E7%9A%84python%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/09/13/ubuntu（二）——-sublime的python环境搭建/</id>
    <published>2018-09-13T07:52:35.000Z</published>
    <updated>2018-09-13T07:55:13.507Z</updated>
    
    <content type="html"><![CDATA[<p>PS：之前一直以为sublime只是文本编辑器，没想到功能如此强大，还有控制，各种东西配置好，就是个IDE了 ~</p><a id="more"></a><h2 id="一、ubuntu-下python版本切换"><a href="#一、ubuntu-下python版本切换" class="headerlink" title="一、ubuntu 下python版本切换"></a>一、ubuntu 下python版本切换</h2><p>ubuntu 本身是自带 python，这样就减少了在windows下的下载和环境变量配置，但是本身是自带两个版本的python，2.X和3.X,两个版本，两个版本默认的是使用2.X</p><ul><li>python    默认版本 2.7.12</li><li>python3  版本是 3.5.2</li></ul><p>ubuntu 下 python 的版本切换：<a href="https://blog.csdn.net/beijiu5854/article/details/77897767" target="_blank" rel="noopener">https://blog.csdn.net/beijiu5854/article/details/77897767</a></p><p><br></p><h2 id="二、Ubantu下-Sublime-Text3-python-环境的搭建"><a href="#二、Ubantu下-Sublime-Text3-python-环境的搭建" class="headerlink" title="二、Ubantu下 Sublime Text3  python 环境的搭建"></a>二、Ubantu下 Sublime Text3  python 环境的搭建</h2><p><a href="https://blog.csdn.net/mao19931004/article/details/51834616" target="_blank" rel="noopener">https://blog.csdn.net/mao19931004/article/details/51834616</a></p><p>一直想实现ubuntu下终端用subl命令打开文件，呵呵呵呵，一个下午差点把sublime玩崩 ~ </p><p>我大概知道应该是路径的问题，一直链接不上，但是不知道怎么改啊~</p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：之前一直以为sublime只是文本编辑器，没想到功能如此强大，还有控制，各种东西配置好，就是个IDE了 ~&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="ubuntu" scheme="http://yoursite.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu（一）—— VM虚拟机上安装ubuntu</title>
    <link href="http://yoursite.com/2018/09/13/ubuntu%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94-VM%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8A%E5%AE%89%E8%A3%85ubuntu/"/>
    <id>http://yoursite.com/2018/09/13/ubuntu（一）——-VM虚拟机上安装ubuntu/</id>
    <published>2018-09-13T07:48:57.000Z</published>
    <updated>2018-09-13T07:49:46.210Z</updated>
    
    <content type="html"><![CDATA[<p>Win10使用VMware虚拟机安装ubuntu</p><p>PS：又被汪大蕾骂了一顿，还是装个虚拟机吧，毕竟做开发还是要靠Linux</p><a id="more"></a><p><br></p><h2 id="一、压缩卷新建磁盘分区"><a href="#一、压缩卷新建磁盘分区" class="headerlink" title="一、压缩卷新建磁盘分区"></a>一、压缩卷新建磁盘分区</h2><p>具体操作：<a href="https://jingyan.baidu.com/article/4f7d5712c415091a21192761.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/4f7d5712c415091a21192761.html</a></p><p>压缩卷：从一个盘里边把没有用到的空间分到未使用的磁盘空间里</p><p>扩展卷：从未使用空间里向现有的盘增加空间</p><p>磁盘格式：不同格式会在磁盘分区容量、单个文件容量、安全方面等存在区别</p><p>格式化：对磁盘或磁盘中的分区（partition）进行初始化的一种操作，这种操作通常会导致现有的磁盘或分区中所有的文件被清除</p><p>windows下磁盘格式主要有FAT16、FAT32、NTFS 等，最新格式为exFAT</p><p><br></p><h2 id="二、虚拟机和双系统"><a href="#二、虚拟机和双系统" class="headerlink" title="二、虚拟机和双系统"></a>二、虚拟机和双系统</h2><p>一直在纠结是装双系统还是虚拟机，但是看帖子说，双系统会不稳定，新手还是建议虚拟机 ~ </p><p>不过运行虚拟机，相当于运行两个系统，比较占用资源，不过拖拽文件会比较方便，双系统就需要切换</p><p><br></p><h3 id="1-虚拟机-（Virtual-Machine）"><a href="#1-虚拟机-（Virtual-Machine）" class="headerlink" title="1.  虚拟机 （Virtual Machine）"></a>1.  虚拟机 （Virtual Machine）</h3><p>通过软件模拟出来的具有完整的硬件系统功能的，运行在宿主机上的一个隔离环境中的计算机系统</p><p><strong>宿主机</strong> 是指直接运行在我们物理硬件的操作系统，而 <strong>虚拟机</strong> 则是运行在宿主机之上，所以当我们运行一个虚拟机的时候，实际上我们是在同时运行两个系统，这对我们的物理硬件要求比较高（主要是内存）</p><h3 id="2-双系统"><a href="#2-双系统" class="headerlink" title="2. 双系统"></a>2. 双系统</h3><p>双系统并不是同时运行两个系统，而是指两个系统都在存储空间中，我们可以选择其中一个进行启动</p><p><br></p><h2 id="三、Win10使用VMware虚拟机安装ubuntu"><a href="#三、Win10使用VMware虚拟机安装ubuntu" class="headerlink" title="三、Win10使用VMware虚拟机安装ubuntu"></a>三、Win10使用VMware虚拟机安装ubuntu</h2><p>具体操作：<a href="https://blog.csdn.net/dcrmg/article/details/74075254" target="_blank" rel="noopener">https://blog.csdn.net/dcrmg/article/details/74075254</a></p><p>​                   <a href="https://www.jianshu.com/p/3379892948da" target="_blank" rel="noopener">https://www.jianshu.com/p/3379892948da</a></p><p><br></p><p>ubuntu-16.04.5-desktop-amd64.iso ： <a href="http://mirrors.zju.edu.cn/ubuntu-releases/16.04/" target="_blank" rel="noopener">http://mirrors.zju.edu.cn/ubuntu-releases/16.04/</a></p><p>VMware Workstation 12.5.7 Pro for Windows</p><p><br></p><p><strong>注意：装虚拟机其中有一步是关于处理器配置</strong></p><p>VMWare中的CPU数量与核心数量意义</p><p>处理器数量 ：是指CPU核数（例如：单核/双核），并不是指CPU颗数</p><p>每个处理的核心数量：是指CPU中的线程，并不是指核心（Core）</p><p><br></p><p>windows 查看CPU数、核心数、线程数</p><p><a href="https://blog.csdn.net/ksws0292756/article/details/79119961" target="_blank" rel="noopener">https://blog.csdn.net/ksws0292756/article/details/79119961</a></p><p><br></p><h2 id="四、VMware安装VMware-Tools"><a href="#四、VMware安装VMware-Tools" class="headerlink" title="四、VMware安装VMware Tools"></a>四、VMware安装VMware Tools</h2><p>提示是在客户机安装虚拟CD驱动器 ，下面是解决办法</p><p><a href="https://blog.csdn.net/AHAU10/article/details/52611765" target="_blank" rel="noopener">https://blog.csdn.net/AHAU10/article/details/52611765</a></p><p>更改路径后，一路yes下去，最后出现enjoy安装算是成功了</p><p><a href="https://blog.csdn.net/u013142781/article/details/50539574" target="_blank" rel="noopener">https://blog.csdn.net/u013142781/article/details/50539574</a></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Win10使用VMware虚拟机安装ubuntu&lt;/p&gt;
&lt;p&gt;PS：又被汪大蕾骂了一顿，还是装个虚拟机吧，毕竟做开发还是要靠Linux&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="ubuntu" scheme="http://yoursite.com/tags/ubuntu/"/>
    
  </entry>
  
</feed>
