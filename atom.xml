<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>绿小蕤</title>
  <icon>https://www.gravatar.com/avatar/e4d7a8bd1cb84fb3b4123916b4ea2f6b</icon>
  <subtitle>好逸恶劳,贪生怕死</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-28T13:22:48.107Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>绿小蕤</name>
    <email>528036346@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Debug、Release版本下 多线程问题</title>
    <link href="http://yoursite.com/2018/11/28/Debug%E3%80%81Release%E7%89%88%E6%9C%AC%E4%B8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/11/28/Debug、Release版本下-多线程问题/</id>
    <published>2018-11-28T09:16:44.000Z</published>
    <updated>2018-11-28T13:22:48.107Z</updated>
    
    <content type="html"><![CDATA[<p>PS：今天做项目的时候，开多线程测试，遇到了一个奇怪的问题，到现在都没有办法解释～<br><a id="more"></a>      </p><p>多线程在Debug版本下的cout部分会正常输出   </p><p>多线程在Release版本下的cout部分似乎受到了阻塞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//开了四个线程</span><br><span class="line">while(times&lt;4) &#123;&#125;;  //保证4个线程运行完进行cout</span><br><span class="line">//其它代码</span><br><span class="line">//cout部分</span><br></pre></td></tr></table></figure><p>Release版本的代码改为以下形式，while里加cout，所有cout部分就都能正常输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//开了四个线程</span><br><span class="line">while(tims&lt;4) &#123;cout&lt;&lt;&quot;&quot;;&#125;       //保证4个线程运行完进行cout</span><br><span class="line">//其它代码</span><br><span class="line">//cout部分</span><br></pre></td></tr></table></figure><p><br><br>很服气，到底cout、while、Release是什么关系</p><hr><p>更新问题：</p><p>哇，真的超级崇拜我家Uncle D，晚上他试了几次，就找到问题所在，其实是Release优化库的问题 </p><p>（1）首先，这个和cout无关，之前觉得是cout多线程缓存区刷新的问题，后来发现不论将后面的代码改为printf还是文件输出都没有反应</p><p>（2）其次，这个问题和Release优化相关，将VS项目属性里C/C++下的优化改为禁用，while后面部分就能正常执行</p><p>（3）接着，解释为什么while后面的代码不执行，因为编译器觉得当前线程中times只加1次，所以times不能加到4，while是个死循环，所以while后的代码不执行</p><p>（4）最后，解释为什么在while的循环体内使用cin、cout、printf这些输入输出流，就能跨过while，因为编译器没有那么智能，编译器会觉得输入输出流会对times产生影响，所以编译器并不认为hile是个死循环        </p><p>最后的最后，他说是我程序写的有问题，因为我将times定义为全局，在每个线程结束处进行times++，编译器会觉得times加不到4，如果将times++放到主函数中等到线程退出才执行，就不会出现这个问题了         </p><p>怎么办，现在越来越崇拜Uncle D了，无法自拔的痴迷~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：今天做项目的时候，开多线程测试，遇到了一个奇怪的问题，到现在都没有办法解释～&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dlib中imglab生成失败的解决方法</title>
    <link href="http://yoursite.com/2018/11/19/Dlib%E4%B8%ADimglab%E7%94%9F%E6%88%90%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/11/19/Dlib中imglab生成失败的解决方法/</id>
    <published>2018-11-19T01:12:46.000Z</published>
    <updated>2018-11-19T01:38:11.543Z</updated>
    
    <content type="html"><![CDATA[<p>PS：花了一个晚上才把imglab这个标注工具生成失败的问题解决，哎，我真的太木了<br><a id="more"></a></p><h2 id="1-问题所在"><a href="#1-问题所在" class="headerlink" title="1.问题所在"></a>1.问题所在</h2><p><code>dlib\image_saver</code> 下的头文件 <code>save_png.h</code> 出现 Assertion Failed<br>可以看到作者在 <code>#ifndef DLIB_PNG_SUPPORT</code> 下其实打了超多感叹号的注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You are getting this error because you are trying to use save_png() but you haven&apos;t defined DLIB_PNG_SUPPORT.  You must do so to use this function. You must also make sure you set your build environment to link against the libpng library.</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h2><p>解决方法很简单，我开始还在研究是不是要配置第三方库libpng和zlib的环境<br>其实只要在imglab主函数里声明<br> <code>#define DLIB_PNG_SUPPORT</code> 和 <code>#define DLIB_JPEG_SUPPORT</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：花了一个晚上才把imglab这个标注工具生成失败的问题解决，哎，我真的太木了&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C++学习：多线程</title>
    <link href="http://yoursite.com/2018/11/08/C-%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/11/08/C-学习：多线程/</id>
    <published>2018-11-08T13:09:22.000Z</published>
    <updated>2018-11-08T13:09:41.141Z</updated>
    
    <content type="html"><![CDATA[<p>PS：真的好难啊，看不懂，有没有什么多线程的资料可以系统读一下，完全云里雾里啊~<br><a id="more"></a></p><h2 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h2><p>POSIX 可移植操作系统接口（Portable Operating System Interface of UNIX ）是为了各操作系统间保持兼容性而制定的系列标准，POSIX并不局限于UNIX</p><p>个人理解：应用程序接口 API（Application Programming Interface）是操作系统提供给应用程序调用的代码，POSIX标准就是规范了不同操作系统的API。<strong>这样，为一个POSIX兼容的操作系统编写的应用程序，应该可以在任何其它的POSIX操作系统上编译执行</strong>。<br><br></p><h2 id="POSIX线程"><a href="#POSIX线程" class="headerlink" title="POSIX线程"></a>POSIX线程</h2><p>POSIX线程（POSIX Threads，Pthreads）是POSIX的线程标准，定义了创建和操纵线程的一套API<br>创建线程之后，由CPU决定何时执行线程调用的函数<br><br>   </p><h2 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h2><p><a href="https://www.cnblogs.com/xh0102/p/5710074.html" target="_blank" rel="noopener">https://www.cnblogs.com/xh0102/p/5710074.html</a><br>1.进程<br>每个进程有自己的地址空间。<strong>两个进程中的地址即使值相同，实际指向的位置也不同。</strong>进程间通信一般 <strong>通过操作系统</strong>的公共区进行。<br>2.线程<br>同一进程中的线程属于同一地址空间，<strong>共享全局变量和内存</strong>，所以一个线程的数据可以直接提供给其他线程使用，而 <strong>不必通过操作系统</strong>，也就是内核的调度。<br><br></p><h2 id="并行、并发"><a href="#并行、并发" class="headerlink" title="并行、并发"></a>并行、并发</h2><p>1.并行<br>是指两个或多个独立的操作同时进行。对于多核，多个线程可以在多核上真正独立的并行执行。<br>2.并发<br>是指在一段时间内执行多个操作。对于单核，多个线程是并发的，在一个时间段内轮流执行。<br>例如，4核4线程可以并行4个线程，4核8线程则使用了超线程技术，把一个物理核模拟为2个逻辑核心，可以并行8个线程。<br><br></p><h2 id="可结合和分离的线程"><a href="#可结合和分离的线程" class="headerlink" title="可结合和分离的线程"></a>可结合和分离的线程</h2><p>线程可结合或可分离是属于内核的属性，决定一个线程以什么样的方式来终止自己<br>1.joinable 可结合，非分离状态<br><strong>需要被其他线程收回其资源和杀死</strong>，在被其他线程回收之前，它的存储器资源是不释放的<br>原有的线程等待创建的线程结束，只有当pthread_join（）函数返回时，创建的线程才算终止，才能释放创建的线程占用的系统资源       </p><ol start="2"><li>detached 分离线程<br>一个分离的线程没有被其他的线程所等待，<strong>不能被其他线程回收或杀死</strong>，等到运行结束，线程也就终止，才释放系统资源<br><br></li></ol><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>线程通信基本问题是同步和互斥<br>1.线程同步<br>一个线程的执行依赖于另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒<br>线程同步的四种方法：<a href="https://blog.csdn.net/zm_jacker/article/details/9787829" target="_blank" rel="noopener">https://blog.csdn.net/zm_jacker/article/details/9787829</a><br>2.线程互斥<br>当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源<br>同步其实已经实现了互斥，而互斥是一种特殊的同步<br><br></p><h2 id="临界资源、临界区"><a href="#临界资源、临界区" class="headerlink" title="临界资源、临界区"></a>临界资源、临界区</h2><p>临界资源：能够被多个线程共享的数据<br>临界区：对临界资源进行操作的那一段代码<br><br></p><h2 id="互斥锁-互斥锁（mutual-exclusive-lock-variable-mutex-）"><a href="#互斥锁-互斥锁（mutual-exclusive-lock-variable-mutex-）" class="headerlink" title="互斥锁/互斥锁（mutual exclusive lock variable / mutex ）"></a>互斥锁/互斥锁（mutual exclusive lock variable / mutex ）</h2><p>在访问共享资源前对互斥量加锁，在访问完成后释放互斥量上的锁。对互斥量加锁以后，任何其他试图对互斥量加锁的线程将会阻塞，直到当前线程释放该互斥锁。<br>如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥锁加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。<br>个人理解：互斥量和互斥锁是一个意思<br><br></p><h2 id="条件变量和互斥锁"><a href="#条件变量和互斥锁" class="headerlink" title="条件变量和互斥锁"></a>条件变量和互斥锁</h2><p>条件变量是和互斥锁搭配使用<br>线程A需要等某个条件成立才能继续往下执行，现在这个条件不成立，线程A就阻塞等待，而线程B在执行过程中使这个条件成立了，就唤醒线程A继续执行<br><br></p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量强调的是多线程的同步，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作<br><br></p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p><strong>原子操作是CPU执行指令的最小单元</strong>，这种操作一旦开始，就一直运行到结束，不会被中断<br>能够在单条指令中完成的操作都可以认为是原子操作</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：真的好难啊，看不懂，有没有什么多线程的资料可以系统读一下，完全云里雾里啊~&lt;br&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>cs144:1-1</title>
    <link href="http://yoursite.com/2018/10/29/cs144-1-1/"/>
    <id>http://yoursite.com/2018/10/29/cs144-1-1/</id>
    <published>2018-10-29T09:20:55.000Z</published>
    <updated>2018-10-29T09:22:39.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p><img src="http://phcnyb3sl.bkt.clouddn.com/summary.png" alt=""></p><ul><li>模型：Bidirectional byte stream</li><li>模型的三种应用：<ul><li>World Wide Web(HTTP)</li><li>Skype</li><li>BitTorrent</li></ul></li></ul><a id="more"></a><p><br></p><h2 id="1-Bidirectional-byte-stream"><a href="#1-Bidirectional-byte-stream" class="headerlink" title="1. Bidirectional byte stream"></a>1. Bidirectional byte stream</h2><p>The most common communication model of networked applications.</p><p>This allows two programs running on different computers exchange data.</p><p>将网络抽象A和B之间双向的读/写</p><p><img src="http://phcnyb3sl.bkt.clouddn.com/bytestreammodel.png" alt=""></p><p><br></p><h2 id="2-1-World-Wide-Web"><a href="#2-1-World-Wide-Web" class="headerlink" title="2-1 World Wide Web"></a>2-1 World Wide Web</h2><p><img src="http://phcnyb3sl.bkt.clouddn.com/http.png" alt=""></p><p><strong>client-server model    客户端-服务端</strong> </p><p>Client open connection to a server and requests <strong>documents</strong>.</p><p>Server responses documents.</p><p><br></p><h2 id="2-2-BitTorrent"><a href="#2-2-BitTorrent" class="headerlink" title="2-2 BitTorrent"></a>2-2 BitTorrent</h2><p><img src="http://phcnyb3sl.bkt.clouddn.com/bittorrent.png" alt=""></p><p><strong>peer-to-peer model</strong></p><p>Swarms of clients open connections to each other to exchange pieces of data.</p><p>A single client can request from many other clients in parallel.</p><p>每个客户端拥有文件的 <strong>piece</strong> 即一部分，这些客户端形成了<strong>swarms</strong> 即集群，客户端可以选择加入或退出这个 swarm</p><p>客户端要load file时，向Tracker请求拥有piece的client lists客户列表，从各客户端load piece，且是个并发的过程</p><p><br></p><h2 id="2-3-Skype"><a href="#2-3-Skype" class="headerlink" title="2-3 Skype"></a>2-3 Skype</h2><p>Clients can`t open connections directly, so go through Rendezvous or Relay server.</p><p>NAT:Network Address Translator</p><p>个人理解：NAT是个单向的过程，所以需要 reverse connection</p><p>正常情况下，A try to open connection to B，但是由于B在NAT后面，B无法通过NAT回发信息给A，实际上是B open connection to A</p><p>通常，public server 不会在NAT后面，但是 personal machine 为了安全，所以需要NAT</p><p> <img src="http://phcnyb3sl.bkt.clouddn.com/skpye1.png" alt=""></p><p><img src="http://phcnyb3sl.bkt.clouddn.com/skype2.png" alt=""></p><p><br></p><h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><p>互联网包含因特网，因特网包含万维网</p><p><br></p><h3 id="1-互联网"><a href="#1-互联网" class="headerlink" title="1. 互联网"></a>1. 互联网</h3><p>凡是能彼此通信的设备组成的网络就叫互联网</p><p><br></p><h3 id="2-Internet-因特网"><a href="#2-Internet-因特网" class="headerlink" title="2. Internet 因特网"></a>2. Internet 因特网</h3><p><strong>基于TCP/IP协议</strong>让不同的设备可以彼此通信。但使用TCP/IP协议的网络并不一定是因特网，一个局域网也可以使用TCP/IP协议。</p><p>TCP/IP协议由很多协议组成，不同类型的协议又被放在不同的层，其中，位于应用层的协议就有很多，比如FTP、SMTP、HTTP。只要<strong>应用层使用的是HTTP协议，就称为万维网</strong>。</p><p>Internet 提供的主要服务有万维网（WWW）、文件传输（FTP）、电子邮件（E-mail）、远程登录（Telnet）、手机 (3GHZ) 等。</p><p><br></p><h3 id="3-www万维网"><a href="#3-www万维网" class="headerlink" title="3. www万维网"></a>3. www万维网</h3><p>浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码HTML提取出来，并翻译成网页。</p><p>URL （Uniform Resource Locator，统一资源定位符）：<a href="http://www.microsoft.com/china/index.htm" target="_blank" rel="noopener">http://www.microsoft.com/china/index.htm</a></p><ol><li>http://：超文本传输协议，通常不用输入</li><li>www：一个万维网服务器</li><li>Microsoft.com/：站点服务器的名称</li><li>China/：该服务器上的子目录</li><li>Index.htm：该子目录下的一个HTML文件，HTML语言描述的文件，需要通过www浏览器显示效果</li></ol><p><br></p><p>PS：万维网与因特网的差别，因特网指的是一个硬件的网络，全球的所有电脑通过网络连接后便形成了因特网，而万维网更倾向于一种浏览网页的功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Summary&quot;&gt;&lt;a href=&quot;#Summary&quot; class=&quot;headerlink&quot; title=&quot;Summary&quot;&gt;&lt;/a&gt;Summary&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://phcnyb3sl.bkt.clouddn.com/summary.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模型：Bidirectional byte stream&lt;/li&gt;
&lt;li&gt;模型的三种应用：&lt;ul&gt;
&lt;li&gt;World Wide Web(HTTP)&lt;/li&gt;
&lt;li&gt;Skype&lt;/li&gt;
&lt;li&gt;BitTorrent&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="cs144" scheme="http://yoursite.com/tags/cs144/"/>
    
  </entry>
  
  <entry>
    <title>[置顶]目录检索</title>
    <link href="http://yoursite.com/2018/10/25/%E7%BD%AE%E9%A1%B6-%E7%9B%AE%E5%BD%95%E6%A3%80%E7%B4%A2/"/>
    <id>http://yoursite.com/2018/10/25/置顶-目录检索/</id>
    <published>2018-10-25T01:17:52.000Z</published>
    <updated>2018-10-25T05:32:18.458Z</updated>
    
    <content type="html"><![CDATA[<p>[置顶]检索目录列表</p><a id="more"></a><p><br></p><h2 id="opencv"><a href="#opencv" class="headerlink" title="opencv"></a>opencv</h2><p><a href="https://sophia0130.github.io/2018/05/07/ImageWatch/" target="_blank" rel="noopener">ImageWatch — VS编译小工具</a></p><p>opencv（一）~（六）学习笔记系列 （PS：其实写了很多功能的代码，但是最近实在没有时间整理）</p><p><br></p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>贝叶斯分类器和概率图模型</p><p><a href="https://sophia0130.github.io/2018/05/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%A4%A7%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">机器学习算法大总结</a></p><p><br></p><h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><p><a href="https://sophia0130.github.io/2018/06/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">深度学习与强化学习</a></p><p>Deep-Learning—吴恩达—作业（一）~（七）系列</p><p><br></p><h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><p>1.cs231n笔记（一）~（十一）系列</p><ul><li>线性回归、逻辑回归、多分类</li><li>最优化（Optimization）：最小化损失函数</li><li>反向传播：链式法则求梯度</li><li>深度学习框架：PyTorch（Facebook）、Tensorflow（Google）</li><li>分类、检测、分割、跟踪</li><li>反卷积与特征可视化</li></ul><p>不同种类的网络：</p><ul><li>神经网络</li><li>卷积神经网络</li><li>经典CNN网络</li><li>循环神经网络</li><li>生成式对抗网络</li></ul><p>2.<a href="https://sophia0130.github.io/2018/08/01/NLP%E2%80%94%E2%80%94word2vec/" target="_blank" rel="noopener">NLP——word2vec</a> （PS：了解了一下自然语言处理，果然比图像要难啊 ~）</p><p><br></p><h2 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h2><p><a href="https://sophia0130.github.io/2018/08/05/TensorFlow-%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">TensorFlow 使用总结</a></p><p><a href="https://sophia0130.github.io/2018/08/05/Tensorboard-%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">Tensorboard 使用总结</a></p><p>TensorFlow代码实现（一）~（四）系列</p><p><br></p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>ubuntu（一）~？    </p><p>Linux（一）~？</p><p>CMake（一）~？</p><p><br></p><h2 id="python安装"><a href="#python安装" class="headerlink" title="python安装"></a>python安装</h2><p><a href="https://sophia0130.github.io/2018/06/13/anaconda%EF%BC%8Cconda%EF%BC%8Cpip%E7%9A%84%E5%85%B3%E7%B3%BB/" target="_blank" rel="noopener">anaconda，conda，pip的关系</a></p><p><a href="https://sophia0130.github.io/2018/07/29/Ipython-%E4%B8%8E-Jupyter-Notebook/" target="_blank" rel="noopener">Ipython 与 Jupyter Notebook</a></p><p><a href="https://sophia0130.github.io/2018/06/28/%E8%A7%A3%E5%86%B3pip%E5%AE%89%E8%A3%85%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">解决pip安装慢的问题</a></p><p><br></p><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p><a href="https://sophia0130.github.io/2018/07/14/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/" target="_blank" rel="noopener">《程序是怎样跑起来的》读书笔记</a></p><p><a href="https://sophia0130.github.io/2018/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%90%84%E7%A7%8D%E6%9D%BF%E5%AD%90/" target="_blank" rel="noopener">嵌入式与板子：MCU、ARM、DSP、FPGA、SOC</a></p><p><a href="https://sophia0130.github.io/2018/07/15/%E6%98%BE%E5%8D%A1/" target="_blank" rel="noopener">显卡</a></p><p><a href="https://sophia0130.github.io/2018/07/26/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">进程和线程</a></p><p><br></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><a href="https://sophia0130.github.io/2018/08/22/%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%81%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%81IDE/" target="_blank" rel="noopener">编译器、IDE、编辑器种类整理</a></p><p><a href="https://sophia0130.github.io/2018/05/04/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/" target="_blank" rel="noopener">编译器和解释器</a></p><p>CMake（一）~？</p><p><br></p><h2 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h2><p>剑指offer（一）~？持续更</p><p><br></p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p><a href="https://sophia0130.github.io/2018/05/14/XML%E3%80%81YAML%E3%80%81JSON/" target="_blank" rel="noopener">序列化数据格式 ：xml、yaml、json</a></p><p><a href="https://sophia0130.github.io/2018/05/18/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%BA%91-%E7%89%B9%E5%88%AB%E7%AE%80%E9%99%8B%E7%9A%84%E8%AE%A4%E8%AF%86/" target="_blank" rel="noopener">虚拟机和云</a></p><p><a href="https://sophia0130.github.io/2018/05/04/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%90%86%E8%A7%A3/" target="_blank" rel="noopener">网络基础知识</a></p><p><br></p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p><a href="https://sophia0130.github.io/2018/06/01/Git-%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">Git学习笔记</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[置顶]检索目录列表&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[置顶]分享</title>
    <link href="http://yoursite.com/2018/10/25/%E7%BD%AE%E9%A1%B6-%E5%88%86%E4%BA%AB/"/>
    <id>http://yoursite.com/2018/10/25/置顶-分享/</id>
    <published>2018-10-25T01:14:56.000Z</published>
    <updated>2018-10-25T05:31:21.936Z</updated>
    
    <content type="html"><![CDATA[<p>[置顶] 书单分享和大神的博客分享</p><a id="more"></a><p><br></p><h2 id="一、书单"><a href="#一、书单" class="headerlink" title="一、书单"></a>一、书单</h2><h3 id="数据结构与算法："><a href="#数据结构与算法：" class="headerlink" title="数据结构与算法："></a>数据结构与算法：</h3><ul><li>《数据结构与算法C语言版本》</li><li>《大话数据结构》</li></ul><p><br></p><h3 id="C-："><a href="#C-：" class="headerlink" title="C++："></a>C++：</h3><ul><li>《C++primer》</li><li>《effective C++》</li><li>《深度探索C++对象模型》</li></ul><p><br></p><h3 id="计算机："><a href="#计算机：" class="headerlink" title="计算机："></a>计算机：</h3><ul><li><p>《计算机程序的构造和解释（SICP）》</p></li><li><p>《程序员的自我修养——链接、装载与库》</p></li><li>《程序是怎样跑起来的》</li></ul><p><br></p><h2 id="机器学习："><a href="#机器学习：" class="headerlink" title="机器学习："></a>机器学习：</h2><p>《机器学习》</p><p>《深度学习500问》GitHub 上：<a href="https://github.com/scutan90" target="_blank" rel="noopener">https://github.com/scutan90</a></p><p><br></p><h2 id="二、大神-Blog"><a href="#二、大神-Blog" class="headerlink" title="二、大神 Blog"></a>二、大神 Blog</h2><p>邹欣：<a href="https://www.cnblogs.com/xinz/" target="_blank" rel="noopener">https://www.cnblogs.com/xinz/</a> （师兄推荐给我的，对于怎么做工程蛮有帮助的）</p><p>莫烦：<a href="https://morvanzhou.github.io/" target="_blank" rel="noopener">https://morvanzhou.github.io/</a> （深度学习实战使用各种框架的入门教程）</p><p>鸟哥：<a href="http://cn.linux.vbird.org/linux_basic/linux_basic.php" target="_blank" rel="noopener">http://cn.linux.vbird.org/linux_basic/linux_basic.php</a> （为什么要叫这么个名字，Linux 学习）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[置顶] 书单分享和大神的博客分享&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>win10+VS2013+Dlib 安装配置</title>
    <link href="http://yoursite.com/2018/10/22/win10-VS2013-Dlib-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/10/22/win10-VS2013-Dlib-安装配置/</id>
    <published>2018-10-22T13:55:40.000Z</published>
    <updated>2018-10-25T03:53:50.235Z</updated>
    
    <content type="html"><![CDATA[<p>PS：我下载的是19.0版本（19.2及以上版本需用vs2015或更高版本）</p><p>这是之前的Dlib版本：<a href="http://dlib.net/files/" target="_blank" rel="noopener">http://dlib.net/files/</a></p><a id="more"></a><p><br></p><h1 id="一、Cmake-生成-dlib-lib文件"><a href="#一、Cmake-生成-dlib-lib文件" class="headerlink" title="一、Cmake 生成 dlib.lib文件"></a>一、Cmake 生成 dlib.lib文件</h1><h3 id="1-cmake-转-VS-工程"><a href="#1-cmake-转-VS-工程" class="headerlink" title="1. cmake 转 VS 工程"></a>1. cmake 转 VS 工程</h3><p>（1）点击configure，选择 Visual Studio 12 2013 Win64、Visual Studio 12 2013 </p><p><strong>注意：这里的平台和以后用的平台要一致</strong></p><p>PS：之前用的是 Visual Studio 12 2013 Win64  后编译生成 dlib.lib 添加到 Win32 平台就一直报错</p><p>（2）选择Genarate</p><p><br></p><h3 id="2-VS2013编译生成-dlib-lib"><a href="#2-VS2013编译生成-dlib-lib" class="headerlink" title="2. VS2013编译生成 dlib.lib"></a>2. VS2013编译生成 dlib.lib</h3><p>（1）build 文件夹下生成 .sln 解决方案，打开解决方案</p><p>（2）切换 vs2013 的平台至 debug 或 release模式</p><p>（3）找到AllBuild工程右击生成，Debug 文件下会生成dlib.lib</p><p>注意：生成之前，检查dlib项目中的属性配置，参考这篇博文：</p><p><a href="https://blog.csdn.net/Dawnfox/article/details/77282246?utm_source=blogxgwz1" target="_blank" rel="noopener">https://blog.csdn.net/Dawnfox/article/details/77282246?utm_source=blogxgwz1</a></p><p><strong>注意：这里有一个坑，到后面才发现，自己建工程，添加lib后，一直报“Runtime Library”的不匹配项，就是因为，生成dlib.lib时候，dlib 项目中的属性配置中的代码生成运行库需要改，我改成了MTd</strong></p><p>大型项目中必须要求所有组件和第三方库的运行时库是统一的，否则将会出现LNK2005井喷</p><p><br></p><p>注意点：（！！真的要注意，很重要！！）</p><ul><li><strong>cmake 的平台 x64 还是 win32</strong></li><li><strong>编译时的模式 Debug 还是 Release</strong></li><li><strong>链接的 Runtime Library</strong> </li></ul><p>我今天突然对上面有了不一样的领悟</p><p><br></p><h2 id="二、属性配置"><a href="#二、属性配置" class="headerlink" title="二、属性配置"></a>二、属性配置</h2><p>属性配置，验证dlib.lib可用性，完全按照下面这篇博文：</p><p><a href="https://blog.csdn.net/Dawnfox/article/details/77282246?utm_source=blogxgwz1" target="_blank" rel="noopener">https://blog.csdn.net/Dawnfox/article/details/77282246?utm_source=blogxgwz1</a></p><p><br></p><h2 id="三、使用dlib的imglab工具标注数据集"><a href="#三、使用dlib的imglab工具标注数据集" class="headerlink" title="三、使用dlib的imglab工具标注数据集"></a>三、使用dlib的imglab工具标注数据集</h2><p>不知道为什么win10下这个工具编译不成功，只好到虚拟机ubuntu上编译</p><p><a href="https://blog.csdn.net/qq_15715657/article/details/81504253" target="_blank" rel="noopener">https://blog.csdn.net/qq_15715657/article/details/81504253</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：我下载的是19.0版本（19.2及以上版本需用vs2015或更高版本）&lt;/p&gt;
&lt;p&gt;这是之前的Dlib版本：&lt;a href=&quot;http://dlib.net/files/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://dlib.net/files/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="安装" scheme="http://yoursite.com/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="配置" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>C++学习：强制类型转换</title>
    <link href="http://yoursite.com/2018/10/21/C-%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2018/10/21/C-学习：强制类型转换/</id>
    <published>2018-10-21T06:12:41.000Z</published>
    <updated>2018-10-21T06:20:13.180Z</updated>
    
    <content type="html"><![CDATA[<p>z最近晕乎乎的，这部分的内容看得很不明白，只能理解非常浅显，我要加油了 ！</p><p>参考这篇博客：<a href="https://blog.csdn.net/ydar95/article/details/69822540" target="_blank" rel="noopener">https://blog.csdn.net/ydar95/article/details/69822540</a></p><ul><li>去const属性用const_cast</li><li>基本类型转换用static_cast</li><li>多态类之间的类型转换用daynamic_cast</li><li>不同类型的指针类型转换用reinterpreter_cast</li></ul><a id="more"></a><p><br></p><h2 id="C风格"><a href="#C风格" class="headerlink" title="C风格"></a>C风格</h2><p><code>TypeName b = (TypeName)a;</code></p><p><br></p><h2 id="C-风格"><a href="#C-风格" class="headerlink" title="C++风格"></a>C++风格</h2><h3 id="1-const-cast"><a href="#1-const-cast" class="headerlink" title="1. const_cast"></a>1. const_cast</h3><p><strong>去掉类型的 const、volatile 属性</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeWord</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tmp = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(buf);</span><br><span class="line">    tmp[<span class="number">0</span>] = <span class="string">'9'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">"123456789"</span>;</span><br><span class="line">    changeWord(buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-static-cast"><a href="#2-static-cast" class="headerlink" title="2. static_cast"></a>2. static_cast</h3><p>类似于C风格的强制转换</p><ol><li><p>派生类和子类之间转换</p><ul><li><strong>派生类的指针或引用转换成基类是安全的</strong></li></ul></li></ol><ul><li><strong>基类指针或引用转换成派生类是不安全的</strong></li></ul><ol start="2"><li><p>基本数据类型之间的转换，enum, struct, int, char, float 之间的转换</p></li><li><p><strong>static_cast不能去掉类型的const、volitale属性 (用const_cast)</strong></p></li><li><p>c++ 的任何的隐式转换都是使用 static_cast 来实现</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 常规用法 */</span></span><br><span class="line"><span class="keyword">float</span> f_pi=<span class="number">3.141592f</span></span><br><span class="line"><span class="keyword">int</span>   i_pi=<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(f_pi); <span class="comment">// i_pi 的值为 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* class 的上下行转换 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  上行 Sub -&gt; Base</span></span><br><span class="line"><span class="comment">//编译通过，安全</span></span><br><span class="line">Sub sub;</span><br><span class="line">Base *base_ptr = <span class="keyword">static_cast</span>&lt;Base*&gt;(&amp;sub);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//  下行 Base -&gt; Sub</span></span><br><span class="line"><span class="comment">//编译通过，不安全</span></span><br><span class="line">Base base;</span><br><span class="line">Sub *sub_ptr = <span class="keyword">static_cast</span>&lt;Sub*&gt;(&amp;base);</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-dynamic-cast"><a href="#3-dynamic-cast" class="headerlink" title="3. dynamic_cast"></a>3. dynamic_cast</h3><p>一般是用在基类和派生类的转换上，也与编译器的属性设置有关</p><p>在进行下行转换时，dynamic_cast具有类型检查的功能，比 static_cast更安全</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base() &#123;&#125;</span><br><span class="line">    ~Base() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm Base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">i_am_virtual_foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sub() &#123;&#125;</span><br><span class="line">    ~Sub() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm Sub"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">i_am_virtual_foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sub-&gt;Base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Sub * sub = <span class="keyword">new</span> Sub();</span><br><span class="line">    sub-&gt;print();</span><br><span class="line">    Base* sub2base = <span class="keyword">dynamic_cast</span>&lt;Base*&gt;(sub);</span><br><span class="line">    <span class="keyword">if</span> (sub2base != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        sub2base-&gt;print();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;sub-&gt;base&gt; sub2base val is: "</span> &lt;&lt; sub2base &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Base-&gt;Sub"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Base *base = <span class="keyword">new</span> Base();</span><br><span class="line">    base-&gt;print();</span><br><span class="line">    Sub  *base2sub = <span class="keyword">dynamic_cast</span>&lt;Sub*&gt;(base);</span><br><span class="line">    <span class="keyword">if</span> (base2sub != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        base2sub-&gt;print();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"&lt;base-&gt;sub&gt; base2sub val is: "</span>&lt;&lt; base2sub &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> sub;</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* vs2017 输出为</span></span><br><span class="line"><span class="comment">Sub-&gt;Base</span></span><br><span class="line"><span class="comment">I'm Sub</span></span><br><span class="line"><span class="comment">I'm Base</span></span><br><span class="line"><span class="comment">&lt;sub-&gt;base&gt; sub2base val is: 00B9E080   // 注:这个地址是系统分配的,每次不一定一样</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Base-&gt;Sub</span></span><br><span class="line"><span class="comment">I'm Base</span></span><br><span class="line"><span class="comment">&lt;base-&gt;sub&gt; base2sub val is: 00000000   // 对此类错误的转换赋值为nullptr</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><br></p><p>运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表</p><p>当一个类中拥有至少一个虚函数，那么编译器就会构建出一个虚函数表，来指示这些函数的地址，假如继承该类的子类定义并实现了一个同名并具有同样函数签名的方法重写了基类中的方法，那么虚函数表会将该函数指向新的地址。此时多态性就体现出来了</p><p><br></p><h3 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4. reinterpret_cast"></a>4. reinterpret_cast</h3><p>无关类型转换，将指针转换为其它指针类型、将数字转换为指针或将指针转换为数字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重解析类型转换，前置进行类型转换 </span></span><br><span class="line">    <span class="keyword">char</span> *p1  = <span class="string">"hello world"</span>;                       </span><br><span class="line">    <span class="keyword">int</span>  *p2  = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> *&gt;(p1);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p2&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 输出一串我也看不懂的数字</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;z最近晕乎乎的，这部分的内容看得很不明白，只能理解非常浅显，我要加油了 ！&lt;/p&gt;
&lt;p&gt;参考这篇博客：&lt;a href=&quot;https://blog.csdn.net/ydar95/article/details/69822540&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/ydar95/article/details/69822540&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;去const属性用const_cast&lt;/li&gt;
&lt;li&gt;基本类型转换用static_cast&lt;/li&gt;
&lt;li&gt;多态类之间的类型转换用daynamic_cast&lt;/li&gt;
&lt;li&gt;不同类型的指针类型转换用reinterpreter_cast&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习：const、static、extern</title>
    <link href="http://yoursite.com/2018/10/20/C-%E5%AD%A6%E4%B9%A0%EF%BC%9Aconst%E3%80%81static%E3%80%81extern/"/>
    <id>http://yoursite.com/2018/10/20/C-学习：const、static、extern/</id>
    <published>2018-10-20T09:57:25.000Z</published>
    <updated>2018-10-20T10:18:18.258Z</updated>
    
    <content type="html"><![CDATA[<p>最粗略的理解</p><p>const：存储的内容不变</p><p>static：存储的位置不变</p><p>参考了好多篇其它博客，但是找不到了……</p><a id="more"></a><p><br></p><h2 id="（一）const"><a href="#（一）const" class="headerlink" title="（一）const"></a>（一）const</h2><p><strong>常量限定符</strong></p><h3 id="一、const-修饰基本数据类型"><a href="#一、const-修饰基本数据类型" class="headerlink" title="一、const 修饰基本数据类型"></a>一、const 修饰基本数据类型</h3><h4 id="1-修饰一般常量及数组"><a href="#1-修饰一般常量及数组" class="headerlink" title="1.修饰一般常量及数组"></a>1.修饰一般常量及数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> <span class="keyword">int</span> a=<span class="number">10</span>;                        <span class="keyword">int</span> <span class="keyword">const</span> a=<span class="number">10</span>;</span><br><span class="line"> <span class="keyword">const</span> <span class="keyword">int</span> arr[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;              <span class="keyword">int</span> <span class="keyword">const</span> arr[<span class="number">3</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="2-修饰指针变量-（重点-常量指针、指针常量）"><a href="#2-修饰指针变量-（重点-常量指针、指针常量）" class="headerlink" title="2.修饰指针变量*  （重点-常量指针、指针常量）"></a>2.修饰指针变量*  （重点-常量指针、指针常量）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* a = &amp; [<span class="number">1</span>]          <span class="comment">//指针指向的数据为常量，不能更改内容  //常量指针</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *a = &amp; [<span class="number">2</span>]          <span class="comment">//指针指向的数据为常量，不能更改内容  //常量指针</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> a = &amp; [<span class="number">3</span>]          <span class="comment">//指针指向的数据非常量，指针指向的地址不能变  //指针常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> a = &amp; [<span class="number">4</span>]    <span class="comment">//常量指针和指针常量</span></span><br></pre></td></tr></table></figure><p>常量指针：指针指向的数据为常量，不能变</p><p>指针常量：指针指向的地址不能变</p><p><br></p><h4 id="3-修饰引用变量-amp"><a href="#3-修饰引用变量-amp" class="headerlink" title="3.修饰引用变量&amp;"></a>3.修饰引用变量&amp;</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> &amp;a=x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;a=x;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="二、函数与-const"><a href="#二、函数与-const" class="headerlink" title="二、函数与 const"></a>二、函数与 const</h3><h4 id="1-作为参数的-const-修饰符"><a href="#1-作为参数的-const-修饰符" class="headerlink" title="1. 作为参数的 const 修饰符"></a>1. 作为参数的 const 修饰符</h4><p>不能对传递进来的指针的内容进行改变，保护了原指针所指向的内容</p><h4 id="2-作为函数返回值的-const-修饰符"><a href="#2-作为函数返回值的-const-修饰符" class="headerlink" title="2. 作为函数返回值的 const 修饰符"></a>2. 作为函数返回值的 const 修饰符</h4><p><br></p><h3 id="三、类与-const"><a href="#三、类与-const" class="headerlink" title="三、类与 const"></a>三、类与 const</h3><h4 id="1-类的-const-数据成员"><a href="#1-类的-const-数据成员" class="headerlink" title="1. 类的 const 数据成员"></a>1. 类的 const 数据成员</h4><p>只在某个对象生存期内是常量，而对于整个类而言却是可变的</p><p><br></p><h4 id="2-类的-const-成员函数（常量成员函数）"><a href="#2-类的-const-成员函数（常量成员函数）" class="headerlink" title="2. 类的 const 成员函数（常量成员函数）"></a>2. 类的 const 成员函数（常量成员函数）</h4><p><strong>类的成员函数后面加 const，表明这个函数不会对这个类对象的数据成员（非静态数据成员）作改变</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTest</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"const"</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"normal"</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    CTest a;  </span><br><span class="line">    a.show();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> CTest b;  </span><br><span class="line">    b.show();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h4 id="3-const-对象与-const-成员函数"><a href="#3-const-对象与-const-成员函数" class="headerlink" title="3. const 对象与 const 成员函数"></a>3. const 对象与 const 成员函数</h4><p>const 成员函数：可以访问非const对象的所有数据成员，也可以访问const对象内的所有数据成员</p><p>非const 成员函数：可以访问非const对象的所有数据成员，但<strong>不可以访问const对象的任意数据成员</strong></p><p><br></p><h2 id="（二）static"><a href="#（二）static" class="headerlink" title="（二）static"></a>（二）static</h2><h3 id="1-静态全局变量"><a href="#1-静态全局变量" class="headerlink" title="1. 静态全局变量"></a>1. 静态全局变量</h3><p>在全局数据区分配内存，不是在栈区，未经初始化的静态全局变量会被自动初始化为0</p><ul><li>全局变量：</li></ul><p>只需在一个源文件中定义，就可以<strong>作用于所有的源文件</strong></p><p>其他不包含全局变量定义的源文件需要用 <strong>extern 关键字再次声明这个全局变量</strong></p><ul><li>静态全局变量：</li></ul><p><strong>作用于定义它的文件里</strong>，不能作用到其它文件里，具有文件作用域</p><p>比如，两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量</p><p><br></p><h3 id="2-静态局部变量"><a href="#2-静态局部变量" class="headerlink" title="2. 静态局部变量"></a>2. 静态局部变量</h3><p>在全局数据区分配内存，不是在栈区，未经初始化的静态全局变量会被自动初始化为0</p><p>静态局部变量被首次初始化以后，函数调用不再进行初始化</p><p>实现在多次函数调用时，对变量的值进行保存</p><p><br></p><h3 id="3-静态函数"><a href="#3-静态函数" class="headerlink" title="3. 静态函数"></a>3. 静态函数</h3><p>类似于静态全局变量，<strong>只能在声明它的文件当中可见</strong>，不能被其它文件使用</p><p><br></p><h3 id="4-类与-static"><a href="#4-类与-static" class="headerlink" title="4. 类与 static"></a>4. 类与 static</h3><p>静态成员数据、静态成员函数被该类的所有对象所共有的</p><p>静态成员函数 <strong>不具有this指针</strong>，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数</p><p><br></p><p>注意</p><ul><li>static成员变量：不能在类的内部初始化，在类的内部只是声明，<strong>定义必须在类定义体的外部</strong></li><li>const成员变量：也不能在类定义处初始化，只能<strong>通过构造函数初始化列表初始化</strong></li></ul><p><br></p><h2 id="（三）extern"><a href="#（三）extern" class="headerlink" title="（三）extern"></a>（三）extern</h2><ol><li><p>extern 可以置于变量或者函数前，表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义</p><p>（感觉有点像头文件的功能）</p></li><li><p>extern 也可用来进行<strong>链接指定</strong>（在C++环境下使用C函数时）</p></li></ol><p><code>extern &quot;C&quot; void fun(int a, int b);</code></p><p>告诉编译器在编译fun这个函数名时，是按着C的规则而不是C++</p><p><br></p><p><strong>C++ 编译函数名时，为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称</strong></p><p>在C++环境下使用C函数的时候，常常会出现编译器无法找到obj模块中的C函数定义，链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，按照C的规则编译函数名</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最粗略的理解&lt;/p&gt;
&lt;p&gt;const：存储的内容不变&lt;/p&gt;
&lt;p&gt;static：存储的位置不变&lt;/p&gt;
&lt;p&gt;参考了好多篇其它博客，但是找不到了……&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习：指针和引用</title>
    <link href="http://yoursite.com/2018/10/20/C-%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2018/10/20/C-学习：指针和引用/</id>
    <published>2018-10-20T03:38:15.000Z</published>
    <updated>2018-10-20T03:41:04.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h2><ol><li>指针：存储的是变量的地址</li><li>引用：和原变量实质上是同一东西，只不过是原变量的一个别名</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;<span class="keyword">int</span> *p=&amp;a;  <span class="comment">// p的值是a的地址</span></span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;<span class="keyword">int</span> &amp;b=a;   <span class="comment">// a、b占据同一块内存</span></span><br></pre></td></tr></table></figure><a id="more"></a><p><br></p><h2 id="amp-和"><a href="#amp-和" class="headerlink" title="&amp;和*"></a>&amp;和*</h2><h3 id="1-amp-符号"><a href="#1-amp-符号" class="headerlink" title="1. &amp; 符号"></a>1. &amp; 符号</h3><ul><li>取址符，用于返回变量的实际地址</li><li>定义变量的引用，不代表取地址</li></ul><p><br></p><h3 id="2-符号"><a href="#2-符号" class="headerlink" title="2. * 符号"></a>2. * 符号</h3><p>用于返回地址所指向的变量（p存储的是变量的地址，*p表示该地址所指向的变量）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a;  </span><br><span class="line">  <span class="keyword">int</span> *aPtr; </span><br><span class="line">  a=<span class="number">7</span>;</span><br><span class="line">  aPtr = &amp;a;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"a="</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;                 <span class="comment">// a的值</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"*aPtr="</span>&lt;&lt;*aPtr&lt;&lt;<span class="built_in">endl</span>;         <span class="comment">// a的值，aPtr存放a的地址，取该地址指向的变量</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"&amp;*aPtr = "</span>&lt;&lt;&amp;*aPtr&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// a的地址，*aPtr指向a，&amp;*aPtr=&amp;a  </span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"*&amp;aPtr = "</span>&lt;&lt;*&amp;aPtr &lt;&lt;<span class="built_in">endl</span>; <span class="comment">// a的地址，&amp;aPtr取aPtr的地址，*&amp;aPtr就是aPtr中存放的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="指针和引用作为参数传递"><a href="#指针和引用作为参数传递" class="headerlink" title="指针和引用作为参数传递"></a>指针和引用作为参数传递</h2><p>1.指针作为参数传递</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> *p)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// p得到main传入的NULL</span></span><br><span class="line">　　<span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">　　p=&amp;a;</span><br><span class="line">　　<span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">" "</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p=<span class="literal">NULL</span>;</span><br><span class="line">    test(p);       <span class="comment">// 传入的是NULL</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"指针p为NULL"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果为：</span></span><br><span class="line"><span class="comment">//0x22ff44 1</span></span><br><span class="line"><span class="comment">//指针p为NULL</span></span><br></pre></td></tr></table></figure><p><br></p><p>2.引用作为参数传递</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="string">" "</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="string">" "</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    test(a);  <span class="comment">// </span></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果为：</span></span><br><span class="line"><span class="comment">//0x22ff44 1</span></span><br><span class="line"><span class="comment">//0x22ff44 1</span></span><br></pre></td></tr></table></figure><p><br></p><h2 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h2><ol><li><strong>可以有 const 指针，但是没有 const 引用</strong>  （？？）</li><li>指针可以有多级，但是引用只能是一级</li><li>指针的值可以为空，但是引用的值不能为NULL，并且<strong>引用在定义的时候必须初始化</strong></li><li>指针的值在初始化后可以改变，即指向其它的存储单元，而<strong>引用在初始化后就不会再改变</strong></li><li>“sizeof引用”得到的是所指向的变量的大小，而”sizeof指针”得到的是指针本身的大小</li><li>指针和引用的自增(++)运算意义不一样（？？）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;指针和引用&quot;&gt;&lt;a href=&quot;#指针和引用&quot; class=&quot;headerlink&quot; title=&quot;指针和引用&quot;&gt;&lt;/a&gt;指针和引用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;指针：存储的是变量的地址&lt;/li&gt;
&lt;li&gt;引用：和原变量实质上是同一东西，只不过是原变量的一个别名&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; *p=&amp;amp;a;  &lt;span class=&quot;comment&quot;&gt;// p的值是a的地址&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &amp;amp;b=a;   &lt;span class=&quot;comment&quot;&gt;// a、b占据同一块内存&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习：内存管理</title>
    <link href="http://yoursite.com/2018/10/19/C-%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2018/10/19/C-学习：内存管理/</id>
    <published>2018-10-19T13:58:27.000Z</published>
    <updated>2018-10-19T14:00:09.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>学习笔记参考：<a href="https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/" target="_blank" rel="noopener">https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/</a></p><a id="more"></a><p><br></p><h2 id="一、内存分配"><a href="#一、内存分配" class="headerlink" title="一、内存分配"></a>一、内存分配</h2><p>C++中，内存分成<strong>5个区</strong>，和 C 的内存分配不太一样，整体上一致</p><p><br></p><ol><li><p><strong>栈</strong>：由编译器在需要时自动分配和释放。通常用来存储局部变量、函数参数、返回地址等</p></li><li><p><strong>堆</strong>：由程序员分配释放，程序员没有释放掉，那么在程序结束后，操作系统会自动回收</p></li><li><p><strong>自由存储区</strong>：是C++中通过 new/delete 动态分配和释放对象的抽象概念</p></li><li><p><strong>全局/静态存储区</strong>：全局变量和静态变量被分配到同一块内存中</p></li><li><p><strong>常量存储区</strong>：存放的是常量，不允许修改</p><p>​</p></li></ol><p><img src="http://img.it610.com/image/info5/eae8b1536ec547d1ab59f6dab3b79347.jpg" alt="“c 语言 内存 分配”的图片搜索结果"></p><p><br></p><h2 id="二、动态内存分配和静态内存分配"><a href="#二、动态内存分配和静态内存分配" class="headerlink" title="二、动态内存分配和静态内存分配"></a>二、动态内存分配和静态内存分配</h2><h3 id="1-时间不同"><a href="#1-时间不同" class="headerlink" title="1. 时间不同"></a>1. 时间不同</h3><p>静态分配发生在程序编译和连接的时候</p><p>动态分配则发生在程序调入和执行的时候</p><h3 id="2-空间不同"><a href="#2-空间不同" class="headerlink" title="2. 空间不同"></a>2. 空间不同</h3><p>堆都是动态分配的，没有静态分配的堆</p><p>栈有静态分配和动态分配</p><p><br></p><h2 id="三、堆和栈的区别"><a href="#三、堆和栈的区别" class="headerlink" title="三、堆和栈的区别"></a>三、堆和栈的区别</h2><h3 id="1-管理方式"><a href="#1-管理方式" class="headerlink" title="1. 管理方式"></a>1. 管理方式</h3><p>栈：由<strong>编译器</strong>自动管理</p><p>堆：由程序员控制，容易产生内存泄漏</p><h3 id="2-碎片问题"><a href="#2-碎片问题" class="headerlink" title="2. 碎片问题"></a>2. 碎片问题</h3><p>堆：频繁的 <code>new/delete</code> 会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低</p><p>栈：是先进后出的队列，不可能有一个内存块从栈中间弹出</p><h3 id="3-生长方向"><a href="#3-生长方向" class="headerlink" title="3. 生长方向"></a>3. 生长方向</h3><p>堆：生长方向是向上的，也就是向着内存地址增加的方向</p><p>栈：生长方向是向下的，是向着内存地址减小的方向增长</p><h3 id="4-分配方式"><a href="#4-分配方式" class="headerlink" title="4. 分配方式"></a>4. 分配方式</h3><p>堆：动态分配，没有静态分配的堆</p><p>栈：静态分配和动态分配，静态分配是编译器完成</p><h3 id="5-分配效率"><a href="#5-分配效率" class="headerlink" title="5. 分配效率"></a>5. 分配效率</h3><p><strong>堆的效率比栈要低得多</strong></p><p>栈：计算机底层会对栈提供支持，分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行</p><p>堆：由C/C++函数库提供</p><p>例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间</p><p><br></p><h2 id="四、new-delete-和-malloc-free-的区别"><a href="#四、new-delete-和-malloc-free-的区别" class="headerlink" title="四、new/delete 和 malloc/free 的区别"></a>四、new/delete 和 malloc/free 的区别</h2><p><a href="https://blog.csdn.net/Hackbuteer1/article/details/6789164" target="_blank" rel="noopener">https://blog.csdn.net/Hackbuteer1/article/details/6789164</a></p><h3 id="1-new-delete"><a href="#1-new-delete" class="headerlink" title="1. new/delete"></a>1. new/delete</h3><p>是C++的<strong>运算符</strong>，无须指定内存块的大小</p><p>内存分配成功时，返回的是对象类型的指针，无须进行类型转换</p><p>注意：</p><p>1.用new 创建对象数组，那么只能使用对象的无参数构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Obj *objects = new Obj[100];           // 创建100 个动态对象</span><br><span class="line">Obj *objects = new Obj[100](1);        // 错误写法，创建100 个动态对象的同时赋初值1</span><br></pre></td></tr></table></figure><p>2.用delete 释放对象数组时，留意不要丢了符号‘[]’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete []objects;   // 正确的用法</span><br><span class="line">delete objects;     // 错误的用法，只释放了一个对象</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-malloc与free"><a href="#2-malloc与free" class="headerlink" title="2. malloc与free"></a>2. malloc与free</h3><p>是C++/C 语言的<strong>标准库函数</strong>，<strong>需要显式地指出所需内存大小</strong> ，因为并不知道申请的内存是什么类型，只关心内存的总字节数</p><p>存分配成功则是返回void <em> ，**需要通过强制类型转换将void</em>指针转换成所需类型**</p><p>对于非内部数据类的对象而言，即<strong>用户自定义的对象，无法用 malloc/free 动态管理对象</strong>（我的理解，自己定义了一个类，可以用new实例化该类，但是不能用malloc为该类分配内存，更不能执行构造函数、析构函数）</p><p><br></p><h3 id="3-对象动态管理"><a href="#3-对象动态管理" class="headerlink" title="3. 对象动态管理"></a>3. 对象动态管理</h3><p>对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数</p><p>由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free</p><p>运算符new能完成动态内存分配和初始化工作，运算符delete能完成清理与释放内存工作</p><p><br></p><h2 id="五、内存错误"><a href="#五、内存错误" class="headerlink" title="五、内存错误"></a>五、内存错误</h2><h3 id="1-内存分配未成功"><a href="#1-内存分配未成功" class="headerlink" title="1. 内存分配未成功"></a>1. 内存分配未成功</h3><p>内存分配未成功，就使用</p><p>常用解决办法是，在使用内存之前检查指针是否为<code>NULL</code></p><h3 id="2-内存越界"><a href="#2-内存越界" class="headerlink" title="2. 内存越界"></a>2. 内存越界</h3><p>例如在使用数组时经常发生下标“多1”或者“少1”的操作</p><h3 id="3-内存泄露（指针不存在）"><a href="#3-内存泄露（指针不存在）" class="headerlink" title="3. 内存泄露（指针不存在）"></a>3. 内存泄露（指针不存在）</h3><p>申请的内存空间没有被正确释放，<strong>而指向这块内存空间的指针不再存在</strong></p><p>含有这种错误的函数每被调用一次就丢失一块内存</p><h3 id="4-释放内存却继续使用"><a href="#4-释放内存却继续使用" class="headerlink" title="4. 释放内存却继续使用"></a>4. 释放内存却继续使用</h3><p>函数  <code>return</code> 了指向栈内存的指针或者引用，但是该内存在函数体结束时就已经被自动销毁了</p><h3 id="5-野指针（指针指向错误的内存）"><a href="#5-野指针（指针指向错误的内存）" class="headerlink" title="5. 野指针（指针指向错误的内存）"></a>5. 野指针（指针指向错误的内存）</h3><p>（1）释放了内存后，指针仍然指向这个已删除的对象，没有将指针设为 <code>NULL</code></p><p>（2）指针未被初始化就被引用，<strong>指向一个未知的地址</strong></p><p><strong>与空指针不同，野指针无法通过简单地判断是否为 NULL 来避免</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h1&gt;&lt;p&gt;学习笔记参考：&lt;a href=&quot;https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习：C和C++的I/O库区别</title>
    <link href="http://yoursite.com/2018/10/19/C-%E5%AD%A6%E4%B9%A0%EF%BC%9AC%E5%92%8CC-%E7%9A%84I-O%E5%BA%93%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/10/19/C-学习：C和C-的I-O库区别/</id>
    <published>2018-10-19T07:16:53.000Z</published>
    <updated>2018-10-19T07:18:23.829Z</updated>
    
    <content type="html"><![CDATA[<p>PS：下面是我个人对两种I/O库的理解</p><p>C语言的输入输出：需要标准流和输入输出函数共同实现，这是个过程</p><p>C++的输入输出：实例化ios类为对象，这是面向对象</p><p>最近看的两个项目，一个是C，一个是C++，突然发现真的有很多不同</p><a id="more"></a><p><br></p><h1 id="C语言—标准I-O"><a href="#C语言—标准I-O" class="headerlink" title="C语言—标准I/O"></a>C语言—标准I/O</h1><p>C语言的I/O相关函数封装在头文件 \&lt;stdio.h></p><p><br></p><h3 id="1-三个标准流"><a href="#1-三个标准流" class="headerlink" title="1. 三个标准流"></a>1. 三个标准流</h3><p>PS：我对流的理解，是数据源源不断的流动，标准应该是指某种规则</p><ul><li><p>标准输入流 stdin：从键盘输入 </p></li><li><p>标准输出流 stdout：默认是输出到屏幕 </p><p>stdout 是行缓冲的，输出会放在一个buffer里面，<strong>只有到换行的时候，才会输出到屏幕</strong></p></li></ul><ul><li><p>标准错误流 stderr：默认是输出到屏幕</p><p>stderr 是无缓冲的，会直接输出</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"Hello"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"World!"</span>);</span><br><span class="line">return0;</span><br><span class="line">&#125;  <span class="comment">// 输出结果：World!Hello</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-格式化输入、输出"><a href="#2-格式化输入、输出" class="headerlink" title="2. 格式化输入、输出"></a>2. 格式化输入、输出</h3><h4 id="（1）格式化输入"><a href="#（1）格式化输入" class="headerlink" title="（1）格式化输入"></a>（1）格式化输入</h4><ul><li>scanf：从控制台输入 </li><li>fscanf ：从文件输入 </li><li>sscanf ：从指定字符串输入</li></ul><h4 id="（2）格式化输出"><a href="#（2）格式化输出" class="headerlink" title="（2）格式化输出"></a>（2）格式化输出</h4><ul><li>printf：向屏幕这样的标准输出设备输出</li><li>sprintf：格式化输出到一个字符串</li><li>fprintf：格式化输出到流 stream指定的文件</li></ul><p><br></p><h3 id="3-标准流和格式化输入输出函数的关系"><a href="#3-标准流和格式化输入输出函数的关系" class="headerlink" title="3. 标准流和格式化输入输出函数的关系"></a>3. 标准流和格式化输入输出函数的关系</h3><p>PS：段小洋说不能单独讲流或输入输出，应该就是输入输出流，两者是绑定的，但是我就是想把它分开来，这样好理解嘛 ~</p><p><strong>C语言把所有的设备（比如显示器、键鼠、U盘等）都当做文件</strong>，把所有的东西都当作文件来处理</p><p>程序与文件交互时，会默认创建 stdin、stdout、stderr 三个文件</p><p>比如，stdin先接收键盘的数据，然后通过输入函数将数据输入到程序里</p><p><br></p><h1 id="C-—标准I-O"><a href="#C-—标准I-O" class="headerlink" title="C++—标准I/O"></a>C++—标准I/O</h1><p><a href="https://www.cnblogs.com/xumengpiaoyun/archive/2013/04/21/3034195.html" target="_blank" rel="noopener">https://www.cnblogs.com/xumengpiaoyun/archive/2013/04/21/3034195.html</a></p><p><br></p><ul><li>标准I/O：对系统指定的<strong>标准设备</strong>的输入和输出（键盘输入数据，输出到显示屏幕）</li><li>文件I/O：<strong>外存磁盘文件</strong>为对象进行输入和输出（从磁盘文件输入数据，数据输出到磁盘文件）</li><li>字符串I/O：对内存中指定的空间进行输入和输出</li></ul><p><br></p><h3 id="1-I-O类库中的常用流类"><a href="#1-I-O类库中的常用流类" class="headerlink" title="1. I/O类库中的常用流类"></a>1. I/O类库中的常用流类</h3><p><img src="https://images0.cnblogs.com/blog/476361/201304/21180804-68564fc8ad1b4472b8ba6012d51c6db3.jpg" alt="img"></p><p><br></p><h3 id="2-头文件"><a href="#2-头文件" class="headerlink" title="2.头文件"></a>2.头文件</h3><p>iostream类库的即可分别由不同的头文件来实现，命名空间为 std</p><ul><li>iostream：标准I/O，对系统指定的标准设备的输入和输出（比如键盘输入数据，输出到显示屏幕）</li><li>fstream：文件I/O，以磁盘文件为对象的输入和输出（从磁盘文件输入数据，数据输出到磁盘文件）</li><li>strstream：字符串I/O，对内存中指定的空间的输入和输出</li></ul><p><br></p><p>PS：标准输入输出流、格式化输入输出都是对流类实例化为对象</p><h3 id="3-标准输入流"><a href="#3-标准输入流" class="headerlink" title="3. 标准输入流"></a>3. 标准输入流</h3><ul><li>cin流对象：从输入流提取数据，遇到空格或者回车就终止。</li><li>cin.get()</li></ul><ul><li><p>cin.getline()</p><p><br></p></li></ul><h3 id="4-标准输出流"><a href="#4-标准输出流" class="headerlink" title="4. 标准输出流"></a>4. 标准输出流</h3><ul><li>cout 流对象：可以传送到显示器输出，也可以<strong>重定向到磁盘文件</strong></li><li>cerr 流对象：只能在显示器输出，<strong>不经过缓冲区</strong></li><li>clog 流对象：在显示器显示错误信息，<strong>缓冲区满</strong> 后或者遇 <strong>endl</strong> 时向显示器输出</li></ul><p><br></p><h3 id="5-格式化输入输出"><a href="#5-格式化输入输出" class="headerlink" title="5. 格式化输入输出"></a>5. 格式化输入输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//控制格式化, 输出</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default bool values : "</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span></span><br><span class="line">&lt;&lt; <span class="string">"\nalpha bool values : "</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span></span><br><span class="line">&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"no reset bool : "</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//没有重置</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::noboolalpha &lt;&lt; <span class="string">"reset bool : "</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//重置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//整数的基, 显示, 大写</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::showbase;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default : "</span> &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="number">1024</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//默认</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"octal : "</span> &lt;&lt; oct &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="number">1024</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//8进制</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::uppercase &lt;&lt; <span class="string">"hex : "</span> &lt;&lt; hex &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="number">1024</span></span><br><span class="line">&lt;&lt; <span class="built_in">std</span>::nouppercase &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//16进制</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"decimal : "</span>  &lt;&lt; dec&lt;&lt; <span class="number">20</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="number">1024</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//10进制</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::noshowbase;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：下面是我个人对两种I/O库的理解&lt;/p&gt;
&lt;p&gt;C语言的输入输出：需要标准流和输入输出函数共同实现，这是个过程&lt;/p&gt;
&lt;p&gt;C++的输入输出：实例化ios类为对象，这是面向对象&lt;/p&gt;
&lt;p&gt;最近看的两个项目，一个是C，一个是C++，突然发现真的有很多不同&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习：内存对齐</title>
    <link href="http://yoursite.com/2018/10/19/C-%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <id>http://yoursite.com/2018/10/19/C-学习：内存对齐/</id>
    <published>2018-10-19T07:13:24.000Z</published>
    <updated>2018-10-19T07:13:47.034Z</updated>
    
    <content type="html"><![CDATA[<p>PS：这篇博客写得很详细，下面的学习笔记都是参考其完成</p><p> <a href="https://blog.csdn.net/markl22222/article/details/38051483" target="_blank" rel="noopener">https://blog.csdn.net/markl22222/article/details/38051483</a></p><a id="more"></a><h2 id="一、内存对齐-Data-structure-alignment"><a href="#一、内存对齐-Data-structure-alignment" class="headerlink" title="一、内存对齐 Data structure alignment"></a>一、内存对齐 Data structure alignment</h2><p>PS：WiKi 的定义很清楚，内存对齐就是数据在电脑中的存储方式</p><p>Data structure alignment refers to the way <strong>data is arranged and accessed in computer memory</strong>. </p><p>It consists of three separate but related issues:</p><ul><li>data alignment</li><li>data structure padding</li><li>packing</li></ul><p><br></p><h3 id="1-内存对齐（Data-structure-alignment）"><a href="#1-内存对齐（Data-structure-alignment）" class="headerlink" title="1. 内存对齐（Data structure alignment）"></a>1. 内存对齐（Data structure alignment）</h3><p>是一个数据类型所存放的<strong>内存地址的属性</strong>，这个属性是一个无符号整数，并且这个整数必须是2的N次方 1、2、4、8、……</p><p>比如，<strong>一个数据类型的内存对齐为8，是指这个数据类型定义出来的所有变量，其内存地址都是8的倍数</strong></p><h3 id="2-自然对齐（naturally-aligned）"><a href="#2-自然对齐（naturally-aligned）" class="headerlink" title="2. 自然对齐（naturally aligned）"></a>2. 自然对齐（naturally aligned）</h3><p>基本数据类型的对齐属性，和这个数据类型的大小相等时，这种对齐方式称作自然对齐</p><p>比如，一个4字节大小的int型数据，默认情况下它的内存对齐也是4</p><p><br></p><h2 id="二、为什么要用内存对齐？"><a href="#二、为什么要用内存对齐？" class="headerlink" title="二、为什么要用内存对齐？"></a>二、为什么要用内存对齐？</h2><p><strong>考虑到CPU处理内存的方式</strong></p><p>32位的x86 CPU，一个时钟周期可以读取4个连续的内存单元，即4字节，使用字节对齐将会提高系统的性能，也就是CPU读取内存数据的效率。</p><p>比如，一个int放在奇数内存位置上，将4个字节读出，32位CPU就需要两次，但对齐之后一次就可以。</p><p><br></p><h2 id="三、数据填充-Data-Structure-Padding"><a href="#三、数据填充-Data-Structure-Padding" class="headerlink" title="三、数据填充 Data Structure Padding"></a>三、数据填充 Data Structure Padding</h2><p>内存对齐可能会让数据在内存里的存放不是紧挨着的，而是可能会出现一些空隙</p><p>举个例子：</p><p>1.定义一个结构体，如果直接相加占用内存是16，sizeof 的结果其实更大，这是因为，为了保证这个结构体里的每个成员都应该在它对齐的内存位置上，而在某些位置插入了Padding</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;         <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="keyword">int</span> b;          <span class="comment">// 4 bytes</span></span><br><span class="line">    <span class="keyword">short</span> c;        <span class="comment">// 2 bytes</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> d;    <span class="comment">// 8 bytes</span></span><br><span class="line">    <span class="keyword">char</span> e;         <span class="comment">// 1 byte</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.填充后的结果</p><p>当然，<strong>不同平台下会使用不同的默认对齐值</strong>，下面这个只是一种方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;         <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="keyword">char</span> pad_0[<span class="number">3</span>];  <span class="comment">// Padding 3</span></span><br><span class="line">    <span class="keyword">int</span> b;          <span class="comment">// 4 bytes</span></span><br><span class="line">    <span class="keyword">short</span> c;        <span class="comment">// 2 bytes</span></span><br><span class="line">    <span class="keyword">char</span> pad_1[<span class="number">6</span>];  <span class="comment">// Padding 6</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> d;    <span class="comment">// 8 bytes</span></span><br><span class="line">    <span class="keyword">char</span> e;         <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="keyword">char</span> pad_2[<span class="number">7</span>];  <span class="comment">// Padding 7</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3.结构体类型本身的内存对齐</p><p>为了保证结构体内的每个成员都能够放在它自然对齐的位置上，对这个结构体本身来说最理想的内存对齐数值应该是结构体里内存对齐数值最大的成员的内存对齐数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：这篇博客写得很详细，下面的学习笔记都是参考其完成&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://blog.csdn.net/markl22222/article/details/38051483&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/markl22222/article/details/38051483&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习：类</title>
    <link href="http://yoursite.com/2018/10/19/C-%E5%AD%A6%E4%B9%A0%EF%BC%9A%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/10/19/C-学习：类/</id>
    <published>2018-10-19T07:08:35.000Z</published>
    <updated>2018-10-19T07:11:46.060Z</updated>
    
    <content type="html"><![CDATA[<ol><li>类与对象</li><li>继承</li><li>重载</li><li>多态</li><li>抽象类</li><li><a id="more"></a></li></ol><p><br></p><h1 id="一、类与对象"><a href="#一、类与对象" class="headerlink" title="一、类与对象"></a>一、类与对象</h1><p><br></p><h2 id="1-成员函数"><a href="#1-成员函数" class="headerlink" title="1. 成员函数"></a>1. 成员函数</h2><p>定义</p><ul><li>在类定义内部定义（默认 inline）</li><li>在类的外部使用<strong>范围解析运算符 ::</strong> 来定义</li></ul><p><br></p><h2 id="2-类访问修饰符"><a href="#2-类访问修饰符" class="headerlink" title="2. 类访问修饰符"></a>2. 类访问修饰符</h2><ul><li>public：数据和函数在类的外部是可访问的，可以不使用任何成员函数来访问工有数据</li><li>private：</li><li><ul><li>数据和函数在类的外部是不可访问的</li><li><strong>只有类和友元函数可以访问私有成员，不能被派生类访问</strong></li></ul></li><li>（PS：没有使用任何访问修饰符，类的成员将被假定为私有成员）</li><li>protected：数据和函数在类的外部是不可访问的，<strong>在派生类（即子类）中是可访问的</strong></li></ul><p><br></p><h2 id="3-构造函数与析构函数"><a href="#3-构造函数与析构函数" class="headerlink" title="3. 构造函数与析构函数"></a>3. 构造函数与析构函数</h2><ol><li><p>构造函数的名称与类的名称完全相同，并且<strong>不会返回任何类型，也不会返回 void</strong>   </p><p>可以使用初始化列表来初始化字段</p></li><li><p>析构函数的名称与类的名称完全相同，只是在前面加了 ~，不会返回任何值，也不能带有任何参数</p><p>析构函数完成对象被删除前的一些清理工作</p></li></ol><p><br></p><h2 id="4-拷贝构造函数"><a href="#4-拷贝构造函数" class="headerlink" title="4. 拷贝构造函数"></a>4. 拷贝构造函数</h2><p>拷贝构造函数是一种特殊的构造函数，使用同一类中之前创建的对象来初始化新创建的对象</p><p>拷贝造函数的名称与类的名称完全相同，并且不会返回任何类型，其<strong>参数是同类对象的引用</strong></p><p><br></p><h2 id="5-友元函数"><a href="#5-友元函数" class="headerlink" title="5. 友元函数"></a>5. 友元函数</h2><p>类的友元函数<strong>『并不是成员函数』</strong>，是定义在类外部，但<strong>有权访问类的所有私有和保护成员</strong></p><p>在类定义中该函数原型前使用关键字 <strong>friend</strong></p><p><br></p><h2 id="6-内联函数"><a href="#6-内联函数" class="headerlink" title="6. 内联函数"></a>6. 内联函数</h2><p>如果一个函数是内联的，那么在编译时，编译器会把出现内联函数调用表达式的地方，用内联函数的函数体进行替换</p><p>在函数名前面放置关键字 <strong>inline</strong></p><p>内联函数是为了解决程序中函数调用的效率问题，就是<strong>空间换时间</strong>，所以内联函数一般都是小函数</p><p>注意：</p><ul><li><p>在内联函数内不允许使用循环语句和开关语句</p></li><li><p>内联函数的定义必须出现在内联函数第一次调用之前</p></li><li><p><strong>在类内部定义的函数会默认声明为inline函数，所有不用显示地去声明inline</strong></p><p><br></p></li></ul><h2 id="7-this-指针"><a href="#7-this-指针" class="headerlink" title="7. this 指针"></a>7. this 指针</h2><p>每一个对象都能通过 this 指针来访问自己的地址</p><p>this指针是所有成员函数的隐含参数，<strong>在成员函数内部，this指针可以用来指向目前调用的对象</strong></p><p>友元函数没有 this 指针，因为不是类的成员</p><p><br></p><h2 id="8-静态成员"><a href="#8-静态成员" class="headerlink" title="8. 静态成员"></a>8. 静态成员</h2><p>静态成员在类的所有对象中是共享的</p><h3 id="1）-静态成员数据"><a href="#1）-静态成员数据" class="headerlink" title="1） 静态成员数据"></a>1） 静态成员数据</h3><p>如果不存在初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零</p><p><strong>不能把静态数据的初始化放在类的定义</strong>中，而是在类的外部使用范围解析运算符 :: 来进行初始化</p><p><br></p><h3 id="2）-静态成员函数"><a href="#2）-静态成员函数" class="headerlink" title="2） 静态成员函数"></a>2） 静态成员函数</h3><p>静态成员函<strong>与类的对象是独立的</strong>，<strong>在类对象不存在的情况下也能被调用</strong></p><p><strong>『静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数，且没有 this 指针』</strong></p><p>这个例子挺好的：<a href="http://www.runoob.com/cplusplus/cpp-static-members.html" target="_blank" rel="noopener">http://www.runoob.com/cplusplus/cpp-static-members.html</a></p><p><br></p><h1 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h1><h2 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h2><p>一个类可以派生自多个类，即一个（子类/派生类）可以有多个（父类/基类）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> &lt;派生类名&gt;:</span>&lt;继承方式<span class="number">1</span>&gt;&lt;基类名<span class="number">1</span>&gt;,&lt;继承方式<span class="number">2</span>&gt;&lt;基类名<span class="number">2</span>&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="2-继承方式不同，基类成员在派生类中的访问属性不同"><a href="#2-继承方式不同，基类成员在派生类中的访问属性不同" class="headerlink" title="2. 继承方式不同，基类成员在派生类中的访问属性不同"></a>2. 继承方式不同，基类成员在派生类中的访问属性不同</h2><p>三种继承方式，使得基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：</p><ul><li>public 继承：public, protected, private</li><li>protected 继承：protected, protected, private</li><li>private 继承：private, private, private</li></ul><p><br></p><h2 id="3-派生类中构造函数和析构函数的调用"><a href="#3-派生类中构造函数和析构函数的调用" class="headerlink" title="3. 派生类中构造函数和析构函数的调用"></a>3. 派生类中构造函数和析构函数的调用</h2><ul><li>创建子类时先调用父类的构造函数然后再调用自己的构造函数</li><li>子类先调用自身的析构函数再调用父类的析构函数</li></ul><p><br></p><h3 id="1）构造函数不能是虚函数"><a href="#1）构造函数不能是虚函数" class="headerlink" title="1）构造函数不能是虚函数"></a>1）构造函数不能是虚函数</h3><p>从继承来讲，总是要先构造父类对象,然后才能是子类对象</p><p>虚函数的作用在于通过父类的指针或者引用，来调用子类的成员函数，而构造函数是在创建对象时<strong>自动调用</strong>，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数</p><p><br></p><h3 id="2）通常将基类的析构函数定义为虚函数的原因"><a href="#2）通常将基类的析构函数定义为虚函数的原因" class="headerlink" title="2）通常将基类的析构函数定义为虚函数的原因"></a>2）通常将基类的析构函数定义为虚函数的原因</h3><ul><li>当派生类指针指向派生类时，先调用派生类的析构函数再调用基类的析构函数</li><li>当基类指针指向派生类对象实现多态时，在析构时<strong>为了防止只析构基类而不析构派生类</strong>，一般会将基类析构函数定义为虚基类，这样就会先调用派生类析构函数，再调用基类析构函数</li></ul><p><br></p><h1 id="三、函数重载和运算符重载"><a href="#三、函数重载和运算符重载" class="headerlink" title="三、函数重载和运算符重载"></a>三、函数重载和运算符重载</h1><p>重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义不同</p><p>重载的运算符其实是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符构成</p><p>并且重载运算符这个特殊函数是有返回类型和参数列表</p><p><br></p><p>注意：</p><ul><li>运算重载符不可以改变操作数的个数</li><li>运算重载符不可以改变优先级</li><li>运算重载符不可以改变结合性</li><li>有些运算符是不可重载的 </li></ul><p><br></p><h1 id="四、多态"><a href="#四、多态" class="headerlink" title="四、多态"></a>四、多态</h1><p>多态发生的条件：<strong>多态只在『基类指针或引用指向派生类对象』的时候才发生，并且基类函数是虚函数</strong></p><p><br></p><h2 id="1-基类、派生类指针指向的对象"><a href="#1-基类、派生类指针指向的对象" class="headerlink" title="1. 基类、派生类指针指向的对象"></a>1. 基类、派生类指针指向的对象</h2><ul><li>基类指针指向派生类对象，是安全的</li><li>派生类指针指向基类对象，会产生编译错误</li><li>派生类指针指向派生类对象，调用的是派生类的成员</li></ul><h2 id="2-虚函数"><a href="#2-虚函数" class="headerlink" title="2. 虚函数"></a>2. 虚函数</h2><p>在基类中使用关键字 <strong>virtual</strong> 声明的函数，派生类中重新定义基类中定义的虚函数</p><p>虚函数使用条件是当<strong>『基类指针指向派生类对象』</strong>时，会告诉编译器不要<strong>静态链接</strong>到基类的虚函数，而是根据所调用的对象类型<strong>动态链接</strong>到派生类中的成员函数</p><p>基类的指针指向派生类的对象，当调用同名的成员函数时：</p><ul><li>如果在基类中成员函数为虚函数，那么基类指针调用的就是派生类的同名函数</li><li>如果基类中成员函数为非虚函数，则调用的是基类的成员函数</li></ul><h2 id="3-纯虚函数"><a href="#3-纯虚函数" class="headerlink" title="3. 纯虚函数"></a>3. 纯虚函数</h2><p>在基类中不给虚函数提供有意义的定义实现，纯虚函数的意义在于定义抽象类</p><p>声明是在普通的虚函数后面加上”=0”  <code>virtual int area() = 0;</code></p><p><br></p><h1 id="五、抽象类"><a href="#五、抽象类" class="headerlink" title="五、抽象类"></a>五、抽象类</h1><p>抽象类：如果类中<strong>至少有一个函数被声明为纯虚函数</strong>，则这个类就是抽象类</p><p>抽象类不能被用于实例化对象</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;类与对象&lt;/li&gt;
&lt;li&gt;继承&lt;/li&gt;
&lt;li&gt;重载&lt;/li&gt;
&lt;li&gt;多态&lt;/li&gt;
&lt;li&gt;抽象类&lt;/li&gt;
&lt;li&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习：标准库和标准模板库</title>
    <link href="http://yoursite.com/2018/10/19/C-%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/"/>
    <id>http://yoursite.com/2018/10/19/C-学习：标准库和标准模板库/</id>
    <published>2018-10-19T07:06:09.000Z</published>
    <updated>2018-10-19T07:08:01.720Z</updated>
    
    <content type="html"><![CDATA[<p>C++标准库包括标准模板库STL</p><a id="more"></a><p><br></p><h2 id="一、标准库"><a href="#一、标准库" class="headerlink" title="一、标准库"></a>一、标准库</h2><ul><li>C++ 标准库头文件 \&lt;xxx>，C++标准库中涵盖C库功能的子库，通常头文件以c开头\&lt;cxxx></li><li>C 标准库头文件 \&lt;xxx.h></li></ul><p>注意：<strong>不同操作西都有其自己的 C++ 标准库实现</strong>， C++编译器在实现 C++ 标准库过程中必须依赖不同操作系统所提供的系统调用接口</p><p><br></p><h2 id="二、标准模板库"><a href="#二、标准模板库" class="headerlink" title="二、标准模板库"></a>二、标准模板库</h2><p>C++标准库包括标准模板库STL</p><p>STL的代码从广义上分为三类：<strong>algorithm（算法）、container（容器）和 iterator（迭代器）</strong>，几乎所有的代码都采用了模板类和模板函数的方式</p><p><br></p><p><strong>容器</strong></p><table><thead><tr><th>数据结构</th><th>描述</th><th>头文件</th></tr></thead><tbody><tr><td>向量(vector)</td><td>连续存储的元素</td><td><vector></vector></td></tr><tr><td>列表(list)</td><td>由节点组成的双向链表，每个结点包含着一个元素</td><td><list></list></td></tr><tr><td>双队列(deque)</td><td>连续存储的指向不同元素的指针所组成的数组</td><td><deque></deque></td></tr><tr><td>集合(set)</td><td>由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序</td><td><set></set></td></tr><tr><td>多重集合(multiset)</td><td>允许存在两个次序相等的元素的集合</td><td><set></set></td></tr><tr><td>栈(stack)</td><td>后进先出的值的排列</td><td><stack></stack></td></tr><tr><td>队列(queue)</td><td>先进先出的执的排列</td><td><queue></queue></td></tr><tr><td>优先队列(priority_queue)</td><td>元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列</td><td><queue></queue></td></tr><tr><td>映射(map)</td><td>由{键，值}对组成的集合，以某种作用于键对上的谓词排列</td><td><map></map></td></tr><tr><td>多重映射(multimap)</td><td>允许键对有相等的次序的映射</td><td><map></map></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++标准库包括标准模板库STL&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统启动过程</title>
    <link href="http://yoursite.com/2018/10/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/10/18/操作系统启动过程/</id>
    <published>2018-10-18T14:13:16.000Z</published>
    <updated>2018-10-19T03:38:45.413Z</updated>
    
    <content type="html"><![CDATA[<p>操作系统启动过程</p><p><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/02/booting.html</a></p><ol><li>BIOS 硬件自检</li><li>根据启动顺序，定位到存储设备</li><li>根据主引导记录中的分区表（存储设备的第一个扇区），定位到主分区</li></ol><a id="more"></a><h2 id="一、BIOS"><a href="#一、BIOS" class="headerlink" title="一、BIOS"></a>一、BIOS</h2><p>计算机通电后，第一件事就是读取被刷入ROM芯片的开机程序，这块芯片里的程序叫做<strong>『基本输入输出系统，Basic Input/Output System，BIOS』</strong></p><p>BIOS 程序首先检查，计算机硬件能否满足运行的基本条件，这叫做<strong>『硬件自检，Power-On Self-Test，POST』</strong></p><h2 id="二、主引导记录"><a href="#二、主引导记录" class="headerlink" title="二、主引导记录"></a>二、主引导记录</h2><h3 id="1-启动顺序"><a href="#1-启动顺序" class="headerlink" title="1. 启动顺序"></a>1. 启动顺序</h3><p>BIOS 根据启动顺序，把控制权转交给启动顺序排在第一位的储存设备，读取该设备的第一个扇区，即主引导记录，进行下一阶段的启动程序</p><p>启动顺序，Boot Sequence：外部储存设备的排序，排在前面的设备就是优先转交控制权的设备</p><p>主引导记录，Master boot record，MBR：计算机读取该设备的<strong>第一个扇区</strong>，也就是最前面的512个字节</p><p>如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动。如果不是，表明设备不能用于启动，控制权于是被转交给启动顺序中的下一个设备</p><h3 id="2-主引导记录"><a href="#2-主引导记录" class="headerlink" title="2. 主引导记录"></a>2. 主引导记录</h3><p>第一个扇区，即最前面的512个字节，就叫做<strong>『主引导记录，Master boot record，MBR』</strong>主要是告诉计算机到硬盘的哪一个位置去找操作系统。</p><p>主引导记录由三个部分组成：</p><p>（1） 第1-446字节：调用操作系统的机器码</p><p>（2） 第447-510字节：分区表</p><p>可以将硬盘分成若干个区安装不同的操作系统，一个硬盘最多只能分四个一级分区，又叫 <strong>“主分区”</strong></p><p>（3） 第511-512字节：主引导记录签名（0x55和0xAA）</p><h2 id="三、硬盘启动"><a href="#三、硬盘启动" class="headerlink" title="三、硬盘启动"></a>三、硬盘启动</h2><p>计算机的控制权转交给硬盘的某个分区</p><h3 id="1-卷引导记录"><a href="#1-卷引导记录" class="headerlink" title="1. 卷引导记录"></a>1. 卷引导记录</h3><p>四个主分区里面，只有一个是激活的</p><p>计算机会读取激活分区的第一个扇区，叫做”卷引导记录”，作用是告诉计算机，操作系统在这个分区里的位置，计算机加载操作系统</p><h3 id="2-启动管理器"><a href="#2-启动管理器" class="headerlink" title="2. 启动管理器"></a>2. 启动管理器</h3><p>计算机读取”主引导记录”前面1-446个字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的”启动管理器”（boot loader），由用户选择启动哪一个操作系统</p><h2 id="四、操作系统"><a href="#四、操作系统" class="headerlink" title="四、操作系统"></a>四、操作系统</h2><p>控制权转交给操作系统后，<strong>操作系统的内核首先被载入内存</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;操作系统启动过程&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/02/booting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ruanyifeng.com/blog/2013/02/booting.html&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BIOS 硬件自检&lt;/li&gt;
&lt;li&gt;根据启动顺序，定位到存储设备&lt;/li&gt;
&lt;li&gt;根据主引导记录中的分区表（存储设备的第一个扇区），定位到主分区&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>处理器</title>
    <link href="http://yoursite.com/2018/10/18/%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>http://yoursite.com/2018/10/18/处理器/</id>
    <published>2018-10-18T01:34:38.000Z</published>
    <updated>2018-10-26T02:14:53.820Z</updated>
    
    <content type="html"><![CDATA[<p>指令集和处理器架构：<a href="https://www.zhihu.com/question/23474438" target="_blank" rel="noopener">https://www.zhihu.com/question/23474438</a></p><p>（我的理解：处理器架构是指硬件设计，对应相应指令集，即二进制机器码，实现某种功能，两者是配套的）</p><a id="more"></a><p><br></p><h2 id="一、指令集"><a href="#一、指令集" class="headerlink" title="一、指令集"></a>一、指令集</h2><p>指令集，规定处理器相应操作，通过指令集去控制处理器实现相应功能，但处理器是一堆硬件电路，只能识别二进制数据，所以指令集是由一堆二进制数据组成</p><p>（我的理解： CPU 读入调用指令集的命令，通过指令集来实现具体的功能）</p><p><br></p><h2 id="二、处理器架构"><a href="#二、处理器架构" class="headerlink" title="二、处理器架构"></a>二、处理器架构</h2><p><strong>处理器架构是用硬件电路实现指令集所规定的操作运算，所以是指令集决定了处理器的架构</strong></p><p>四大CPU体系架构：前两个为主流</p><ul><li><strong>x86 ：Intel、AMD（复杂指令集）</strong></li><li><strong>ARM架构：ARM公司（精简指令集）</strong></li><li>PowerPC架构：IBM公司（精简指令集）</li><li>MIPS架构（精简指令集）</li></ul><p><br></p><p>Intel 处理器分类：<a href="https://www.zhihu.com/question/32669957" target="_blank" rel="noopener">https://www.zhihu.com/question/32669957</a></p><p><img src="https://pic3.zhimg.com/v2-73ba36e9a085e8f666d039a1a465e44a_r.jpg" alt="preview"></p><p><br></p><h2 id="三、汇编语言"><a href="#三、汇编语言" class="headerlink" title="三、汇编语言"></a>三、汇编语言</h2><p>汇编语言是为了方便人类操作指令集，所以汇编语言是和指令集配套</p><p>汇编语言通过汇编器转为二进制</p><p><br></p><h2 id="四、操作系统"><a href="#四、操作系统" class="headerlink" title="四、操作系统"></a>四、操作系统</h2><p>四、操作系统</p><p>指令集是二进制，操作系统其实是应用程序，普通应用程序和操作系统都需要经过编译器，编译为二进</p><p>不同CPU对应的指令集不一样，对应的编译器也不一样，所以相同高级语言用不同编译器编译得到的二进制代码是不同的</p><p>windows 只能在x86架构的CPU上运行，因为Windows系统设计的时候是基于x86架构</p><p>Linux 可以运行在不同架构的CPU，因为Linux 的不同版本可以支持不同架构的指令集</p><p>（我的理解：编译器最后编译生成的二进制就是各条指令集）</p><p><br></p><h2 id="五、汇编器和编译器的区别"><a href="#五、汇编器和编译器的区别" class="headerlink" title="五、汇编器和编译器的区别"></a>五、汇编器和编译器的区别</h2><p>汇编器，用来编译汇编语言的</p><p>编译器的作用是，将源文件，这是已经是二进制代码了。，最后由连接器（Linker），将目标代码连接起来，这样就形成了可执行文件</p><p><br></p><h2 id="六、CPU性能指标"><a href="#六、CPU性能指标" class="headerlink" title="六、CPU性能指标"></a>六、CPU性能指标</h2><h3 id="1-字长"><a href="#1-字长" class="headerlink" title="1.字长"></a>1.字长</h3><p>单位时间内CPU能处理的二进制数据的位数，32位、64位</p><h3 id="2-主频"><a href="#2-主频" class="headerlink" title="2.主频"></a>2.主频</h3><p>CPU内的动作都是按<strong>时钟周期</strong>计算，一秒内有几个时钟周期，主频就是多少赫兹</p><h3 id="3-外频"><a href="#3-外频" class="headerlink" title="3.外频"></a>3.外频</h3><p>外频是由主板为CPU提供的基准时钟频率，就是主板规定CPU<strong>1秒内对外进行数据交换的次数</strong></p><p>PS：关于处理器性能好坏，我之前的理解就是 i7 总比 i5 要好吧，后来发现并不是如此，功耗不同用于平台不同，还是要看天梯图</p><p><br></p><h2 id="七、核心数、线程数"><a href="#七、核心数、线程数" class="headerlink" title="七、核心数、线程数"></a>七、核心数、线程数</h2><p>核心数：指硬件上存在着几个核心个数。比如，双核就是包括2个相对独立的CPU核心单元组，四核就包含4个相对独立的CPU核心单元组。</p><p>线程数：线程数概念仅仅只针对Intel的CPU才有用，因为它是通过Intel<strong>超线程</strong>技术来实现的，就是可以<strong>模拟出的CPU核心数</strong>，一个核心可以对应两个线程，即可以同时运行两个线程</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;指令集和处理器架构：&lt;a href=&quot;https://www.zhihu.com/question/23474438&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/23474438&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（我的理解：处理器架构是指硬件设计，对应相应指令集，即二进制机器码，实现某种功能，两者是配套的）&lt;/p&gt;
    
    </summary>
    
    
      <category term="硬件" scheme="http://yoursite.com/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>远程登陆</title>
    <link href="http://yoursite.com/2018/10/17/%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86/"/>
    <id>http://yoursite.com/2018/10/17/远程登陆/</id>
    <published>2018-10-17T12:57:24.000Z</published>
    <updated>2018-10-17T13:00:11.323Z</updated>
    
    <content type="html"><![CDATA[<ul><li>局域网远程控制：<a href="https://jingyan.baidu.com/article/84b4f565d448f760f6da32e2.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/84b4f565d448f760f6da32e2.html</a></li></ul><ul><li>SSH 远程登陆：<a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a></li></ul><p>（可以不在同一个局域网）</p><p>PS：最近实在忙，没时间研究，只能用到什么，先记录下来</p><a id="more"></a><p><br></p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>SSH是一种网络协议，用于计算机之间的加密登录，采用了公钥加密</p><p>GitHub 就是用SSH</p><p><br></p><h3 id="1-公开密钥加密"><a href="#1-公开密钥加密" class="headerlink" title="1. 公开密钥加密"></a>1. 公开密钥加密</h3><p>公开密钥加密也称为非对称加密，需要两个密钥，一个是公开密钥，另一个是私有密。其中一个密钥把明文加密后所得的密文，只能用相对应的另一个密钥才能解密得到原本的明文，由于加密和解密需要两个不同的密钥，故称为<strong>非对称加密</strong>。</p><p>原理：</p><p>（1）远程主机收到用户的登录请求，把自己的<strong>公钥</strong>发给用户</p><p>（2）用户使用这个公钥，将<strong>登录密码</strong>加密后，发送回来</p><p>（3）远程主机用自己的<strong>私钥</strong>，解密登录密码，如果密码正确，就同意用户登录</p><p><br></p><h3 id="2-中间人攻击"><a href="#2-中间人攻击" class="headerlink" title="2. 中间人攻击"></a>2. 中间人攻击</h3><p>如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。</p><p>如果攻击者插在用户与远程主机之间（比如在公共的wifi区域），用伪造的公钥，获取用户的登录密码，再用这个密码登录远程主机。</p><p><br></p><h3 id="3-公钥登陆"><a href="#3-公钥登陆" class="headerlink" title="3. 公钥登陆"></a>3. 公钥登陆</h3><p>使用密码登录，非常麻烦，SSH 还提供了公钥登录，省去输入密码的步骤</p><p>原理：</p><p>用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;局域网远程控制：&lt;a href=&quot;https://jingyan.baidu.com/article/84b4f565d448f760f6da32e2.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://jingyan.baidu.com/article/84b4f565d448f760f6da32e2.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;SSH 远程登陆：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（可以不在同一个局域网）&lt;/p&gt;
&lt;p&gt;PS：最近实在忙，没时间研究，只能用到什么，先记录下来&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文本文件和二进制文件</title>
    <link href="http://yoursite.com/2018/09/20/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/09/20/文本文件和二进制文件/</id>
    <published>2018-09-20T08:02:13.000Z</published>
    <updated>2018-09-20T08:03:39.520Z</updated>
    
    <content type="html"><![CDATA[<p>二进制文件和文本文件的区别 ：<a href="https://www.jianshu.com/p/af0b4f8b030e" target="_blank" rel="noopener">https://www.jianshu.com/p/af0b4f8b030e</a></p><a id="more"></a><p><br></p><h4 id="（1）文本文件"><a href="#（1）文本文件" class="headerlink" title="（1）文本文件"></a>（1）文本文件</h4><ul><li><p>基于字符编码的文件，常见的编码有 ASCII 编码，UNICODE 编码</p></li><li><p><strong>只能存储 char 型字符变量</strong></p></li><li><p>数据通常是固定长度，以ASCII为例，每个字符都是1个字节</p></li><li><p>文本文件编辑器就可以读写</p></li><li><p>进行编辑的最小单位是字节(byte)</p></li><li><p>纯文本文件没有控制格式的信息，实际上也是一种<strong>特殊的二进制文件</strong></p><p><br></p></li></ul><h4 id="（2）二进制文件"><a href="#（2）二进制文件" class="headerlink" title="（2）二进制文件"></a>（2）二进制文件</h4><ul><li>基于值编码的文件</li><li><strong>可以存储 char/int/short/long/float/……各种变量值</strong></li><li>不同变量占据长度不同，short占两个字节，int占四个字节，float占8个字节……</li><li>二进制文件<strong>需要特别的解码器</strong>，比如bmp文件需要图像查看器，rmvb需要播放器</li><li>进行编辑的最小单位则是位(bit)（但，不会直接通过手工的方式对二进制文件进行编辑）</li><li>二进制文件，都往往有一个头 head，提供文件信息和解释方式</li></ul><p><strong>记事本</strong>只能够识别字符类型，支持文本文件而不支持二进制文件。如果用记事本打开文本文件一切正常，如果打开的是二进制文件就会出现乱码，但也有不乱码的地方，那些地方都是<strong>字符编码</strong>的，而对于int、double 等类型所对应的值都是乱码的。</p><p>PS：字符编码有 ASCII、Unicode、GBK 和 UTF-8 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二进制文件和文本文件的区别 ：&lt;a href=&quot;https://www.jianshu.com/p/af0b4f8b030e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/af0b4f8b030e&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CUDA和OpenCL</title>
    <link href="http://yoursite.com/2018/09/17/CUDA%E5%92%8COpenCL/"/>
    <id>http://yoursite.com/2018/09/17/CUDA和OpenCL/</id>
    <published>2018-09-17T07:24:35.000Z</published>
    <updated>2018-09-17T07:26:39.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要-OpenCL-和-CUDA？"><a href="#为什么需要-OpenCL-和-CUDA？" class="headerlink" title="为什么需要 OpenCL 和 CUDA？"></a>为什么需要 OpenCL 和 CUDA？</h2><p>当不使用异构系统架构，数据在 CPU和GPU之间的流动，会造成很大的开销。</p><p>由于CPU和GPU拥有独立的地址空间，当控制数据在CPU和GPU之间流动时， CPU代码通过系统调用向GPU发送任务，此类系统调用一般由GPU驱动程序管理，这么多的环节造成了很大的调用开销。</p><a id="more"></a><p><br></p><h2 id="OpenCL-和-CUDA"><a href="#OpenCL-和-CUDA" class="headerlink" title="OpenCL 和 CUDA"></a>OpenCL 和 CUDA</h2><h3 id="1-流程"><a href="#1-流程" class="headerlink" title="1. 流程"></a>1. 流程</h3><p>CUDA 和 OpenCL 的开发模型基本一致，都是由 Host 和 Device 组成</p><ul><li>Host：CPU 和Host存储空间，串行代码</li><li>Device: GPU 和Device存储空间，并行代码</li></ul><p>对于异构系统，程序首先执行 Host 程序，然后由 Host 程序激活 Device 程序执行kernel，<strong>kernel 程序是指 Device 设备上执行的代码</strong>，它是直接在设备上执行，受具体设备的限制。</p><p><br></p><h3 id="2-从程序理解流程"><a href="#2-从程序理解流程" class="headerlink" title="2. 从程序理解流程"></a>2. 从程序理解流程</h3><p>PS：只是非常简单的对数据的理解</p><ul><li>从 CPU 拷贝数据到 GPU</li><li>调用 kernel 来操作存储在 GPU 的数据</li><li>将操作结果从 GPU 拷贝至 CPU</li></ul><p><br></p><h3 id="3-OpenCL-和-CUDA-的区别"><a href="#3-OpenCL-和-CUDA-的区别" class="headerlink" title="3. OpenCL 和 CUDA 的区别"></a>3. OpenCL 和 CUDA 的区别</h3><ul><li>OpenCL 是一个开源的标准，通用性好</li><li>CUDA 只针对NVIDIA的GPU产品</li></ul><p>CUDA 和 OpenCL 的差别主要表现在调用 Device 的 API 的差异</p><p>cl-CUDA</p><p>在通用Lisp程序中使用NVIDIA CUDA的库</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么需要-OpenCL-和-CUDA？&quot;&gt;&lt;a href=&quot;#为什么需要-OpenCL-和-CUDA？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要 OpenCL 和 CUDA？&quot;&gt;&lt;/a&gt;为什么需要 OpenCL 和 CUDA？&lt;/h2&gt;&lt;p&gt;当不使用异构系统架构，数据在 CPU和GPU之间的流动，会造成很大的开销。&lt;/p&gt;
&lt;p&gt;由于CPU和GPU拥有独立的地址空间，当控制数据在CPU和GPU之间流动时， CPU代码通过系统调用向GPU发送任务，此类系统调用一般由GPU驱动程序管理，这么多的环节造成了很大的调用开销。&lt;/p&gt;
    
    </summary>
    
    
      <category term="硬件" scheme="http://yoursite.com/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
</feed>
