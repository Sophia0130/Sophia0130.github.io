<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>绿小蕤</title>
  <icon>https://www.gravatar.com/avatar/e4d7a8bd1cb84fb3b4123916b4ea2f6b</icon>
  <subtitle>好逸恶劳,贪生怕死</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-21T01:54:05.038Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>绿小蕤</name>
    <email>528036346@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C和C++的I/O库区别</title>
    <link href="http://yoursite.com/2018/09/21/C%E5%92%8CC-%E7%9A%84I-O%E5%BA%93%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/09/21/C和C-的I-O库区别/</id>
    <published>2018-09-21T01:52:46.000Z</published>
    <updated>2018-09-21T01:54:05.038Z</updated>
    
    <content type="html"><![CDATA[<p>PS：下面是我个人对两种I/O库的理解</p><p>C语言的输入输出：需要标准流和输入输出函数共同实现，这是个过程</p><p>C++的输入输出：实例化ios类为对象，这是面向对象</p><p>最近看的两个项目，一个是C，一个是C++，突然发现真的有很多不同</p><a id="more"></a><p><br></p><h1 id="C语言—标准I-O"><a href="#C语言—标准I-O" class="headerlink" title="C语言—标准I/O"></a>C语言—标准I/O</h1><p>C语言的I/O相关函数封装在头文件 \&lt;stdio.h></p><p><br></p><h3 id="1-三个标准流"><a href="#1-三个标准流" class="headerlink" title="1. 三个标准流"></a>1. 三个标准流</h3><p>PS：我对流的理解，是数据源源不断的流动，标准应该是指某种规则</p><ul><li><p>标准输入流 stdin：从键盘输入 </p></li><li><p>标准输出流 stdout：默认是输出到屏幕 </p><p>stdout 是行缓冲的，输出会放在一个buffer里面，<strong>只有到换行的时候，才会输出到屏幕</strong></p></li></ul><ul><li><p>标准错误流 stderr：默认是输出到屏幕</p><p>stderr 是无缓冲的，会直接输出</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"Hello "</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"World!"</span>);</span><br><span class="line">return0;</span><br><span class="line">&#125;  <span class="comment">// 输出结果：World!Hello</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-格式化输入、输出"><a href="#2-格式化输入、输出" class="headerlink" title="2. 格式化输入、输出"></a>2. 格式化输入、输出</h3><h4 id="（1）格式化输入"><a href="#（1）格式化输入" class="headerlink" title="（1）格式化输入"></a>（1）格式化输入</h4><ul><li>scanf：从控制台输入 </li><li>fscanf ：从文件输入 </li><li>sscanf ：从指定字符串输入</li></ul><h4 id="（2）格式化输出"><a href="#（2）格式化输出" class="headerlink" title="（2）格式化输出"></a>（2）格式化输出</h4><ul><li>printf：向屏幕这样的标准输出设备输出</li><li>sprintf：格式化输出到一个字符串</li><li>fprintf：格式化输出到流 stream指定的文件</li></ul><p><br></p><h3 id="3-标准流和格式化输入输出函数的关系"><a href="#3-标准流和格式化输入输出函数的关系" class="headerlink" title="3. 标准流和格式化输入输出函数的关系"></a>3. 标准流和格式化输入输出函数的关系</h3><p>PS：段小洋说不能单独讲流或输入输出，应该就是输入输出流，两者是绑定的，但是我就是想把它分开来，这样好理解嘛 ~</p><p><strong>C语言把所有的设备（比如显示器、键鼠、U盘等）都当做文件</strong>，把所有的东西都当作文件来处理</p><p>程序与文件交互时，会默认创建 stdin、stdout、stderr 三个文件</p><p>比如，stdin先接收键盘的数据，然后通过输入函数将数据输入到程序里</p><p><br></p><h1 id="C-—标准I-O"><a href="#C-—标准I-O" class="headerlink" title="C++—标准I/O"></a>C++—标准I/O</h1><p><a href="https://www.cnblogs.com/xumengpiaoyun/archive/2013/04/21/3034195.html" target="_blank" rel="noopener">https://www.cnblogs.com/xumengpiaoyun/archive/2013/04/21/3034195.html</a></p><p><br></p><ul><li>标准I/O：对系统指定的<strong>标准设备</strong>的输入和输出（键盘输入数据，输出到显示屏幕）</li><li>文件I/O：<strong>外存磁盘文件</strong>为对象进行输入和输出（从磁盘文件输入数据，数据输出到磁盘文件）</li><li>字符串I/O：对内存中指定的空间进行输入和输出</li></ul><p><br></p><h3 id="1-I-O类库中的常用流类"><a href="#1-I-O类库中的常用流类" class="headerlink" title="1. I/O类库中的常用流类"></a>1. I/O类库中的常用流类</h3><p><img src="https://images0.cnblogs.com/blog/476361/201304/21180804-68564fc8ad1b4472b8ba6012d51c6db3.jpg" alt="img"></p><p><br></p><h3 id="2-头文件"><a href="#2-头文件" class="headerlink" title="2.头文件"></a>2.头文件</h3><p>iostream类库的即可分别由不同的头文件来实现，命名空间为 std</p><ul><li>iostream：标准I/O，对系统指定的标准设备的输入和输出（比如键盘输入数据，输出到显示屏幕）</li><li>fstream：文件I/O，以磁盘文件为对象的输入和输出（从磁盘文件输入数据，数据输出到磁盘文件）</li><li>strstream：字符串I/O，对内存中指定的空间的输入和输出</li></ul><p><br></p><p>PS：标准输入输出流、格式化输入输出都是对流类实例化为对象</p><h3 id="3-标准输入流"><a href="#3-标准输入流" class="headerlink" title="3. 标准输入流"></a>3. 标准输入流</h3><ul><li>cin流对象：从输入流提取数据，遇到空格或者回车就终止。</li><li>cin.get()</li></ul><ul><li><p>cin.getline()</p><p><br></p></li></ul><h3 id="4-标准输出流"><a href="#4-标准输出流" class="headerlink" title="4. 标准输出流"></a>4. 标准输出流</h3><ul><li>cout 流对象：可以传送到显示器输出，也可以<strong>重定向到磁盘文件</strong></li><li>cerr 流对象：只能在显示器输出，<strong>不经过缓冲区</strong></li><li>clog 流对象：在显示器显示错误信息，<strong>缓冲区满</strong> 后或者遇 <strong>endl</strong> 时向显示器输出</li></ul><p><br></p><h3 id="5-格式化输入输出"><a href="#5-格式化输入输出" class="headerlink" title="5. 格式化输入输出"></a>5. 格式化输入输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//控制格式化, 输出</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default bool values : "</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span></span><br><span class="line">&lt;&lt; <span class="string">"\nalpha bool values : "</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span></span><br><span class="line">&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"no reset bool : "</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//没有重置</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::noboolalpha &lt;&lt; <span class="string">"reset bool : "</span> &lt;&lt; <span class="literal">true</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="literal">false</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//重置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//整数的基, 显示, 大写</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::showbase;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"default : "</span> &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="number">1024</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//默认</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"octal : "</span> &lt;&lt; oct &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="number">1024</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//8进制</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::uppercase &lt;&lt; <span class="string">"hex : "</span> &lt;&lt; hex &lt;&lt; <span class="number">20</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="number">1024</span></span><br><span class="line">&lt;&lt; <span class="built_in">std</span>::nouppercase &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//16进制</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"decimal : "</span>  &lt;&lt; dec&lt;&lt; <span class="number">20</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="number">1024</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//10进制</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::noshowbase;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：下面是我个人对两种I/O库的理解&lt;/p&gt;
&lt;p&gt;C语言的输入输出：需要标准流和输入输出函数共同实现，这是个过程&lt;/p&gt;
&lt;p&gt;C++的输入输出：实例化ios类为对象，这是面向对象&lt;/p&gt;
&lt;p&gt;最近看的两个项目，一个是C，一个是C++，突然发现真的有很多不同&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>文本文件和二进制文件</title>
    <link href="http://yoursite.com/2018/09/20/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/09/20/文本文件和二进制文件/</id>
    <published>2018-09-20T08:02:13.000Z</published>
    <updated>2018-09-20T08:03:39.520Z</updated>
    
    <content type="html"><![CDATA[<p>二进制文件和文本文件的区别 ：<a href="https://www.jianshu.com/p/af0b4f8b030e" target="_blank" rel="noopener">https://www.jianshu.com/p/af0b4f8b030e</a></p><a id="more"></a><p><br></p><h4 id="（1）文本文件"><a href="#（1）文本文件" class="headerlink" title="（1）文本文件"></a>（1）文本文件</h4><ul><li><p>基于字符编码的文件，常见的编码有 ASCII 编码，UNICODE 编码</p></li><li><p><strong>只能存储 char 型字符变量</strong></p></li><li><p>数据通常是固定长度，以ASCII为例，每个字符都是1个字节</p></li><li><p>文本文件编辑器就可以读写</p></li><li><p>进行编辑的最小单位是字节(byte)</p></li><li><p>纯文本文件没有控制格式的信息，实际上也是一种<strong>特殊的二进制文件</strong></p><p><br></p></li></ul><h4 id="（2）二进制文件"><a href="#（2）二进制文件" class="headerlink" title="（2）二进制文件"></a>（2）二进制文件</h4><ul><li>基于值编码的文件</li><li><strong>可以存储 char/int/short/long/float/……各种变量值</strong></li><li>不同变量占据长度不同，short占两个字节，int占四个字节，float占8个字节……</li><li>二进制文件<strong>需要特别的解码器</strong>，比如bmp文件需要图像查看器，rmvb需要播放器</li><li>进行编辑的最小单位则是位(bit)（但，不会直接通过手工的方式对二进制文件进行编辑）</li><li>二进制文件，都往往有一个头 head，提供文件信息和解释方式</li></ul><p><strong>记事本</strong>只能够识别字符类型，支持文本文件而不支持二进制文件。如果用记事本打开文本文件一切正常，如果打开的是二进制文件就会出现乱码，但也有不乱码的地方，那些地方都是<strong>字符编码</strong>的，而对于int、double 等类型所对应的值都是乱码的。</p><p>PS：字符编码有 ASCII、Unicode、GBK 和 UTF-8 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二进制文件和文本文件的区别 ：&lt;a href=&quot;https://www.jianshu.com/p/af0b4f8b030e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/af0b4f8b030e&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>内存对齐</title>
    <link href="http://yoursite.com/2018/09/19/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <id>http://yoursite.com/2018/09/19/内存对齐/</id>
    <published>2018-09-19T04:06:12.000Z</published>
    <updated>2018-09-19T04:06:57.721Z</updated>
    
    <content type="html"><![CDATA[<p>PS：这篇博客写得很详细，下面的学习笔记都是参考其完成</p><p> <a href="https://blog.csdn.net/markl22222/article/details/38051483" target="_blank" rel="noopener">https://blog.csdn.net/markl22222/article/details/38051483</a></p><a id="more"></a><h2 id="一、内存对齐-Data-structure-alignment"><a href="#一、内存对齐-Data-structure-alignment" class="headerlink" title="一、内存对齐 Data structure alignment"></a>一、内存对齐 Data structure alignment</h2><p>PS：WiKi 的定义很清楚，内存对齐就是数据在电脑中的存储方式</p><p>Data structure alignment refers to the way <strong>data is arranged and accessed in computer memory</strong>. </p><p>It consists of three separate but related issues:</p><ul><li>data alignment</li><li>data structure padding</li><li>packing</li></ul><p><br></p><h3 id="1-内存对齐（Data-structure-alignment）"><a href="#1-内存对齐（Data-structure-alignment）" class="headerlink" title="1. 内存对齐（Data structure alignment）"></a>1. 内存对齐（Data structure alignment）</h3><p>是一个数据类型所存放的<strong>内存地址的属性</strong>，这个属性是一个无符号整数，并且这个整数必须是2的N次方 1、2、4、8、……</p><p>比如，<strong>一个数据类型的内存对齐为8，是指这个数据类型定义出来的所有变量，其内存地址都是8的倍数</strong></p><h3 id="2-自然对齐（naturally-aligned）"><a href="#2-自然对齐（naturally-aligned）" class="headerlink" title="2. 自然对齐（naturally aligned）"></a>2. 自然对齐（naturally aligned）</h3><p>基本数据类型的对齐属性，和这个数据类型的大小相等时，这种对齐方式称作自然对齐</p><p>比如，一个4字节大小的int型数据，默认情况下它的内存对齐也是4</p><p><br></p><h2 id="二、为什么要用内存对齐？"><a href="#二、为什么要用内存对齐？" class="headerlink" title="二、为什么要用内存对齐？"></a>二、为什么要用内存对齐？</h2><p><strong>考虑到CPU处理内存的方式</strong></p><p>32位的x86 CPU，一个时钟周期可以读取4个连续的内存单元，即4字节，使用字节对齐将会提高系统的性能，也就是CPU读取内存数据的效率。</p><p>比如，一个int放在奇数内存位置上，将4个字节读出，32位CPU就需要两次，但对齐之后一次就可以。</p><p><br></p><h2 id="三、数据填充-Data-Structure-Padding"><a href="#三、数据填充-Data-Structure-Padding" class="headerlink" title="三、数据填充 Data Structure Padding"></a>三、数据填充 Data Structure Padding</h2><p>内存对齐可能会让数据在内存里的存放不是紧挨着的，而是可能会出现一些空隙</p><p>举个例子：</p><p>1.定义一个结构体，如果直接相加占用内存是16，sizeof 的结果其实更大，这是因为，为了保证这个结构体里的每个成员都应该在它对齐的内存位置上，而在某些位置插入了Padding</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;         <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="keyword">int</span> b;          <span class="comment">// 4 bytes</span></span><br><span class="line">    <span class="keyword">short</span> c;        <span class="comment">// 2 bytes</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> d;    <span class="comment">// 8 bytes</span></span><br><span class="line">    <span class="keyword">char</span> e;         <span class="comment">// 1 byte</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2.填充后的结果</p><p>当然，<strong>不同平台下会使用不同的默认对齐值</strong>，下面这个只是一种方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;         <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="keyword">char</span> pad_0[<span class="number">3</span>];  <span class="comment">// Padding 3</span></span><br><span class="line">    <span class="keyword">int</span> b;          <span class="comment">// 4 bytes</span></span><br><span class="line">    <span class="keyword">short</span> c;        <span class="comment">// 2 bytes</span></span><br><span class="line">    <span class="keyword">char</span> pad_1[<span class="number">6</span>];  <span class="comment">// Padding 6</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> d;    <span class="comment">// 8 bytes</span></span><br><span class="line">    <span class="keyword">char</span> e;         <span class="comment">// 1 byte</span></span><br><span class="line">    <span class="keyword">char</span> pad_2[<span class="number">7</span>];  <span class="comment">// Padding 7</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3.结构体类型本身的内存对齐</p><p>为了保证结构体内的每个成员都能够放在它自然对齐的位置上，对这个结构体本身来说最理想的内存对齐数值应该是结构体里内存对齐数值最大的成员的内存对齐数</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：这篇博客写得很详细，下面的学习笔记都是参考其完成&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://blog.csdn.net/markl22222/article/details/38051483&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/markl22222/article/details/38051483&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CUDA和OpenCL</title>
    <link href="http://yoursite.com/2018/09/17/CUDA%E5%92%8COpenCL/"/>
    <id>http://yoursite.com/2018/09/17/CUDA和OpenCL/</id>
    <published>2018-09-17T07:24:35.000Z</published>
    <updated>2018-09-17T07:26:39.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要-OpenCL-和-CUDA？"><a href="#为什么需要-OpenCL-和-CUDA？" class="headerlink" title="为什么需要 OpenCL 和 CUDA？"></a>为什么需要 OpenCL 和 CUDA？</h2><p>当不使用异构系统架构，数据在 CPU和GPU之间的流动，会造成很大的开销。</p><p>由于CPU和GPU拥有独立的地址空间，当控制数据在CPU和GPU之间流动时， CPU代码通过系统调用向GPU发送任务，此类系统调用一般由GPU驱动程序管理，这么多的环节造成了很大的调用开销。</p><a id="more"></a><p><br></p><h2 id="OpenCL-和-CUDA"><a href="#OpenCL-和-CUDA" class="headerlink" title="OpenCL 和 CUDA"></a>OpenCL 和 CUDA</h2><h3 id="1-流程"><a href="#1-流程" class="headerlink" title="1. 流程"></a>1. 流程</h3><p>CUDA 和 OpenCL 的开发模型基本一致，都是由 Host 和 Device 组成</p><ul><li>Host：CPU 和Host存储空间，串行代码</li><li>Device: GPU 和Device存储空间，并行代码</li></ul><p>对于异构系统，程序首先执行 Host 程序，然后由 Host 程序激活 Device 程序执行kernel，<strong>kernel 程序是指 Device 设备上执行的代码</strong>，它是直接在设备上执行，受具体设备的限制。</p><p><br></p><h3 id="2-从程序理解流程"><a href="#2-从程序理解流程" class="headerlink" title="2. 从程序理解流程"></a>2. 从程序理解流程</h3><p>PS：只是非常简单的对数据的理解</p><ul><li>从 CPU 拷贝数据到 GPU</li><li>调用 kernel 来操作存储在 GPU 的数据</li><li>将操作结果从 GPU 拷贝至 CPU</li></ul><p><br></p><h3 id="3-OpenCL-和-CUDA-的区别"><a href="#3-OpenCL-和-CUDA-的区别" class="headerlink" title="3. OpenCL 和 CUDA 的区别"></a>3. OpenCL 和 CUDA 的区别</h3><ul><li>OpenCL 是一个开源的标准，通用性好</li><li>CUDA 只针对NVIDIA的GPU产品</li></ul><p>CUDA 和 OpenCL 的差别主要表现在调用 Device 的 API 的差异</p><p>cl-CUDA</p><p>在通用Lisp程序中使用NVIDIA CUDA的库</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么需要-OpenCL-和-CUDA？&quot;&gt;&lt;a href=&quot;#为什么需要-OpenCL-和-CUDA？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要 OpenCL 和 CUDA？&quot;&gt;&lt;/a&gt;为什么需要 OpenCL 和 CUDA？&lt;/h2&gt;&lt;p&gt;当不使用异构系统架构，数据在 CPU和GPU之间的流动，会造成很大的开销。&lt;/p&gt;
&lt;p&gt;由于CPU和GPU拥有独立的地址空间，当控制数据在CPU和GPU之间流动时， CPU代码通过系统调用向GPU发送任务，此类系统调用一般由GPU驱动程序管理，这么多的环节造成了很大的调用开销。&lt;/p&gt;
    
    </summary>
    
    
      <category term="硬件" scheme="http://yoursite.com/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>caffe框架</title>
    <link href="http://yoursite.com/2018/09/16/caffe%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2018/09/16/caffe框架/</id>
    <published>2018-09-16T01:03:36.000Z</published>
    <updated>2018-09-16T01:05:40.019Z</updated>
    
    <content type="html"><![CDATA[<p>PS：我是没有打算使用 caffe，所以这篇博文不适合当作入门教材</p><p>但是tiny dnn的一个模块里面提供了caffe训练网络的接口，顺便就学习了一下，还是很有收获的</p><a id="more"></a><p><br></p><h2 id="一、caffe主要结构"><a href="#一、caffe主要结构" class="headerlink" title="一、caffe主要结构"></a>一、caffe主要结构</h2><p>这部分是完全参考了这篇博文：</p><p><a href="http://noahsnail.com/2016/12/05/2016-12-5-Caffe%E7%9A%84%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">http://noahsnail.com/2016/12/05/2016-12-5-Caffe%E7%9A%84%E6%A1%86%E6%9E%B6/</a></p><p>caffe代码本身非常模块化，主要由4部分组成Blob，Layer，Net 和 Solver</p><ul><li>Blob</li></ul><p>Blob主要用来表示网络中的数据，包括训练数据，网络各层自身的参数，网络之间传递的数据都是通过Blob来实现的，同时Blob数据也支持在CPU与GPU上存储，能够在两者之间做同步。</p><ul><li>Layer</li></ul><p>Layer是对神经网络中各种层的一个抽象，包括卷积层和下采样层，还有全连接层和各种激活函数层等等。同时每种Layer都实现了前向传播和反向传播，并通过Blob来传递数据。</p><ul><li>Net</li></ul><p>Net是对整个神经网络的表示，由各种Layer前后连接组合而成，也是要构建的网络模型。</p><ul><li>Solver</li></ul><p>Solver定义了针对Net网络模型的求解方法，记录神经网络的训练过程，保存神经网络模型参数，中断并恢复网络的训练过程。通过配置文件自定义Solver，能够实现不同的神经网络求解方式。</p><p><br></p><h2 id="二、caffe采用读入配置文件的方式进行训练"><a href="#二、caffe采用读入配置文件的方式进行训练" class="headerlink" title="二、caffe采用读入配置文件的方式进行训练"></a>二、caffe采用读入配置文件的方式进行训练</h2><ul><li><p>caffe.proto文件编写</p></li><li><p>编译生成caffe.pb.cc与caffe.pb.h文件</p></li><li><p>编写网络结构与模型训练的配置文件</p><ul><li><p><strong>slover.prototxt</strong>：</p><p>描述网络训练时的各种参数文件，如训练的策略，学习率的变化率，模型保存的频率等</p></li><li><p><strong>net.prototxt：</strong></p><p>描述网络的网络结构</p></li></ul></li></ul><ul><li>训练结果输出到 caffemodel</li></ul><p><br></p><p><strong>其中关于caffe.proto文件的作用：</strong></p><ul><li>定义的结构化数据，用于构建Caffe网络，即<strong>.prototxt文件中的每个字段名要在caffe.proto中存在</strong></li><li>负责.caffemodel数据文件的存储和读取</li><li>每次向Caffe中增加新的层，相应的caffe.proto文件也需调整</li><li>注意选择Protobuf的版本要与Caffe中的一致</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：我是没有打算使用 caffe，所以这篇博文不适合当作入门教材&lt;/p&gt;
&lt;p&gt;但是tiny dnn的一个模块里面提供了caffe训练网络的接口，顺便就学习了一下，还是很有收获的&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="caffe" scheme="http://yoursite.com/tags/caffe/"/>
    
  </entry>
  
  <entry>
    <title>Google Protocol Buffers</title>
    <link href="http://yoursite.com/2018/09/15/Google-Protocol-Buffers/"/>
    <id>http://yoursite.com/2018/09/15/Google-Protocol-Buffers/</id>
    <published>2018-09-15T09:12:19.000Z</published>
    <updated>2018-09-15T09:20:00.715Z</updated>
    
    <content type="html"><![CDATA[<p>PS：在使用其它深度学习框架时遇到 caffe.proto，不理解这个文件是干嘛的，只好去看了一下 Google Protocol Buffers</p><p>这篇文章用了非常简单的例子，说明如何使用Google Protocol Buffers：</p><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html</a></p><a id="more"></a><p><br></p><h2 id="Google-Protocol-Buffers（Protobuf）"><a href="#Google-Protocol-Buffers（Protobuf）" class="headerlink" title="Google Protocol Buffers（Protobuf）"></a>Google Protocol Buffers（Protobuf）</h2><p>Google Protocol Buffers（Protobuf）：一种结构化数据存储格式</p><p>PS：我的理解用 Protobuf 编译器将 proto 编译成对应的语言后，就可以对结构化数据写入读出</p><p><strong>适合不同语言之间的数据交换</strong>，即只要将相同协议格式的proto文件被编译成不同的语言版本，加入到各自的工程中，这样不同语言就可以通过protobuf序列化的数据解析其他语言</p><p><br></p><h3 id="1-编写-proto-文件"><a href="#1-编写-proto-文件" class="headerlink" title="1. 编写 .proto 文件"></a>1. 编写 .proto 文件</h3><p>编写一个 proto 文件，定义程序中需要处理的结构化数据（被称为 Message）</p><p>proto文件的结构：<a href="https://www.jianshu.com/p/5ea08c6b7031" target="_blank" rel="noopener">https://www.jianshu.com/p/5ea08c6b7031</a></p><table><thead><tr><th>名称</th><th style="text-align:left">定义</th></tr></thead><tbody><tr><td>message</td><td style="text-align:left">是消息定义的关键字</td></tr><tr><td>required</td><td style="text-align:left">这个字段必须的，必须在序列化的时候被赋值</td></tr><tr><td>optional</td><td style="text-align:left">代表这个字段是可选的，可以为0个或1个但不能大于1个</td></tr><tr><td>repeated</td><td style="text-align:left">代表此字段可以被重复任意多次包括0次</td></tr><tr><td>int32和string</td><td style="text-align:left">字段的类型</td></tr></tbody></table><p><br></p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 命名规则：packageName.MessageName.proto</span><br><span class="line"></span><br><span class="line">package lm; </span><br><span class="line">message helloworld </span><br><span class="line">&#123; </span><br><span class="line">   required int32     id = 1;  // ID </span><br><span class="line">   required string    str = 2;  // str </span><br><span class="line">   optional int32     opt = 3;  //optional field </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-编译-proto-文件"><a href="#2-编译-proto-文件" class="headerlink" title="2. 编译 .proto 文件"></a>2. 编译 .proto 文件</h3><p>用 Protobuf 编译器将 proto 编译成对应的目标语言（C++为例），生成一下两个文件</p><ul><li><p>packageName.MessageName.pb.h 头文件：类的定义，类名为 packageName::MessageName</p></li><li><p>packageName.MessageName.pb.cc文件：类的实现</p><ul><li>类的实现提供了一系列的函数用来修改和读取结构化数据中的数据成员</li></ul></li></ul><ul><li>类的实现提供相应的方法来把一个复杂的数据变成一个字节序列，可以将这个字节序列写入磁盘</li></ul><p><br></p><p>例子：</p><p>若目标语言是 C++，则lm.helloworld. .proto 文件，经过编译生成了对应了一个 C++ 的 helloworld 类</p><p>lm.helloworld.pb.h ：  C++ 类的定义头文件</p><p>lm.helloworld.pb.cc ： C++ 类的实现文件</p><p><br></p><h3 id="3-编写-writer-和-Reader具体实现结构化数据的写入读出"><a href="#3-编写-writer-和-Reader具体实现结构化数据的写入读出" class="headerlink" title="3. 编写 writer 和 Reader具体实现结构化数据的写入读出"></a>3. 编写 writer 和 Reader具体实现结构化数据的写入读出</h3><p>Writer 、Reader 文件中 include 编译后的头文件 lm.helloworld.pb.h 就可以使用 lm::helloworld类</p><ul><li><strong>Writer ：把一个结构化数据写入磁盘，以便其他人来读取</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lm.helloworld.pb.h"</span> <span class="comment">// lm::helloworld 类定义在 lm.helloworld.pb.h 头文件中</span></span></span><br><span class="line">…</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"> </span>&#123; </span><br><span class="line">  lm::helloworld msg1;    <span class="comment">//类的实现</span></span><br><span class="line">  msg1.set_id(<span class="number">101</span>);        </span><br><span class="line">  msg1.set_str(“hello”); </span><br><span class="line">     </span><br><span class="line">  <span class="comment">// Write the new address book back to disk. </span></span><br><span class="line">  <span class="function">fstream <span class="title">output</span><span class="params">(<span class="string">"./log"</span>, ios::out | ios::trunc | ios::binary)</span></span>;  <span class="comment">//对象序列化写入</span></span><br><span class="line">         </span><br><span class="line">  <span class="keyword">if</span> (!msg1.SerializeToOstream(&amp;output)) &#123; </span><br><span class="line">      <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to write msg."</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">  &#125;         </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><br></p><ul><li><strong>Reader：把写入磁盘的结构化数据读出</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"lm.helloworld.pb.h"</span> </span></span><br><span class="line">…</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">ListMsg</span><span class="params">(<span class="keyword">const</span> lm::helloworld &amp; msg)</span> </span>&#123; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; msg.id() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; msg.str() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"> &#125; </span><br><span class="line">  </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line">  lm::helloworld msg1; </span><br><span class="line">  </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="function">fstream <span class="title">input</span><span class="params">(<span class="string">"./log"</span>, ios::in | ios::binary)</span></span>; </span><br><span class="line">    <span class="keyword">if</span> (!msg1.ParseFromIstream(&amp;input)) &#123; </span><br><span class="line">      <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Failed to parse address book."</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  ListMsg(msg1); </span><br><span class="line">  … </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：在使用其它深度学习框架时遇到 caffe.proto，不理解这个文件是干嘛的，只好去看了一下 Google Protocol Buffers&lt;/p&gt;
&lt;p&gt;这篇文章用了非常简单的例子，说明如何使用Google Protocol Buffers：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux（五）—— .o、.a、.so</title>
    <link href="http://yoursite.com/2018/09/13/Linux%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94-o%E3%80%81-a%E3%80%81-so/"/>
    <id>http://yoursite.com/2018/09/13/Linux（五）——-o、-a、-so/</id>
    <published>2018-09-13T12:58:35.000Z</published>
    <updated>2018-09-13T13:00:27.412Z</updated>
    
    <content type="html"><![CDATA[<p>PS：Linux与windows的对应起来看</p><p><a href="https://blog.csdn.net/chlele0105/article/details/23691147" target="_blank" rel="noopener">https://blog.csdn.net/chlele0105/article/details/23691147</a></p><a id="more"></a><h2 id="windows下obj、lib、dll"><a href="#windows下obj、lib、dll" class="headerlink" title="windows下obj、lib、dll"></a>windows下obj、lib、dll</h2><ol><li><p>lib  是静态链接库的库文件</p></li><li><p>dll  是动态链接库的库文件</p></li><li><p>obj 是中间代码</p><p>因为不可能一次得到目标文件，一个exe需要很多的cpp文件生成，而编译器一次只能编译一个cpp文件，这样编译器编译好一个cpp以后会将其编译成obj，当所有必须要的cpp都编译成obj以后，再统一link成所需要的exe</p></li></ol><p><br></p><h2 id="linux下-o、-a、-so"><a href="#linux下-o、-a、-so" class="headerlink" title="linux下 .o、.a、.so"></a>linux下 .o、.a、.so</h2><ul><li><p>.o      是目标文件，相当于windows中的.obj文件 </p></li><li><p>.a      是静态库，是好多个.o合在一起，用于静态连接 ，相当于windows下的lib</p></li><li><p>.so    是共享库（shared object）用于动态链接，相当于windows下的dll </p><p>相对于静态函数库，共享函数库在编译的时候，并没有被编译进目标代码中</p><p>当程序执行到相关函数时才调用共享函数库里相应的函数</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：Linux与windows的对应起来看&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/chlele0105/article/details/23691147&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/chlele0105/article/details/23691147&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CMake（三）—— Linux下使用CMake</title>
    <link href="http://yoursite.com/2018/09/13/CMake%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-Linux%E4%B8%8B%E4%BD%BF%E7%94%A8CMake/"/>
    <id>http://yoursite.com/2018/09/13/CMake（三）——-Linux下使用CMake/</id>
    <published>2018-09-13T09:16:21.000Z</published>
    <updated>2018-09-13T09:19:01.030Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CMake在Linux下的使用"><a href="#CMake在Linux下的使用" class="headerlink" title="CMake在Linux下的使用"></a>CMake在Linux下的使用</h2><ol><li>工程文件下包含你需要的cpp和CMakeLists.txt</li><li>在工程目录下打开终端</li></ol><ul><li><code>mkdir build</code>        新建一个文件夹放编译的文件（和cpp、CMakeLists.txt分开放）</li><li><code>cd ./build</code>          进入该文件目录</li><li><code>cmake ../</code>            build目录下生成一系列文件</li><li><code>make</code>                     在build目录下生成可执行文件</li><li><code>./可执行文件</code>        执行可执行文件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CMake在Linux下的使用&quot;&gt;&lt;a href=&quot;#CMake在Linux下的使用&quot; class=&quot;headerlink&quot; title=&quot;CMake在Linux下的使用&quot;&gt;&lt;/a&gt;CMake在Linux下的使用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;工程文件下包含你需要的c
      
    
    </summary>
    
    
      <category term="CMake" scheme="http://yoursite.com/tags/CMake/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu（三）—— opencv、cheese安装</title>
    <link href="http://yoursite.com/2018/09/13/ubuntu%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-opencv%E3%80%81cheese%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2018/09/13/ubuntu（三）——-opencv、cheese安装/</id>
    <published>2018-09-13T07:55:56.000Z</published>
    <updated>2018-09-17T06:40:58.386Z</updated>
    
    <content type="html"><![CDATA[<p>PS：那天晚上opencv从九点半开始装到十点半，人都快要崩溃了，结果第二天又重新编译了一遍，感觉自己真的是一个人在黑暗中摸索 ~</p><a id="more"></a><p><br></p><h2 id="一、安装-opencv"><a href="#一、安装-opencv" class="headerlink" title="一、安装 opencv"></a>一、安装 opencv</h2><ol><li><p>ubuntu 安装 opencv 的流程</p><p><a href="https://blog.csdn.net/JohinieLi/article/details/79885820" target="_blank" rel="noopener">https://blog.csdn.net/JohinieLi/article/details/79885820</a></p></li><li><p>测试opencv是否安装成功   </p><p>使用 <code>smaples/cpp/example_cmake</code> 中的样例去测试opencv是否安装成    </p><p>在打开摄像头时，其实程序运行正确，打开了摄像头反而报错了      </p><p> ERROR: V4L/V4L2: VIDIOC_S_CROP                   </p><p><strong>是依赖的库 libv4l-dev 没有装</strong>，所以需要对opencv重新编译      </p></li><li><p>opencv重新编译，解决方法如下：</p><p>opencv 在 ubuntu 中需要的依赖   <a href="https://blog.csdn.net/suochao90/article/details/7530233" target="_blank" rel="noopener">https://blog.csdn.net/suochao90/article/details/7530233</a></p><p>安装完依赖库，对opencv 重新编译  <a href="https://blog.csdn.net/m0_37811342/article/details/802278" target="_blank" rel="noopener">https://blog.csdn.net/m0_37811342/article/details/802278</a></p></li><li><p>但是程序提示 select time out，后来才知道是 wecamera 的驱动没有装</p><p>如果之前没有装webcamera的驱动 ~ 请看第二部分cheese</p></li></ol><p><br></p><h2 id="二、Ubuntu中通过Cheese支持Webcam"><a href="#二、Ubuntu中通过Cheese支持Webcam" class="headerlink" title="二、Ubuntu中通过Cheese支持Webcam"></a>二、Ubuntu中通过Cheese支持Webcam</h2><p>PS：刚开始我不能理解，为什么主机上已经装过摄像头驱动，虚拟机还要装一遍，那是我对驱动是什么没有理解 ~ </p><h3 id="1-驱动"><a href="#1-驱动" class="headerlink" title="1. 驱动"></a>1. 驱动</h3><p>『<strong>驱动程序提供了硬件到操作系统的一个接口。</strong>』（注意：是<strong>操作系统</strong>！！！）</p><p>相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作。</p><p>正因为这个原因，驱动程序在系统中的所占的地位十分重要，一般当操作系统安装完毕后，首要的便是安装硬件设备的驱动程序。</p><p><br></p><h3 id="2-通过Cheese支持Webcam"><a href="#2-通过Cheese支持Webcam" class="headerlink" title="2. 通过Cheese支持Webcam"></a>2. 通过Cheese支持Webcam</h3><p><a href="https://blog.csdn.net/JNingWei/article/details/79945300" target="_blank" rel="noopener">https://blog.csdn.net/JNingWei/article/details/79945300</a></p><p>大多数webcam生产商并不为Linux系统提供驱动，包括Ununtu</p><p>解决方法就是：『<strong>可以通过安装cheese来激活Ubuntu自带的摄像头UVC驱动</strong>』（不过需要保证，摄像头是支持 UVC驱动）</p><p><br></p><h3 id="3-cheese安装"><a href="#3-cheese安装" class="headerlink" title="3. cheese安装"></a>3. cheese安装</h3><p>PS：刚开始以为 cheese 是硬件驱动程序，后来才明白过来，它不过是个拍照录像的应用程序，但是可以通过安装这个应用程序，来激活ubuntu自带的摄像头驱动</p><ol><li><p>安装<br><code>sudo apt-get install cheese</code></p></li><li><p>虚拟机设置里面将USB兼容性改为3.0</p></li><li><p>测试</p><p><code>cheese</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：那天晚上opencv从九点半开始装到十点半，人都快要崩溃了，结果第二天又重新编译了一遍，感觉自己真的是一个人在黑暗中摸索 ~&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="ubuntu" scheme="http://yoursite.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu（二）—— sublime的python环境搭建</title>
    <link href="http://yoursite.com/2018/09/13/ubuntu%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-sublime%E7%9A%84python%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/09/13/ubuntu（二）——-sublime的python环境搭建/</id>
    <published>2018-09-13T07:52:35.000Z</published>
    <updated>2018-09-13T07:55:13.507Z</updated>
    
    <content type="html"><![CDATA[<p>PS：之前一直以为sublime只是文本编辑器，没想到功能如此强大，还有控制，各种东西配置好，就是个IDE了 ~</p><a id="more"></a><h2 id="一、ubuntu-下python版本切换"><a href="#一、ubuntu-下python版本切换" class="headerlink" title="一、ubuntu 下python版本切换"></a>一、ubuntu 下python版本切换</h2><p>ubuntu 本身是自带 python，这样就减少了在windows下的下载和环境变量配置，但是本身是自带两个版本的python，2.X和3.X,两个版本，两个版本默认的是使用2.X</p><ul><li>python    默认版本 2.7.12</li><li>python3  版本是 3.5.2</li></ul><p>ubuntu 下 python 的版本切换：<a href="https://blog.csdn.net/beijiu5854/article/details/77897767" target="_blank" rel="noopener">https://blog.csdn.net/beijiu5854/article/details/77897767</a></p><p><br></p><h2 id="二、Ubantu下-Sublime-Text3-python-环境的搭建"><a href="#二、Ubantu下-Sublime-Text3-python-环境的搭建" class="headerlink" title="二、Ubantu下 Sublime Text3  python 环境的搭建"></a>二、Ubantu下 Sublime Text3  python 环境的搭建</h2><p><a href="https://blog.csdn.net/mao19931004/article/details/51834616" target="_blank" rel="noopener">https://blog.csdn.net/mao19931004/article/details/51834616</a></p><p>一直想实现ubuntu下终端用subl命令打开文件，呵呵呵呵，一个下午差点把sublime玩崩 ~ </p><p>我大概知道应该是路径的问题，一直链接不上，但是不知道怎么改啊~</p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：之前一直以为sublime只是文本编辑器，没想到功能如此强大，还有控制，各种东西配置好，就是个IDE了 ~&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="ubuntu" scheme="http://yoursite.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu（一）—— VM虚拟机上安装ubuntu</title>
    <link href="http://yoursite.com/2018/09/13/ubuntu%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94-VM%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8A%E5%AE%89%E8%A3%85ubuntu/"/>
    <id>http://yoursite.com/2018/09/13/ubuntu（一）——-VM虚拟机上安装ubuntu/</id>
    <published>2018-09-13T07:48:57.000Z</published>
    <updated>2018-09-13T07:49:46.210Z</updated>
    
    <content type="html"><![CDATA[<p>Win10使用VMware虚拟机安装ubuntu</p><p>PS：又被汪大蕾骂了一顿，还是装个虚拟机吧，毕竟做开发还是要靠Linux</p><a id="more"></a><p><br></p><h2 id="一、压缩卷新建磁盘分区"><a href="#一、压缩卷新建磁盘分区" class="headerlink" title="一、压缩卷新建磁盘分区"></a>一、压缩卷新建磁盘分区</h2><p>具体操作：<a href="https://jingyan.baidu.com/article/4f7d5712c415091a21192761.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/4f7d5712c415091a21192761.html</a></p><p>压缩卷：从一个盘里边把没有用到的空间分到未使用的磁盘空间里</p><p>扩展卷：从未使用空间里向现有的盘增加空间</p><p>磁盘格式：不同格式会在磁盘分区容量、单个文件容量、安全方面等存在区别</p><p>格式化：对磁盘或磁盘中的分区（partition）进行初始化的一种操作，这种操作通常会导致现有的磁盘或分区中所有的文件被清除</p><p>windows下磁盘格式主要有FAT16、FAT32、NTFS 等，最新格式为exFAT</p><p><br></p><h2 id="二、虚拟机和双系统"><a href="#二、虚拟机和双系统" class="headerlink" title="二、虚拟机和双系统"></a>二、虚拟机和双系统</h2><p>一直在纠结是装双系统还是虚拟机，但是看帖子说，双系统会不稳定，新手还是建议虚拟机 ~ </p><p>不过运行虚拟机，相当于运行两个系统，比较占用资源，不过拖拽文件会比较方便，双系统就需要切换</p><p><br></p><h3 id="1-虚拟机-（Virtual-Machine）"><a href="#1-虚拟机-（Virtual-Machine）" class="headerlink" title="1.  虚拟机 （Virtual Machine）"></a>1.  虚拟机 （Virtual Machine）</h3><p>通过软件模拟出来的具有完整的硬件系统功能的，运行在宿主机上的一个隔离环境中的计算机系统</p><p><strong>宿主机</strong> 是指直接运行在我们物理硬件的操作系统，而 <strong>虚拟机</strong> 则是运行在宿主机之上，所以当我们运行一个虚拟机的时候，实际上我们是在同时运行两个系统，这对我们的物理硬件要求比较高（主要是内存）</p><h3 id="2-双系统"><a href="#2-双系统" class="headerlink" title="2. 双系统"></a>2. 双系统</h3><p>双系统并不是同时运行两个系统，而是指两个系统都在存储空间中，我们可以选择其中一个进行启动</p><p><br></p><h2 id="三、Win10使用VMware虚拟机安装ubuntu"><a href="#三、Win10使用VMware虚拟机安装ubuntu" class="headerlink" title="三、Win10使用VMware虚拟机安装ubuntu"></a>三、Win10使用VMware虚拟机安装ubuntu</h2><p>具体操作：<a href="https://blog.csdn.net/dcrmg/article/details/74075254" target="_blank" rel="noopener">https://blog.csdn.net/dcrmg/article/details/74075254</a></p><p>​                   <a href="https://www.jianshu.com/p/3379892948da" target="_blank" rel="noopener">https://www.jianshu.com/p/3379892948da</a></p><p><br></p><p>ubuntu-16.04.5-desktop-amd64.iso ： <a href="http://mirrors.zju.edu.cn/ubuntu-releases/16.04/" target="_blank" rel="noopener">http://mirrors.zju.edu.cn/ubuntu-releases/16.04/</a></p><p>VMware Workstation 12.5.7 Pro for Windows</p><p><br></p><p><strong>注意：装虚拟机其中有一步是关于处理器配置</strong></p><p>VMWare中的CPU数量与核心数量意义</p><p>处理器数量 ：是指CPU核数（例如：单核/双核），并不是指CPU颗数</p><p>每个处理的核心数量：是指CPU中的线程，并不是指核心（Core）</p><p><br></p><p>windows 查看CPU数、核心数、线程数</p><p><a href="https://blog.csdn.net/ksws0292756/article/details/79119961" target="_blank" rel="noopener">https://blog.csdn.net/ksws0292756/article/details/79119961</a></p><p><br></p><h2 id="四、VMware安装VMware-Tools"><a href="#四、VMware安装VMware-Tools" class="headerlink" title="四、VMware安装VMware Tools"></a>四、VMware安装VMware Tools</h2><p>提示是在客户机安装虚拟CD驱动器 ，下面是解决办法</p><p><a href="https://blog.csdn.net/AHAU10/article/details/52611765" target="_blank" rel="noopener">https://blog.csdn.net/AHAU10/article/details/52611765</a></p><p>更改路径后，一路yes下去，最后出现enjoy安装算是成功了</p><p><a href="https://blog.csdn.net/u013142781/article/details/50539574" target="_blank" rel="noopener">https://blog.csdn.net/u013142781/article/details/50539574</a></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Win10使用VMware虚拟机安装ubuntu&lt;/p&gt;
&lt;p&gt;PS：又被汪大蕾骂了一顿，还是装个虚拟机吧，毕竟做开发还是要靠Linux&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="ubuntu" scheme="http://yoursite.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Linux（四）—— 文件</title>
    <link href="http://yoursite.com/2018/09/10/Linux%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94-%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/09/10/Linux（四）——-文件/</id>
    <published>2018-09-10T12:57:10.000Z</published>
    <updated>2018-09-10T13:05:39.989Z</updated>
    
    <content type="html"><![CDATA[<p>PS：今天突然对可执行文件有了全新的理解</p><p>下面举的例子可能不那么对，但是就是这个意思。</p><p>word这个应用程序，就是通过 winword.exe 这个主程序，读取某个.doc文件然后对它进行一系列写操作</p><a id="more"></a><h2 id="一、用户和用户组"><a href="#一、用户和用户组" class="headerlink" title="一、用户和用户组"></a>一、用户和用户组</h2><p>PS：突然放这块内容有点怪，但是是为了解释后面文件权限的内容</p><h3 id="1-用户-user"><a href="#1-用户-user" class="headerlink" title="1. 用户 user"></a>1. 用户 user</h3><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，每个用户账号有一个惟一的用户名和各自的口令，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问，另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p><br></p><h3 id="2-用户组-group"><a href="#2-用户组-group" class="headerlink" title="2. 用户组 group"></a>2. 用户组 group</h3><p>具有相同特征的用户（user）的集合体。</p><p>比如，有时，要让多个用户具有相同的权限，比如查看、修改某一文件或执行某个命令，这时可以把这些用户都定义到同一用户组，通过<strong>修改文件或目录的权限</strong>，这样用户组下的用户对该文件或目录都具有相同的权限。</p><p>PS： <strong>用户和用户组的对应关系是：一对一、多对一、一对多或多对多</strong></p><p><br></p><h2 id="二、文件基本属性"><a href="#二、文件基本属性" class="headerlink" title="二、文件基本属性"></a>二、文件基本属性</h2><p>Linux系统是一种典型的多用户系统，不同的用户拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p><p>PS：其实刚开始看到这部分有点疑惑，觉得文件属性不应该是看后缀来判断文件的类型</p><p><br></p><h2 id="三、Linux下的文件后缀"><a href="#三、Linux下的文件后缀" class="headerlink" title="三、Linux下的文件后缀"></a>三、Linux下的文件后缀</h2><ol><li><strong>Linux不根据后缀判断文件类型，而是根据文件的内容来判断</strong>。所以扩展名的作用是帮助识别文件，对于Linux系统本身来说没有什么意义。</li><li>但我们自己创建一些文件，最好还是加后缀名，这样做的目的是仅仅是为了我们的在应用时方便。</li><li>Linux桌面环境和Windows一样智能化，系统会自动判断用哪个应用程序打开g=该Linux文件。</li></ol><p><br></p><h2 id="四、为什么Linux和Windows的可执行文件不能通用"><a href="#四、为什么Linux和Windows的可执行文件不能通用" class="headerlink" title="四、为什么Linux和Windows的可执行文件不能通用"></a>四、为什么Linux和Windows的可执行文件不能通用</h2><p><a href="https://www.zhihu.com/question/22672994/answer/27076210" target="_blank" rel="noopener">https://www.zhihu.com/question/22672994/answer/27076210</a></p><h3 id="1-格式不同-——-不同操作系统准备工作不同"><a href="#1-格式不同-——-不同操作系统准备工作不同" class="headerlink" title="1. 格式不同 —— 不同操作系统准备工作不同"></a>1. 格式不同 —— 不同操作系统准备工作不同</h3><ul><li>Windows 里大部分可执行文件的格式为PE</li><li>Linux 里大部分可执行文件的格式为ELF</li></ul><p>可执行文件要被执行时，操作系统需要为其分配资源，比如，内存空间（物理的和虚拟的）、进程、线程资源等等。所以可执行文件在执行之前需要告诉操作系统，要为可执行文件准备哪些东西它才能运行。</p><p><strong>但是不同的操作系统，准备工作是不同的，所以可执行文件的格式不完全相同，导致了不同的可执行文件无法跨平台直接使用。</strong></p><p><br></p><h3 id="2-操作系统API不同"><a href="#2-操作系统API不同" class="headerlink" title="2. 操作系统API不同"></a>2. 操作系统API不同</h3><p>一个可执行文件所执行的绝大多数操作（比如：文件操作、输入输出、内存申请释放、任务调度等等）都需要与操作系统交互才能完成，而不同的操作系统使用这些操作的方法完全不同。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：今天突然对可执行文件有了全新的理解&lt;/p&gt;
&lt;p&gt;下面举的例子可能不那么对，但是就是这个意思。&lt;/p&gt;
&lt;p&gt;word这个应用程序，就是通过 winword.exe 这个主程序，读取某个.doc文件然后对它进行一系列写操作&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CMake（二）—— Windows下使用CMake</title>
    <link href="http://yoursite.com/2018/09/10/CMake%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-Windows%E4%B8%8B%E4%BD%BF%E7%94%A8CMake/"/>
    <id>http://yoursite.com/2018/09/10/CMake（二）——-Windows下使用CMake/</id>
    <published>2018-09-10T06:25:35.000Z</published>
    <updated>2018-09-10T08:53:44.599Z</updated>
    
    <content type="html"><![CDATA[<p>PS：我现在陷入了不同开发环境如何编译这么个问题里，感觉自己脑袋一团浆糊 ~ </p><a id="more"></a><h2 id="一、windows下cmake安装"><a href="#一、windows下cmake安装" class="headerlink" title="一、windows下cmake安装"></a>一、windows下cmake安装</h2><p> <a href="https://blog.csdn.net/notbaron/article/details/51100545" target="_blank" rel="noopener">https://blog.csdn.net/notbaron/article/details/51100545</a></p><p>安装的时候其中有一项是问你，是否添加到PATH，勾选就好了，免得还要自己去配置</p><p><br></p><h2 id="二、windows下cmake-的使用"><a href="#二、windows下cmake-的使用" class="headerlink" title="二、windows下cmake 的使用"></a>二、windows下cmake 的使用</h2><h3 id="1-命令行方式使用CMake"><a href="#1-命令行方式使用CMake" class="headerlink" title="1. 命令行方式使用CMake"></a>1. 命令行方式使用CMake</h3><p>（1）在test1工程下写了 hello.cpp 和CMakeLists.txt两个文件</p><p>（2）在test1目录下运行<code>cmake .</code> 可以看到自动生成了解决方案文件<strong>.sln</strong> 和工程文件 <strong>.vcproj</strong></p><p>（3）打开解决方案文件<strong>.sln</strong> ，可以开始调试运行，这里<strong>注意：要把需要运行的项目设置为启动项</strong></p><p>运行完成后会生成Debug文件，下面会有.exe程序</p><p><br></p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/cmake%E4%BD%BF%E7%94%A81.png" alt=""></p><p><br></p><h3 id="2-GUI程序cmake-gui-exe来使用CMake"><a href="#2-GUI程序cmake-gui-exe来使用CMake" class="headerlink" title="2. GUI程序cmake-gui.exe来使用CMake"></a>2. GUI程序cmake-gui.exe来使用CMake</h3><p><a href="https://www.jianshu.com/p/03640a4caf7e" target="_blank" rel="noopener">https://www.jianshu.com/p/03640a4caf7e</a></p><p>（1）在test1工程下写了 hello.cpp 和CMakeLists.txt两个文件</p><p>（2）打开 cmake-gui.exe 将 CMakeLists.txt 拖到 <code>Where is the source code</code></p><p>（3）Configure：  选择代码编译工具</p><p>（4）Generate：   在<code>where to build the binaries</code> 目录下生成vs编译工程文件</p><p><strong>注意：中间文件和可执行文件一般将存放在build目录中，所以修改到 /build</strong> </p><p>（5）打开解决方案文件<strong>.sln</strong> ，可以开始调试运行，这里<strong>注意：要把需要运行的项目设置为启动项</strong></p><p><br></p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/cmake2.png" alt=""></p><p><br></p><h2 id="三、CMake与Visual-Studio"><a href="#三、CMake与Visual-Studio" class="headerlink" title="三、CMake与Visual Studio"></a>三、CMake与Visual Studio</h2><p><a href="http://www.g-var.com/posts/translation/cmake/cmake_and_visual_studio/" target="_blank" rel="noopener">http://www.g-var.com/posts/translation/cmake/cmake_and_visual_studio/</a></p><p>Visual Studio到CMake的映射</p><p>PS：看到下面这张表有一种如梦初醒的感觉，Visual Studio项目的一些常见的操作和设置，比如新建工程后，需要对opencv做环境配置等，都和 CMakeLists.txt 对映起来</p><p><img src="http://www.g-var.com/images/cmake/cmake_and_visual_studio.png" alt="img"></p><p><a href="http://www.ituring.com.cn/book/miniarticle/5514" target="_blank" rel="noopener">http://www.ituring.com.cn/book/miniarticle/5514</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：我现在陷入了不同开发环境如何编译这么个问题里，感觉自己脑袋一团浆糊 ~ &lt;/p&gt;
    
    </summary>
    
    
      <category term="cmake" scheme="http://yoursite.com/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>CMake（一）—— make和cmake</title>
    <link href="http://yoursite.com/2018/09/10/CMake%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94-make%E5%92%8Ccmake/"/>
    <id>http://yoursite.com/2018/09/10/CMake（一）——-make和cmake/</id>
    <published>2018-09-10T03:39:51.000Z</published>
    <updated>2018-09-13T12:41:28.054Z</updated>
    
    <content type="html"><![CDATA[<p>PS：之前一直是在Windows用VS，感觉很方便，自己新建个工程，不论是编译还是调试，都有现成的，IDE都帮你集成好了，按几个键就好了 ~ </p><a id="more"></a><h2 id="一、makefile-和-make"><a href="#一、makefile-和-make" class="headerlink" title="一、makefile 和 make"></a>一、makefile 和 make</h2><p>『敲黑板！！！make 并不只是编译.c，还有链接目标文件啊』</p><p>PS：又发现自己理解偏差了，makefile里写的规则并不只有将.c 编译为目标文件，肯定有链接，但是，我之前看make的解释都是什么编译多个文件，以为没有链接的功能，我之前一直觉得很奇怪，为什么 make 之后就可以运行可执行文件了，还没有链接呢，感觉自己太年轻了 ~</p><p><br></p><h3 id="1-编译器和-make"><a href="#1-编译器和-make" class="headerlink" title="1. 编译器和 make"></a>1. 编译器和 make</h3><ul><li><p><strong>编译器是编译一个文件</strong></p></li><li><p>make是编译多个源文件的工具，</p><p>通过调用makefile文件中，用户指定的命令来进行编译和链接的，看作是编译器的调度器</p></li></ul><p><br></p><h3 id="2-makefile-文件"><a href="#2-makefile-文件" class="headerlink" title="2. makefile 文件"></a>2. makefile 文件</h3><p>一个工程中有很多源文件，makefile定义了整个工程的编译规则，哪些文件先编译，哪些文件后编译，哪些文件重新编译。malefile是<strong>自动化编译</strong>，一旦写好，只需一个make，整个工程自动编译。</p><p>生成阶段将生成用户指定类型（如Visual Studio或GNU/Linux GCC）的构建文件</p><p><br></p><h2 id="二、CmakeList-txt-和-CMake"><a href="#二、CmakeList-txt-和-CMake" class="headerlink" title="二、CmakeList.txt 和 CMake"></a>二、CmakeList.txt 和 CMake</h2><h3 id="1-CMake-的优势"><a href="#1-CMake-的优势" class="headerlink" title="1. CMake 的优势"></a>1. CMake 的优势</h3><p> <a href="http://gclxry.com/use-cmake-on-windows/" target="_blank" rel="noopener">http://gclxry.com/use-cmake-on-windows/</a></p><p>因为有好几种 Make 工具，例如 GNU Make ，QT 的 qmake 等等。这些 Make 工具遵循着不同的规范和标准，执行的 Makefile 格式也不同。如果想跨平台，在不同平台编译，而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile 。</p><p>CMake就是针对上面问题所设计的工具，首先允许开发者编写一种『 <strong>平台无关</strong> 』的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成本地化的 Makefile 或工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。</p><p><br></p><h3 id="2-CMake-的使用原理"><a href="#2-CMake-的使用原理" class="headerlink" title="2. CMake 的使用原理"></a>2. CMake 的使用原理</h3><p><strong>CMake是种跨平台编译工具，Cmake 将 CMakeList.txt 转化为make 需要的 makefile 文件，用make编译</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：之前一直是在Windows用VS，感觉很方便，自己新建个工程，不论是编译还是调试，都有现成的，IDE都帮你集成好了，按几个键就好了 ~ &lt;/p&gt;
    
    </summary>
    
    
      <category term="cmake" scheme="http://yoursite.com/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>Linux（三）—— 环境变量</title>
    <link href="http://yoursite.com/2018/09/09/Linux%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2018/09/09/Linux（三）——-环境变量/</id>
    <published>2018-09-09T09:29:37.000Z</published>
    <updated>2018-09-09T09:30:22.903Z</updated>
    
    <content type="html"><![CDATA[<p>Linux是一个<strong>多用户多任务</strong>的操作系统，每个用户登录系统后，都会有一个专用的运行环境。</p><p><a href="https://blog.csdn.net/u010533843/article/details/54986646" target="_blank" rel="noopener">https://blog.csdn.net/u010533843/article/details/54986646</a></p><a id="more"></a><p><br></p><h3 id="一、环境变量按照生命周期来分"><a href="#一、环境变量按照生命周期来分" class="headerlink" title="一、环境变量按照生命周期来分"></a>一、环境变量按照生命周期来分</h3><ol><li>永久的：需要用户修改相关的<strong>配置文件</strong>，变量永久生效。</li><li>临时的：用户利用export命令，在当前终端下声明环境变量，<strong>关闭Shell终端失效</strong>。</li></ol><p><br></p><h3 id="二、环境变量按照作用域来分"><a href="#二、环境变量按照作用域来分" class="headerlink" title="二、环境变量按照作用域来分"></a>二、环境变量按照作用域来分</h3><p>1.<strong>系统环境变量</strong>：对该系统中所有用户都有效</p><ul><li><p>/etc/environment：</p><p>是系统在登录时读取的第一个文件，该文件设置的是整个系统的环境，只要启动系统就会读取该文件，用于为所有进程设置环境变量。</p><p>系统使用此文件时并不是执行此文件中的命令，而是根据KEY=VALUE模式的代码，对KEY赋值以VALUE，因此文件中如果要定义PATH环境变量，只需加入 PATH=$PATH:/xxx/bin</p></li><li><p>/etc/profile：</p><p>是系统登录时执行的第二个文件，为系统的每个用户设置环境信息。当用户登录时，该文件被执行一次，并从 /etc/profile.d 目录的配置文件中搜集shell 的设置。  </p></li></ul><ul><li><p>/etc/bashrc：</p><p>针对所有用户的bash初始化文件，当 bash shell 被打开时，该文件被读取，即每次新打开一个终端 shell，该文件就会被读取。</p></li></ul><p><br></p><p>2.<strong>用户环境变量</strong>：只对特定的用户有效</p><ul><li><p>~/.profile：</p><p>只对单个用户生效，当用户登录时该文件仅执行一次。用户可使用该文件添加自己使用的 shell 变量信息。</p></li><li><p>~/.bash_profile：</p><p> 是交互式、login 方式进入bash 运行</p><p>包含专用于用户的bash shell的bash信息，当用户登录时，该文件仅仅执行一次。默认情况下，他设置一些环境变量，执行用户的.bashrc文件。</p></li><li><p>~/.bashrc：</p><p>是交互式 non-login 方式进入bash 运行</p><p>包含专用于用户的bash shell的bash信息，当用户登录时以及每次打开新的shell时，该文件被读取。（每个用户都有一个.bashrc文件，在用户目录下）</p></li></ul><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>shell 是用户和Linux 内核之间的接口程序，你在提示符下输入的每个命令都由shell先解释然后传给Linux内核，<strong>shell 是一个命令行解释器</strong>。</p><p> bash 是 Linux 默认的 shell  ，相对应的，windows shell就是cmd。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux是一个&lt;strong&gt;多用户多任务&lt;/strong&gt;的操作系统，每个用户登录系统后，都会有一个专用的运行环境。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u010533843/article/details/54986646&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/u010533843/article/details/54986646&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux（二）—— 系统目录结构</title>
    <link href="http://yoursite.com/2018/09/09/Linux%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/09/09/Linux（二）——-系统目录结构/</id>
    <published>2018-09-09T09:27:53.000Z</published>
    <updated>2018-09-09T09:28:38.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-系统目录结构"><a href="#Linux-系统目录结构" class="headerlink" title="Linux 系统目录结构"></a>Linux 系统目录结构</h2><p>Linux系统目录是树状目录结构，”/ “ 根是所有目录的起点</p><p><strong>/home</strong>：用户的主目录，一般该目录名是以用户的账号命名的</p><p><strong>/root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。</p><p><strong>/usr</strong> ：是系统存放程序的目录</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/003vPl7Rty6E8kZRlAEdc690.jpg" alt="003vPl7Rty6E8kZRlAEdc&amp;690"></p><a id="more"></a><p>终端默认的启动位置是当前用户目录 home</p><ul><li><p>如果只是访问而不涉及修改的话，不需要root权限</p><p><code>cd /</code> 回到根目录cd</p></li></ul><p><code>cd /usr</code> 访问usr文件</p><ul><li>如果需要对根用户权限下的文件或文件夹做修改的话，需要把自身权限提为root权限，方法就是在命令前加上一个sudo，然后按照提示输入root密码即可</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux-系统目录结构&quot;&gt;&lt;a href=&quot;#Linux-系统目录结构&quot; class=&quot;headerlink&quot; title=&quot;Linux 系统目录结构&quot;&gt;&lt;/a&gt;Linux 系统目录结构&lt;/h2&gt;&lt;p&gt;Linux系统目录是树状目录结构，”/ “ 根是所有目录的起点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;/home&lt;/strong&gt;：用户的主目录，一般该目录名是以用户的账号命名的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;/root&lt;/strong&gt;：该目录为系统管理员，也称作超级权限者的用户主目录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;/usr&lt;/strong&gt; ：是系统存放程序的目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.runoob.com/wp-content/uploads/2014/06/003vPl7Rty6E8kZRlAEdc690.jpg&quot; alt=&quot;003vPl7Rty6E8kZRlAEdc&amp;amp;690&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux（一）—— 为什么要用Linux做开发</title>
    <link href="http://yoursite.com/2018/09/09/Linux%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Linux%E5%81%9A%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2018/09/09/Linux（一）——-为什么要用Linux做开发/</id>
    <published>2018-09-09T09:23:41.000Z</published>
    <updated>2018-09-10T08:13:10.369Z</updated>
    
    <content type="html"><![CDATA[<p>一直在纠结什么开发要用Linux系统，下面写两点自己的理解，不知道对不对。</p><a id="more"></a><ol><li><p>Linux占据了主要<strong>服务器市场</strong></p><p>下面来盘一下逻辑：为什么Linux占据服务器市场，因为Linux相比于windows好，为什么好，比如，Linux 没有把图形用户界面GUI写入内核kernel，Linux的内核小，速度快。</p></li><li><p>Linux适合做<strong>嵌入式操作系统</strong></p><p>嵌入式linux 是将Linux操作系统进行裁剪修改，使之能在嵌入式计算机系统上运行的一种操作系统。 </p><p>Linux做嵌入式的优势，首先，Linux是开放源代码的，不存在黑箱技术。其次，Linux的内核小、效率高，内核的更新速度很快。第三，Linux是免费的操作系统，在价格上极具竞争力。 </p></li></ol><!--more--><p>Linux相比于windows的优势：</p><p><strong>1. 稳定性高</strong></p><p><strong>2. 成本低</strong></p><p><strong>3. 低维护成本</strong></p><p><strong>4. 病毒造成破坏低</strong></p><p>……</p><p><a href="https://blog.csdn.net/dolphin_LYG/article/details/59121002" target="_blank" rel="noopener">https://blog.csdn.net/dolphin_LYG/article/details/59121002</a></p><p>可能是我用的太少了，实在没有体会到，Linux 相较于 windows 的不同与优势。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直在纠结什么开发要用Linux系统，下面写两点自己的理解，不知道对不对。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>DLL的创建与使用</title>
    <link href="http://yoursite.com/2018/09/04/DLL%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/09/04/DLL的创建与使用/</id>
    <published>2018-09-04T06:50:48.000Z</published>
    <updated>2018-09-04T06:55:22.852Z</updated>
    
    <content type="html"><![CDATA[<p>PS：前几天朱大丽，和我说她不会生成自己的DLL，我也不会啊，有什么办法，只能宠着她帮她做呗。不然整体阿谀奉承我，让我略略略 ~</p><a id="more"></a><p><br></p><h2 id="一、VS创建DLL"><a href="#一、VS创建DLL" class="headerlink" title="一、VS创建DLL"></a>一、VS创建DLL</h2><p><a href="http://wangzi6147.github.io/2015/05/05/DLL.html" target="_blank" rel="noopener">http://wangzi6147.github.io/2015/05/05/DLL.html</a></p><p>1.创建一个DLL工程</p><p><img src="http://wangzi6147.github.io/public/img/DLL_1.jpg" alt="img"></p><p><br></p><p>2.添加头文件 MyDllCalculator.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DLL_API  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_API __declspec(dllexport)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DLL_API代表可供调用者调用的函数 </span></span><br><span class="line"><span class="function">DLL_API  <span class="keyword">int</span> <span class="title">MyAdd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function">DLL_API  <span class="keyword">int</span> <span class="title">MyMul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><p><br></p><p>3.添加源文件 MyDllCalculator.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyDllCalculator.h"</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyAdd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyMul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>4.生成解决方案，生成Debug版本的库文件，所以在Debug文件下生成.lib和.dll</p><p>注意：如果生成的库依赖其他动态链接库，需要把依赖的.dll文件一同打包发布</p><p><br></p><p><br></p><h2 id="二、使用DLL"><a href="#二、使用DLL" class="headerlink" title="二、使用DLL"></a>二、使用DLL</h2><ol><li><p>添加工程的头文件目录：工程—属性—配置属性—c/c++—常规—附加包含目录：加上头文件存放目录</p><p>MyDllCalculator.h 的存放路径</p></li><li><p>添加文件引用的lib静态库路径：工程—属性—配置属性—链接器—常规—附加库目录：加上lib文件存放目录</p></li><li><p>添加工程引用的lib文件名：工程—属性—配置属性—链接器—输入—附加依赖项：加上lib文件名（用绝对路径）</p></li><li><p>添加工程引用的dll动态库：把引用的dll放到工程的 <strong>可执行文件</strong> 所在的目录下</p></li></ol><p>程序运行结果</p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/dll1.JPG" alt=""></p><p><br></p><p><br></p><h2 id="三、DLL-导入导出"><a href="#三、DLL-导入导出" class="headerlink" title="三、DLL 导入导出"></a>三、DLL 导入导出</h2><h3 id="1-declspec-dllexport"><a href="#1-declspec-dllexport" class="headerlink" title="1. __declspec(dllexport)"></a>1. <code>__declspec(dllexport)</code></h3><p>声明一个导出函数，即这个函数要从本DLL导出。省掉在DEF文件中手工定义导出哪些函数的一个方法。但是，如果DLL里全是C++的类，无法在DEF里指定导出的函数,，只能用<code>__declspec(dllexport)</code>导出类</p><p><br></p><h3 id="2-declspec-dllimport"><a href="#2-declspec-dllimport" class="headerlink" title="2. __declspec(dllimport)"></a>2. <code>__declspec(dllimport)</code></h3><p>声明一个导入函数，是说这个函数是从别的DLL导入。不使用，也能正确编译，但使用，可以使编译器生成更好的代码，因为它可以确定函数是否存在于 DLL 中，这使得编译器可以生成跳过间接寻址级别的代码，而这些代码通常会出现在跨 DLL 边界的函数调用中。但是，必须使用<code>__declspec(dllimport)</code>才能导入 DLL 中使用的变量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：前几天朱大丽，和我说她不会生成自己的DLL，我也不会啊，有什么办法，只能宠着她帮她做呗。不然整体阿谀奉承我，让我略略略 ~&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剑指offer（一）</title>
    <link href="http://yoursite.com/2018/08/22/%E5%89%91%E6%8C%87offer%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/08/22/剑指offer（一）/</id>
    <published>2018-08-22T13:52:48.000Z</published>
    <updated>2018-09-09T06:55:09.102Z</updated>
    
    <content type="html"><![CDATA[<p><strong>面试题一：赋值运算符函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CMyString(<span class="keyword">char</span>* pData = <span class="literal">NULL</span>);</span><br><span class="line">CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">~CMyString(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p><br></p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>没有返回值</p><p>构造函数的重载</p><p><br></p><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>没有传入参数、没有返回值、一个类只能有一个析构函数</p><p>先构造的对象，后析构</p><p><br></p><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>根据一个类的对象，复制一个一样的对象</p><p>拷贝构造函数分为浅拷贝和深拷贝两种：</p><ul><li>浅拷贝只是复制指针的地址，会导致两个指针指向同一块内存，在分别delete时就会出现重复释放</li><li>深拷贝则创建新内存，把值拷贝进新开的内存，指针指向新开的内存</li></ul><p><br></p><h2 id="赋值运算符函数重载"><a href="#赋值运算符函数重载" class="headerlink" title="赋值运算符函数重载"></a>赋值运算符函数重载</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><ol><li><p><strong>返回值为类型的引用</strong>，函数结束前返回实例自身的引用 return *this  </p><p>若返回void，则不能做<strong>连续赋值操作</strong> a=b=c</p></li><li><p><strong>传入的参数为常量引用</strong> </p><p>引用可以<strong>避免从形参到实参会调用一次拷贝构造函数</strong>，提高效率 </p><p>const 不改变传入的实例</p></li><li><p><strong>重新分配内存时候，必须要释放之前自己已有的空间，否则会导致内存泄漏</strong> </p><p>m_pData之前指向的内存释放</p></li><li><p>判断传入的参数和当前的实例*this是否为同一实例，即this == &amp;str</p><p>若是同一个，不进行赋值</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>=&amp;str)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> []m_pData;  <span class="comment">//释放原有内存</span></span><br><span class="line">    m_pData=<span class="literal">NULL</span>;</span><br><span class="line">    m_pData=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData)+<span class="number">1</span>];  <span class="comment">//分配新内存</span></span><br><span class="line">    stpcpy(m_pData,str.m_pData);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>先释放之前的内存再开辟新空间，如果此时内存不足导致new时抛出异常，那么此时m_pData已经为空指针，<strong>原来实例的状态被修改</strong>，这样违背了异常安全性（Exception Safety）的原则</p><p>因可以先创建一个临时实例，再交换临时实例和原来的实例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> !=&amp;str)</span><br><span class="line">    &#123;</span><br><span class="line"> <span class="comment">//临时对象strTemp，运行到if作用域外，就用自动调用strTemp的析构函数从而完成了内存的释放</span></span><br><span class="line">        CMyString strTemp(str）；   <span class="comment">//先创建一个临时对象strTemp</span></span><br><span class="line">        <span class="keyword">char</span>* pTemp=strTemp.m_pData;</span><br><span class="line">        strTemp.m_pData=m_pData;   <span class="comment">//strTemp.m_pData就是实例的m_pData之前指向的内存</span></span><br><span class="line">        m_pData=pTemp；    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：<strong>内存泄漏</strong>—程序中己动态分配的堆内存，由于某种原因程序未释放，造成系统内存的浪费</p><p><br></p><hr><p>以下是这道题涉及到的其它知识点</p><p><br></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li>引用是变量的别名，一旦把引用初始化为某个变量，就可以使用该引用名指向变量</li><li><strong>引用与指针</strong>的区别：</li><li><ul><li>不存在空引用，引用必须连接到一块合法的内存</li><li>一旦引用被初始化，就不能被指向到另一个对象，指针可以在任何时候指向到另一个对象</li><li>引用必须在创建时被初始化，指针可以在任何时间被初始化</li></ul></li></ol><p><br></p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h3 id="1-const修饰变量"><a href="#1-const修饰变量" class="headerlink" title="1. const修饰变量"></a>1. const修饰变量</h3><p>const修饰的类型为TYPE的变量value是不可变的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const TYPE ValueName = value;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-指针使用const"><a href="#2-指针使用const" class="headerlink" title="2. 指针使用const"></a>2. 指针使用const</h3><p>(1) 指针本身是常量不可变</p><p><code>char* const pContent;</code></p><p>(2) 指针所指向的内容是常量不可变</p><p><code>const char* pContent;</code></p><p>(3)两者都不可变</p><p><code>const char* const pContent;</code></p><p> <br></p><h3 id="3-函数中使用const"><a href="#3-函数中使用const" class="headerlink" title="3. 函数中使用const"></a>3. 函数中使用const</h3><p>(1)const修饰函数参数<br>a.传递过来的参数在函数内不可以改变(无意义，因为Var本身就是形参)</p><p><code>void function(const int Var);</code></p><p>b.参数指针所指内容为常量不可变</p><p><code>void function(const char* Var);</code></p><p>c.参数指针本身为常量不可变(也无意义，因为char* Var也是形参)</p><p><code>void function(char* const Var);</code></p><p>d.参数为引用，为了增加效率同时防止修改</p><p><code>void function(const Class&amp; Var);</code>//引用参数在函数内不可以改变</p><p><code>void function(const TYPE&amp; Var);</code> //引用参数在函数内为常量不可变</p><p>(2)const 修饰函数返回值</p><p><br></p><p><strong>将const类型转化为非const类型的方法</strong> ：</p><p>const_cast &lt; type_id &gt;  (expression) </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;面试题一：赋值运算符函数&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CMyString&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CMyString(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* pData = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CMyString(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; CMyString&amp;amp; str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;~CMyString(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* m_pData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>编译器、编辑器、IDE</title>
    <link href="http://yoursite.com/2018/08/22/%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%81%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%81IDE/"/>
    <id>http://yoursite.com/2018/08/22/编译器、编辑器、IDE/</id>
    <published>2018-08-22T08:59:22.000Z</published>
    <updated>2018-08-22T09:24:21.709Z</updated>
    
    <content type="html"><![CDATA[<p>PS：关于版本和各种编辑器、编译器、IDE</p><a id="more"></a><h2 id="C-版本"><a href="#C-版本" class="headerlink" title="C++版本"></a>C++版本</h2><ul><li>C++03</li><li>C++11</li><li>C++14</li></ul><p><br></p><h2 id="python版本"><a href="#python版本" class="headerlink" title="python版本"></a>python版本</h2><ul><li>python2.x</li><li>python3.x</li></ul><p><br></p><h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>编译器是编译一个文件</p><ul><li>gcc/g++</li><li>clang</li></ul><p><br></p><h2 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h2><p>make是<strong>编译多个源文件</strong>的工具，解释makefile中的指令，看作是编译器的调度器</p><p>make通过读入makefile，执行一组以gcc/g++为主的shell命令序列，输入文件主要用来记录文件之间的依赖关系和命令执行顺序</p><p><br></p><h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>CMake是一种跨平台编译工具</p><p>CMake主要是编写CMakeLists.txt文件，然后用cmake命令将CMakeLists.txt文件转化为make所需要的makefile文件，最后用make命令编译源码生成可执行程序或共享库 so(shared object)</p><p><br></p><h2 id="集成开发环境IDE"><a href="#集成开发环境IDE" class="headerlink" title="集成开发环境IDE"></a>集成开发环境IDE</h2><p>集成开发环境（IDE，Integrated Development Environment ）：一般包括代码编辑器、编译器、调试器和图形用户界面等工具。</p><ul><li>Microsoft Visual C++：（简称Visual C++、MSVC、VC++或VC）是微软公司的C++开发工具</li><li>Eclipse：开源的、跨平台的 IDE</li><li>Qt Creator：收费的、跨平台的 IDE</li><li>Visual Studio：Windows平台应用程序的集成开发环境</li><li>Android Studio： Android平台开发程序的集成开发环境</li></ul><p><br></p><h2 id="代码编辑器"><a href="#代码编辑器" class="headerlink" title="代码编辑器"></a>代码编辑器</h2><ul><li>Atom  ：跨平台的文本编辑器</li><li>Sublime Text：跨平台的文本编辑器</li><li>VI/VIM：Unix/Linux </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：关于版本和各种编辑器、编译器、IDE&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
</feed>
