<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>绿小蕤</title>
  <icon>https://www.gravatar.com/avatar/e4d7a8bd1cb84fb3b4123916b4ea2f6b</icon>
  <subtitle>好逸恶劳,贪生怕死</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-25T11:46:52.259Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>绿小蕤</name>
    <email>528036346@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Christmas Gift——pygame、pyinstaller</title>
    <link href="http://yoursite.com/2018/12/25/Christmas-Gift%E2%80%94%E2%80%94pygame%E3%80%81pyinstaller/"/>
    <id>http://yoursite.com/2018/12/25/Christmas-Gift——pygame、pyinstaller/</id>
    <published>2018-12-25T11:46:52.000Z</published>
    <updated>2018-12-25T11:46:52.259Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>机器学习（五）——KNN</title>
    <link href="http://yoursite.com/2018/12/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94KNN/"/>
    <id>http://yoursite.com/2018/12/25/机器学习（五）——KNN/</id>
    <published>2018-12-25T06:32:22.000Z</published>
    <updated>2018-12-25T06:34:16.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>1.以所有已知类别的实例作为参照，选取参数K</p><p>2.计算已知实例与未知实例的距离</p><p>3.选择最近的K个实例</p><p>4.根据投票原则，将未知实例归为K个最近邻中多数的样本</p><a id="more"></a><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1.算法复杂度高，未知实例需要与所有已知实例比较</p><p>2.样本分布不均匀时，未知实例容易被归为实例数量过大的起主导作用的那一类</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法流程&quot;&gt;&lt;a href=&quot;#算法流程&quot; class=&quot;headerlink&quot; title=&quot;算法流程&quot;&gt;&lt;/a&gt;算法流程&lt;/h2&gt;&lt;p&gt;1.以所有已知类别的实例作为参照，选取参数K&lt;/p&gt;
&lt;p&gt;2.计算已知实例与未知实例的距离&lt;/p&gt;
&lt;p&gt;3.选择最近的K个实例&lt;/p&gt;
&lt;p&gt;4.根据投票原则，将未知实例归为K个最近邻中多数的样本&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习（四）——XGBoost</title>
    <link href="http://yoursite.com/2018/12/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94XGBoost/"/>
    <id>http://yoursite.com/2018/12/25/机器学习（四）——XGBoost/</id>
    <published>2018-12-25T01:09:43.000Z</published>
    <updated>2018-12-25T01:13:36.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h2><p>1.多个决策树的 <strong>集成</strong>               </p><p>2.一个树一个树向里增加，同时每加一个树，需要保证效果是提升的<br>当要增加树的时候，会将前面的树当成一个整体，构造的树，使得之前当成整体的目标函数减小</p><a id="more"></a><h2 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h2><p>两者具体的区别：<a href="https://blog.csdn.net/u013709270/article/details/72553282" target="_blank" rel="noopener">https://blog.csdn.net/u013709270/article/details/72553282</a></p><p>Bagging <strong>并行</strong>生成<br>Boosting 将弱分类器 <strong>提升</strong>为强分类器，<strong>串行</strong>生成</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;XGBoost&quot;&gt;&lt;a href=&quot;#XGBoost&quot; class=&quot;headerlink&quot; title=&quot;XGBoost&quot;&gt;&lt;/a&gt;XGBoost&lt;/h2&gt;&lt;p&gt;1.多个决策树的 &lt;strong&gt;集成&lt;/strong&gt;               &lt;/p&gt;
&lt;p&gt;2.一个树一个树向里增加，同时每加一个树，需要保证效果是提升的&lt;br&gt;当要增加树的时候，会将前面的树当成一个整体，构造的树，使得之前当成整体的目标函数减小&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习（三）——PCA</title>
    <link href="http://yoursite.com/2018/12/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94PCA/"/>
    <id>http://yoursite.com/2018/12/24/机器学习（三）——PCA/</id>
    <published>2018-12-24T09:28:20.000Z</published>
    <updated>2018-12-24T11:10:33.850Z</updated>
    
    <content type="html"><![CDATA[<p>PS：关于PCA数学推导，协方差矩阵、特征向量计算的那部分我就不放</p><a id="more"></a><h2 id="一、降维"><a href="#一、降维" class="headerlink" title="一、降维"></a>一、降维</h2><p>projection 高维到低维的 <strong>投影</strong><br>highly redundant features 可以减少多余的特征</p><p><br></p><h2 id="二、为什么需要降维"><a href="#二、为什么需要降维" class="headerlink" title="二、为什么需要降维"></a>二、为什么需要降维</h2><p>1.使用较少的计算机内存或磁盘空间（选择k，使得原数据的方差尽可能保留）<br>2.加快学习算法（选择k，使得原数据的方差尽可能保留）<br>3.可视化数据（选择k=2、3，将数据放在二维平面或三维空间展示）</p><p><br></p><h2 id="三、PCA"><a href="#三、PCA" class="headerlink" title="三、PCA"></a>三、PCA</h2><h3 id="1-PCA的理解"><a href="#1-PCA的理解" class="headerlink" title="1.PCA的理解"></a>1.PCA的理解</h3><p><strong>PCA就是找到一个低维的平面，把所有的数据都投射到该平面上时，使得投射误差 projection error 尽可能的小</strong></p><p>n维降到k维，就是在n维空间中，找一个低维空间，<strong>该低维空间可以用k个n维的向量来表示</strong>，把所有的数据都投射到该空间中，使得投射的误差 projection error 尽可能的小</p><h3 id="2-PCA需要计算"><a href="#2-PCA需要计算" class="headerlink" title="2.PCA需要计算"></a>2.PCA需要计算</h3><p>(1)用于降维的，k个n维的方向向量 U_redeuce<br>(2)数据在低维空间投影后的特征 Z</p><h3 id="3-PCA实现步骤"><a href="#3-PCA实现步骤" class="headerlink" title="3.PCA实现步骤"></a>3.PCA实现步骤</h3><p><img src="https://github.com/Sophia0130/Sophia0130.github.io/blob/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/PCA%E6%AD%A5%E9%AA%A4%E5%AE%9E%E7%8E%B0.jpg?raw=true" alt=""></p><h3 id="4-PCA数学推导"><a href="#4-PCA数学推导" class="headerlink" title="4.PCA数学推导"></a>4.PCA数学推导</h3><h3 id="5-PCA与线性回归的区别"><a href="#5-PCA与线性回归的区别" class="headerlink" title="5.PCA与线性回归的区别"></a>5.PCA与线性回归的区别</h3><p>[右图] PCA最小化的是 <strong>投射误差</strong>（projection Error），不做预测<br>[左图] 线性回归最小化的是 <strong>预测误差</strong>，即预测结果与实际标签的距离</p><p><img src="https://images2015.cnblogs.com/blog/788978/201605/788978-20160524003006303-547302950.png" alt=""></p><p><br></p><h2 id="四、主成分个数k的选择"><a href="#四、主成分个数k的选择" class="headerlink" title="四、主成分个数k的选择"></a>四、主成分个数k的选择</h2><p>PCA的目的：是减少投射的平均均方误差</p><p>PCA的ｋ选取是：投射的平均均方误差与训练集方差的比例尽可能小的情况下，选择尽可能小的k<br>（这个比例小于1%，意味着原本数据的 <strong>方差</strong>有99%都保留下来了）</p><p>选取步骤：<br>1.令k=1，然后进行主要成分分析，获得前k个特征向量 U_reduce 和计算原数据 X 投影后的数据 Z<br>2.计算投射的平均均方误差与训练集方差的比例，是否小于1%<br>（如果不满足，令k=2，如此类推，直到找到可以使得比例小于1%的最小k值）</p><p><img src="https://images2015.cnblogs.com/blog/788978/201605/788978-20160524003014225-1738231865.png" alt=""></p><p><br></p><h2 id="五、PCA不适合设防止过拟合"><a href="#五、PCA不适合设防止过拟合" class="headerlink" title="五、PCA不适合设防止过拟合"></a>五、PCA不适合设防止过拟合</h2><p>PCA并不是一个好的方法用来防止过拟合，防止过拟合，还是应该用正则化</p><p>原因：<br>1.PCA是无监督的，会 <strong>丢失与Y相关的信息</strong><br>PCA是 <strong>无监督</strong>的，只关注输入数据X之间的相关性，降低数据Ｘ的维度，而不考虑标签Y，会让与Y有关的信息被丢失<br>对于监督学习，则寻找的是X与Y之间的联系</p><p>2.PCA会 <strong>丢失方差小的特征</strong><br><strong>PCA的假设是方差越大信息量越多</strong>，但是方差小的特征并不代表表对于标签没有意义</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：关于PCA数学推导，协方差矩阵、特征向量计算的那部分我就不放&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习（二）——贝叶斯算法</title>
    <link href="http://yoursite.com/2018/12/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/12/24/机器学习（二）——贝叶斯算法/</id>
    <published>2018-12-24T09:21:17.000Z</published>
    <updated>2018-12-24T11:10:00.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正向概率、逆向概率"><a href="#正向概率、逆向概率" class="headerlink" title="正向概率、逆向概率"></a>正向概率、逆向概率</h2><p>根据表面现象，做出猜测</p><p><img src="https://github.com/Sophia0130/Sophia0130.github.io/blob/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%AD%A3%E5%90%91%E3%80%81%E9%80%86%E5%90%91%E6%A6%82%E7%8E%87.JPG?raw=true" alt=""></p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>P(B|A) = P(A|B)*P(B) / P(A)</p><p><img src="https://github.com/Sophia0130/Sophia0130.github.io/blob/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%8F%E7%90%86%E8%A7%A3.jpg?raw=true" alt=""></p><a id="more"></a><h2 id="实例一：拼写纠正"><a href="#实例一：拼写纠正" class="headerlink" title="实例一：拼写纠正"></a>实例一：拼写纠正</h2><p>用户输入了一个不在字典的单词，猜测用户想输入的单词</p><p>P(猜测用户想输入的单词|用户实际输入的单词)</p><p>用户输入P(D)=“tha”，猜测用户想输入的可能是P(h1)=“the”、P(h2)=“than”……</p><p><br></p><h3 id="一、公式理解"><a href="#一、公式理解" class="headerlink" title="一、公式理解"></a>一、公式理解</h3><p>1.需要求出这些概率，将最大值作为预测的结果</p><p>P(h1|D)=P(猜测用户想输入的=“the”|用户实际输入的=“tha”)<br>P(h2|D)=P(猜测用户想输入的=“than”|用户实际输入的=“tha”)……</p><p>P(h|D)=P(D|h)*P(h)/P(D)</p><p>2.<strong>先验概率</strong></p><p>P(h1)=P(猜测用户想输入的=“the”)<br>P(h2)=P(猜测用户想输入的=“than”) ……<br>即“the”、“than”的词频为先验概率</p><p>3.在某个猜想下，实际的概率</p><p>P(D|h1)=P(用户实际输入的=“tha”|猜测用户想输入的=“the”)<br>P(D|h2 )=P(用户实际输入的=“tha”|猜测用户想输入的=“than”)……</p><p>把“the”写成“tha”的概率，有很多衡量指标，可能与键盘中a和e的远近有关</p><p><br></p><h3 id="二、模型比较理论"><a href="#二、模型比较理论" class="headerlink" title="二、模型比较理论"></a>二、模型比较理论</h3><p>我们希望找出P(h1|D)、P(h2|D)…….中最大的作为预测结果，P(h|D)与P(D|h)*P(h)成正比，那么P(D|h)越大、或者P(h)越大对应的预测越大，越是我们需要的模型</p><p>1.<strong>最大似然估计((maximum likelihood estimation, MLE)</strong></p><p>P(D|h)较大的模型较有优势</p><p>2.<strong>奥卡姆剃刀</strong></p><p>P(h)较大的模型较有优势，即在实际中什么情况越常见，则其优势是越大的</p><p><br></p><h2 id="实例二：垃圾邮件过滤"><a href="#实例二：垃圾邮件过滤" class="headerlink" title="实例二：垃圾邮件过滤"></a>实例二：垃圾邮件过滤</h2><p><img src="https://github.com/Sophia0130/Sophia0130.github.io/blob/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9E%83%E5%9C%BE%E9%82%AE%E4%BB%B6.JPG?raw=true" alt=""></p><p>1.先验概率 P (h+)、P(h-)可以通过统计邮件库中垃圾邮件、正常邮件的比例来得到</p><p>2.P(D|h+)</p><p>将原始的条件概率通过以下几步化简</p><p>(1)P(D|h+)=P(d1,d2,d3…dn|h+)表示当这封邮件是垃圾邮件时，这封邮件中恰好出现D(d1,d2,d3…dn)中这N个单词的概率</p><p>(2)P(D|h+)=P(d1,d2,d3…dn|h+)=P(d1|h+)*P(d2|d1,h+)*P(d3|d1,d2,h<br>+)*…<br>对P(D|h+)条件概率可以展开为P(d1|h+)*P(d2|d1,h+)*P(d3|d1,d2,h<br>+)*…表示一封垃圾邮件第一个词为d1的概率，一封垃圾邮件第一个词为d1时第二个词为d2的概率，…</p><p>(3)<strong>朴素贝叶斯</strong><br>假设di与di-1互不影响，即 <strong>特征独立</strong><br>P(d1|h+)*P(d2|d1,h+)*P(d3|d1,d2,h<br>+)*…可以化简为P(d1|h+)*P(d2|h+)*P(d3|h<br>+)*…即只要统计垃圾邮件中d1、d2、d3的概率</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;正向概率、逆向概率&quot;&gt;&lt;a href=&quot;#正向概率、逆向概率&quot; class=&quot;headerlink&quot; title=&quot;正向概率、逆向概率&quot;&gt;&lt;/a&gt;正向概率、逆向概率&lt;/h2&gt;&lt;p&gt;根据表面现象，做出猜测&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/Sophia0130/Sophia0130.github.io/blob/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%AD%A3%E5%90%91%E3%80%81%E9%80%86%E5%90%91%E6%A6%82%E7%8E%87.JPG?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;公式&quot;&gt;&lt;a href=&quot;#公式&quot; class=&quot;headerlink&quot; title=&quot;公式&quot;&gt;&lt;/a&gt;公式&lt;/h2&gt;&lt;p&gt;P(B|A) = P(A|B)*P(B) / P(A)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/Sophia0130/Sophia0130.github.io/blob/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%8F%E7%90%86%E8%A7%A3.jpg?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习（一）——决策树、随机森林</title>
    <link href="http://yoursite.com/2018/12/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%86%B3%E7%AD%96%E6%A0%91%E3%80%81%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"/>
    <id>http://yoursite.com/2018/12/24/机器学习（一）——决策树、随机森林/</id>
    <published>2018-12-24T09:06:38.000Z</published>
    <updated>2018-12-24T11:08:20.271Z</updated>
    
    <content type="html"><![CDATA[<p>PS：决策树这部分我是看了B站上一个博主的教程和西瓜书，感觉这个博主就是按照西瓜书来教学，但是没有涉及太多概率的计算，所以还蛮好理解的   </p><p>根据贷款申请样本这个例子，从数学上去理解熵的意义<br><a id="more"></a></p><p>1.决策树既能解决分类问题又能解决回归问题</p><p>2.两个阶段<br>(1)训练，根据给定训练集 <strong>构造决策树</strong><br>(2)分类，根据决策树各节点的分类属性进行分类</p><p>3.决策树的结构<br><img src="https://github.com/Sophia0130/Sophia0130.github.io/blob/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%86%B3%E7%AD%96%E6%A0%91%E7%BB%93%E6%9E%84.JPG?raw=true" alt=""></p><p><br></p><h2 id="一、构建决策树的关键"><a href="#一、构建决策树的关键" class="headerlink" title="一、构建决策树的关键"></a>一、构建决策树的关键</h2><p>1.问题<br>构建决策树的关键在于如何选择 <strong>节点的划分属性</strong>来划分样本   </p><p>2.解决方法<br>选择 <font color="#f58220"><strong>最优划分属性</strong></font>，即根据该属性分类，得到的分类结果的标签尽可能一样，纯度高，分类精确度高</p><p>后面的计算基于该样本集</p><p><img src="https://github.com/Sophia0130/Sophia0130.github.io/blob/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E4%BE%8B.png?raw=true" alt=""></p><p><br></p><h2 id="二、熵"><a href="#二、熵" class="headerlink" title="二、熵"></a>二、熵</h2><h3 id="1-熵"><a href="#1-熵" class="headerlink" title="1.熵"></a>1.熵</h3><p>(1)自信息：事件的不确定性 ，即事件发生的概率越大，则其不确定性就越小</p><p>(2)信息熵：样本的平均信息量(即样本中包含多个事件)，即衡量样本集合的纯度，内部的混乱程度，不确定性  </p><p><img src="https://github.com/Sophia0130/Sophia0130.github.io/blob/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%86%B5.jpg?raw=true" alt=""></p><h3 id="2-决策树与熵"><a href="#2-决策树与熵" class="headerlink" title="2.决策树与熵"></a>2.决策树与熵</h3><p>构建决策树的关键在于如何选择节点的划分属性</p><p>希望该划分属性满足以下原则<br>(1)随着树深度的增加，节点的熵降低，这样分类的纯度提高<br>(2) <strong>熵降低的速度越快越好</strong>，这样就可以得到高度 <strong>最矮</strong>的决策树</p><p><br></p><h2 id="三、决策树算法"><a href="#三、决策树算法" class="headerlink" title="三、决策树算法"></a>三、决策树算法</h2><p>这三种算法都是为了提高分类结果的纯度，让分类更精确</p><h3 id="1-ID3"><a href="#1-ID3" class="headerlink" title="1.ID3"></a>1.ID3</h3><p>ID3决策树算法，使用 <font color="#f58220"><strong>信息增益</strong></font>作为最优属性的划分原则</p><p>某属性对样本划分后得到的熵，样本未经该属性划分得到的熵，两者之差为信息增益，信息增益越大，表示样本用该属性进行划分后，纯度得到提升的程度大</p><p><img src="https://github.com/Sophia0130/Sophia0130.github.io/blob/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ID3.jpg?raw=true" alt=""></p><h3 id="2-C4-5"><a href="#2-C4-5" class="headerlink" title="2.C4.5"></a>2.C4.5</h3><p>C4.5决策树算法，使用 <font color="#f58220"><strong>信息增益率</strong></font>作为最优属性的划分原则</p><p>C4.5是对ID3的改进，使用信息增益率代替信息增益</p><p>ID3是以信息增益为准则来进行节点属性的选择，该准则存在以下缺点：<br>对于某些特征，特征的属性很多，且每个属性对应的样本数很少，这样就会使得信息增益很大，但是这样的决策树不具有泛化能力</p><p><img src="https://github.com/Sophia0130/Sophia0130.github.io/blob/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/C4.5.jpg?raw=true" alt=""></p><h3 id="3-CART"><a href="#3-CART" class="headerlink" title="3.CART"></a>3.CART</h3><p>CART决策树算法，使用<font color="#f58220"> <strong>基尼指数</strong></font>Gini(D)作为最优属性的划分原则</p><p>基尼指数Gini(D)反映了从数据集D中 <strong>随机抽取两个样本，其类别标记不一致的概率</strong>，因此基尼指数越小，数据集D的纯度越高</p><p><br></p><h2 id="四、剪枝处理"><a href="#四、剪枝处理" class="headerlink" title="四、剪枝处理"></a>四、剪枝处理</h2><p>若决策树高度太高，分支太多，最后可能将所有样本划分为一个，而出现 <strong>过拟合</strong>，所以要进行剪枝</p><h3 id="1-预剪枝"><a href="#1-预剪枝" class="headerlink" title="1.预剪枝"></a>1.预剪枝</h3><p>对每个节点在划分前进行估计，若不满足某些条件，则停止继续划分</p><h3 id="2-后剪枝"><a href="#2-后剪枝" class="headerlink" title="2.后剪枝"></a>2.后剪枝</h3><p>通过一个评价函数，计算某个节点剪枝前和剪枝后的评估分数，以此来确定是否有划分的必要性</p><p><br></p><h2 id="五、随机森林"><a href="#五、随机森林" class="headerlink" title="五、随机森林"></a>五、随机森林</h2><p>1.随机      </p><p>(1)<font color="#f58220"><strong>样本选择</strong></font>的随机性</p><ul><li>样本数量的随机性（可以避免取到异常点)</li><li>有放回的采样 <font color="#f58220"><strong>bootstraping</strong></font></li></ul><p>(2)font color=#f58220&gt; <strong>特征选择</strong>的随机性(可以避免取到异常特征)</p><p>2.森林</p><p>构建多个决策树做分类或回归任务 <font color="#f58220"><strong>bagging</strong></font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：决策树这部分我是看了B站上一个博主的教程和西瓜书，感觉这个博主就是按照西瓜书来教学，但是没有涉及太多概率的计算，所以还蛮好理解的   &lt;/p&gt;
&lt;p&gt;根据贷款申请样本这个例子，从数学上去理解熵的意义&lt;br&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>编译和链接（四）——重定义</title>
    <link href="http://yoursite.com/2018/12/19/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E9%87%8D%E5%AE%9A%E4%B9%89/"/>
    <id>http://yoursite.com/2018/12/19/编译和链接（四）——重定义/</id>
    <published>2018-12-19T12:45:43.000Z</published>
    <updated>2018-12-19T12:47:07.559Z</updated>
    
    <content type="html"><![CDATA[<p>PS：整理重定义之后，我发现最大的问题是之前没有理解预处理、编译、链接，理解编译才是最关键的地方 ~<br><a id="more"></a></p><h2 id="一、头文件中声明或定义函数"><a href="#一、头文件中声明或定义函数" class="headerlink" title="一、头文件中声明或定义函数"></a>一、头文件中声明或定义函数</h2><ol><li>头文件中只声明函数，一个工程下的多个c文件，可以多次包含该头文件</li><li>头文件中定义了函数，一个工程下的多个c文件，就只能包含一次该头文件，不同c文件包含该头文件会出现重定义</li></ol><p><br></p><h2 id="二、预处理与编译"><a href="#二、预处理与编译" class="headerlink" title="二、预处理与编译"></a>二、预处理与编译</h2><p>预处理与编译：<a href="https://github.com/xuelangZF/CS_Offer/blob/master/C%2B%2B/Compiler.md" target="_blank" rel="noopener">https://github.com/xuelangZF/CS_Offer/blob/master/C%2B%2B/Compiler.md</a></p><h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1.预处理"></a>1.预处理</h3><p>预处理器是在程序源文件被编译之前根据预处理指令对程序源文件进行处理，预处理器指令以#号开头标识，末尾不包含分号<br>C/C++提供的预处理功能主要有文件包含、宏替换、条件编译等</p><p>（1）文件包含<br>当使用预处理指令#include引用头文件时，相当于将头文件中所有内容，复制到include处</p><p>（2）宏替换<br>宏替换只作代码字符序列的替换工作，不作任何语法的检查，也不作任何的中间计算<br>宏定义在源文件中必须单独另起一行，换行符是宏定义的结束标志，不需要分号等符号作分隔符<br><strong>续行</strong>是通过 \符号，然后再紧跟回车符号</p><p>（3）条件编译</p><h3 id="2-编译"><a href="#2-编译" class="headerlink" title="2.编译"></a>2.编译</h3><p><strong>编译是对源文件进行编译，而不是对头文件编译，对头文件的处理在预处理时就已完成</strong></p><p><br></p><h2 id="三、重定义与编译和链接"><a href="#三、重定义与编译和链接" class="headerlink" title="三、重定义与编译和链接"></a>三、重定义与编译和链接</h2><p>1.出现重定义的两个条件</p><ul><li><strong>函数定义</strong>放在头文件中</li><li>头文件 <strong>被多个c文件包含</strong></li></ul><p>2.重定义是对目标文件 <strong>链接</strong>时报的错误，与编译无关，只是由于编译两次函数的定义，而导致链接时重定义</p><p>3.<code>#pragma once</code> 或 <code>#ifndef...#define...#endif</code> ，由于头文件嵌套包含，防止同一个c文件里对同一个头文件二次包含、二次编译， <strong>但无法解决重定义</strong> </p><p><br></p><h2 id="四、重定义理解的例子"><a href="#四、重定义理解的例子" class="headerlink" title="四、重定义理解的例子"></a>四、重定义理解的例子</h2><h3 id="情况一：函数声明与函数定义分开，不会出现重定义问题"><a href="#情况一：函数声明与函数定义分开，不会出现重定义问题" class="headerlink" title="情况一：函数声明与函数定义分开，不会出现重定义问题"></a>情况一：函数声明与函数定义分开，不会出现重定义问题</h3><p>func()函数的定义放在func.c，声明放在func.h</p><p>main.c包含 func.h、func1.h、func2.h<br><code>#pragma once；</code>、 <code>#ifndef...#define...#endif</code> 解决重复包含 head.h 的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">================c文件================</span><br><span class="line">//main.c</span><br><span class="line">#include&quot;func1.h&quot;</span><br><span class="line">#include&quot;func2.h&quot;</span><br><span class="line">#include &quot;func.h&quot;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    func1();</span><br><span class="line">    func2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//func1.c</span><br><span class="line">#include &quot;func1.h&quot;</span><br><span class="line"></span><br><span class="line">void func1()</span><br><span class="line">&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//func2.c</span><br><span class="line">#include &quot;func2.h&quot;</span><br><span class="line"></span><br><span class="line">void func2()</span><br><span class="line">&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">================h文件================</span><br><span class="line">//func.h</span><br><span class="line">#ifndef HEAD_H_</span><br><span class="line">#define HEAD_H_</span><br><span class="line"></span><br><span class="line">void func();</span><br><span class="line"></span><br><span class="line"># endif</span><br><span class="line"></span><br><span class="line">//func1.h</span><br><span class="line">#define FUNC1_H_</span><br><span class="line">#ifdef FUNC1_H_</span><br><span class="line"></span><br><span class="line">#include &quot;func.h&quot;</span><br><span class="line"></span><br><span class="line">void func1();</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//func2.h</span><br><span class="line">#define FUNC2_H_</span><br><span class="line">#ifdef FUNC2_H_</span><br><span class="line"></span><br><span class="line">#include &quot;func.h&quot;</span><br><span class="line"></span><br><span class="line">void func2();</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><br></p><h3 id="情况二：函数函数定义放在头文件中，该头文件只在c文件中包含一次，不会出现重定义问题"><a href="#情况二：函数函数定义放在头文件中，该头文件只在c文件中包含一次，不会出现重定义问题" class="headerlink" title="情况二：函数函数定义放在头文件中，该头文件只在c文件中包含一次，不会出现重定义问题"></a>情况二：函数函数定义放在头文件中，该头文件只在c文件中包含一次，不会出现重定义问题</h3><p>func()函数的定义放在func.h</p><p>注意：func.h 只是在 func1.c 中被包含，只被编译了一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">================c文件================</span><br><span class="line">//main.c</span><br><span class="line">#include&quot;func1.h&quot;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    func1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//func1.c</span><br><span class="line">#include &quot;func1.h&quot;</span><br><span class="line">#include &quot;func.h&quot;</span><br><span class="line"></span><br><span class="line">void func1()</span><br><span class="line">&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">================h文件================</span><br><span class="line">//func.h</span><br><span class="line">#ifndef HEAD_H_</span><br><span class="line">#define HEAD_H_</span><br><span class="line"></span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># endif</span><br><span class="line"></span><br><span class="line">//func1.h</span><br><span class="line">#define FUNC1_H_</span><br><span class="line">#ifdef FUNC1_H_</span><br><span class="line"></span><br><span class="line">void func1();</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><br></p><h3 id="情况三：函数函数定义放在头文件中，该头文件在多个c文件中包含，会出现重定义问题"><a href="#情况三：函数函数定义放在头文件中，该头文件在多个c文件中包含，会出现重定义问题" class="headerlink" title="情况三：函数函数定义放在头文件中，该头文件在多个c文件中包含，会出现重定义问题"></a>情况三：函数函数定义放在头文件中，该头文件在多个c文件中包含，会出现重定义问题</h3><p>func()函数的定义放在func.h</p><p>注意：func.h 只是在 func1.h 中被包含，而不是 func1.c中被包含，但是 main.c 中包含了 func1.h，相当于也包含了 func.h</p><p>编译器编译的是c文件<br>编译main.c时由于包含 func1.h，由于 func1.h 中包含了 func.h,则编译了func()函数<br>编译func1.c时由于包含 func1.h，由于 func1.h 中包含了 func.h,则又编译了func()函数<br>编译结束后生成 main.o、func1.o，将两个目标文件链接时，由于存在两个func()函数的定义，就会报重定义的错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">================c文件================</span><br><span class="line">//main.c</span><br><span class="line">#include&quot;func1.h&quot;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    func1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//func1.c</span><br><span class="line">#include &quot;func1.h&quot;</span><br><span class="line"></span><br><span class="line">void func1()</span><br><span class="line">&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">================h文件================</span><br><span class="line">//func.h</span><br><span class="line">#ifndef HEAD_H_</span><br><span class="line">#define HEAD_H_</span><br><span class="line"></span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># endif</span><br><span class="line"></span><br><span class="line">//func1.h</span><br><span class="line">#define FUNC1_H_</span><br><span class="line">#ifdef FUNC1_H_</span><br><span class="line"></span><br><span class="line">#include &quot;func.h&quot;</span><br><span class="line"></span><br><span class="line">void func1();</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><br></p><h2 id="五、重定义与类的内联函数"><a href="#五、重定义与类的内联函数" class="headerlink" title="五、重定义与类的内联函数"></a>五、重定义与类的内联函数</h2><p>类里面定义函数，就是默认内联，不会出现重定义的问题<br>内联函数是用代码膨胀代替函数调用，直接将函数下的代码复制在内联处，不是调用，需要找到一个函数的入口地址</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：整理重定义之后，我发现最大的问题是之前没有理解预处理、编译、链接，理解编译才是最关键的地方 ~&lt;br&gt;
    
    </summary>
    
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>编译和链接（三）——头文件与库</title>
    <link href="http://yoursite.com/2018/12/19/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BA%93/"/>
    <id>http://yoursite.com/2018/12/19/编译和链接（三）——头文件与库/</id>
    <published>2018-12-19T12:44:16.000Z</published>
    <updated>2018-12-19T12:44:44.718Z</updated>
    
    <content type="html"><![CDATA[<p>PS：之前觉得链接库之后一定要有头文件，是因为这个头文件提供了一个函数的入口地址，现在发现，完全理解错了</p><a id="more"></a><p>头文件和库没有什么关系<br>头文件包含在源文件中，是为了在编译时说明源文件中调用的函数存在，而真正链接时，源文件编译生成的目标文件.o与库文件链接，这才实现源文件调用库中的函数</p><p><br></p><h2 id="一、源文件调用源文件下的函数"><a href="#一、源文件调用源文件下的函数" class="headerlink" title="一、源文件调用源文件下的函数"></a>一、源文件调用源文件下的函数</h2><p>先不讨论库，先看一个c文件调用另一个c文件下定义的函数<br>main() 函数调用了 func() 函数，由于 main.c 文件中并没有定义该函数，所以需要有该函数的声明，表明存在该函数，不然编译的时候会报错，下面有两种方式声明该函数</p><h3 id="1-在头文件中声明该函数，源文件包含该头文件"><a href="#1-在头文件中声明该函数，源文件包含该头文件" class="headerlink" title="1.在头文件中声明该函数，源文件包含该头文件"></a>1.在头文件中声明该函数，源文件包含该头文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">===============c文件===============</span><br><span class="line">//main.c</span><br><span class="line">#include &quot;func.h&quot;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//func.c</span><br><span class="line"></span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">    int a=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===============头文件===============</span><br><span class="line">//func.h</span><br><span class="line">void func();</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-在调用该函数的源文件声明该函数"><a href="#2-在调用该函数的源文件声明该函数" class="headerlink" title="2.在调用该函数的源文件声明该函数"></a>2.在调用该函数的源文件声明该函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">===============c文件===============</span><br><span class="line">//main.c</span><br><span class="line">void func();</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//func.c</span><br><span class="line"></span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">    int a=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="二、源文件调用库里的函数"><a href="#二、源文件调用库里的函数" class="headerlink" title="二、源文件调用库里的函数"></a>二、源文件调用库里的函数</h2><p>库函数可以理解为多个源文件编译后生成的目标文件的集合，其实和第一种情况一样<br>源文件包含库的头文件，相当于函数声明，即编译源文件时，表明该库函数存在，不会把报错<br>但链接的时候，还是编译后的源文件与库函数链接，实现函数的调用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：之前觉得链接库之后一定要有头文件，是因为这个头文件提供了一个函数的入口地址，现在发现，完全理解错了&lt;/p&gt;
    
    </summary>
    
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>编译和链接（二）——静态链接和动态链接</title>
    <link href="http://yoursite.com/2018/12/19/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2018/12/19/编译和链接（二）——静态链接和动态链接/</id>
    <published>2018-12-19T12:42:24.000Z</published>
    <updated>2018-12-19T12:43:09.906Z</updated>
    
    <content type="html"><![CDATA[<p>预处理（需要头文件）（.c） -&gt; 编译器将源码转换为汇编代码（.asm） -&gt; 汇编器将汇编代码转换为目标文件，即二进制文件 （.obj）-&gt; 链接器将目标文件和库链接（需要库文件）（.exe）-&gt;运行</p><p><img src="D:\\program\\GitHub\\Hexo\\source\\img\\编译\\过程.jpg" alt=""></p><a id="more"></a><p><br></p><h2 id="一、编译和链接"><a href="#一、编译和链接" class="headerlink" title="一、编译和链接"></a>一、编译和链接</h2><p>编译：只要有头文件中的声明就足够了，头文件只是告诉编译器，函数是如何去调用如何返回</p><p>链接：把已经编译好的.obj和现有的.lib文件进行链接，这时生成可执行文件</p><p><br></p><h2 id="二、头文件和库文件"><a href="#二、头文件和库文件" class="headerlink" title="二、头文件和库文件"></a>二、头文件和库文件</h2><p>头文件：提供声明，编译的时候需要</p><p>库文件：提供定义/实现，链接时将指定的目标文件抽取出</p><p><br></p><h2 id="三、库"><a href="#三、库" class="headerlink" title="三、库"></a>三、库</h2><h3 id="1-lib后缀的库有两种"><a href="#1-lib后缀的库有两种" class="headerlink" title="1. lib后缀的库有两种"></a>1. lib后缀的库有两种</h3><ol><li>静态链接库（.lib）：静态库是一个或者多个obj文件的打包，包含了实际执行代码</li><li>动态链接库的导入库（.lib）：属于动态链接库的附加依赖项，只包含了确保程序找到对应函数的一些基本索引信息</li></ol><p><br></p><h3 id="2-dll后缀的库"><a href="#2-dll后缀的库" class="headerlink" title="2. dll后缀的库"></a>2. dll后缀的库</h3><p>动态链接库（.dll）：是具体的实现，程序运行时动态调用</p><p><br></p><p> n</p><h2 id="四、静态链接"><a href="#四、静态链接" class="headerlink" title="四、静态链接"></a>四、静态链接</h2><h3 id="1-用到的库"><a href="#1-用到的库" class="headerlink" title="1. 用到的库"></a>1. 用到的库</h3><p>静态链接库：（.lib为后缀）是一个或者多个obj文件的打包 ，<strong>『 链接时使用』</strong></p><h3 id="2-静态链接"><a href="#2-静态链接" class="headerlink" title="2. 静态链接"></a>2. 静态链接</h3><p><strong>把.lib文件中用到的函数代码直接链接进可执行文件</strong>，程序运行的时候不再需要其它的库文件</p><h3 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h3><p>程序在运行时与其它库函数无关，用户安装时就不需要再挂动态库，移植方便</p><h3 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4. 缺点"></a>4. 缺点</h3><p>所有相关的目标文件和函数库被链接合成一个可执行文件，当多个程序都调用相同函数时，内存中就会存在这个函数的多个拷贝，浪费空间和资源</p><p><br></p><h2 id="五、动态链接"><a href="#五、动态链接" class="headerlink" title="五、动态链接"></a>五、动态链接</h2><h3 id="1-用到的库-1"><a href="#1-用到的库-1" class="headerlink" title="1. 用到的库"></a>1. 用到的库</h3><ul><li>动态链接库的导入库： （.lib为后缀）属于动态链接库的附加依赖项，一般是一些索引信息，告诉链接器调用的函数在哪个dll中，函数执行代码在dll中的什么位置，<strong>『 链接时使用』</strong></li><li>动态链接库：（.dll为后缀）具体的实现，<strong>『 程序运行时使用』</strong></li></ul><h3 id="2-动态链接"><a href="#2-动态链接" class="headerlink" title="2. 动态链接"></a>2. 动态链接</h3><p>调用的函数代码并没有被拷贝到可执行文件中，仅仅在其中加入了所调用函数的索引信息，只有当应用程序被装入内存开始运行时，在Windows的管理下，才在应用程序与相应的dll之间建立链接关系。</p><h3 id="3-优点-1"><a href="#3-优点-1" class="headerlink" title="3. 优点"></a>3. 优点</h3><p>这样当一个或多个应用程序运行时，才将程序代码和被调用的函数代码链接起来，从而节省了内存资源</p><h3 id="4-缺点-1"><a href="#4-缺点-1" class="headerlink" title="4. 缺点"></a>4. 缺点</h3><p>dll 和 lib 文件必须随应用程序一起发行，否则应用程序将会产生错误</p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;预处理（需要头文件）（.c） -&amp;gt; 编译器将源码转换为汇编代码（.asm） -&amp;gt; 汇编器将汇编代码转换为目标文件，即二进制文件 （.obj）-&amp;gt; 链接器将目标文件和库链接（需要库文件）（.exe）-&amp;gt;运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;D:\\program\\GitHub\\Hexo\\source\\img\\编译\\过程.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>编译和链接（一）——预处理、编译、链接</title>
    <link href="http://yoursite.com/2018/12/19/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E9%A2%84%E5%A4%84%E7%90%86%E3%80%81%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2018/12/19/编译和链接（一）——预处理、编译、链接/</id>
    <published>2018-12-19T12:19:02.000Z</published>
    <updated>2018-12-20T01:21:48.976Z</updated>
    
    <content type="html"><![CDATA[<p>PS：这个博主连载了四篇关于编译、链接的博文，思路很清晰，推荐看原文，我只是用自己的话做了个总结</p><p><a href="https://segmentfault.com/a/1190000016433947" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016433947</a></p><p><img src="https://github.com/Sophia0130/Sophia0130.github.io/blob/master/blog-img-%E7%BC%96%E8%AF%91/%E8%BF%87%E7%A8%8B.jpg?raw=true" alt=""></p><font color="#f58220"><strong>注意：编译包括了使用编译器生成汇编代码，和使用汇编器生成目标文件两部分</strong></font><p>1.编译：将一个源文件转为目标文件<br>2.链接：将多个目标文件之间产生关联</p><a id="more"></a><h2 id="一、预处理"><a href="#一、预处理" class="headerlink" title="一、预处理"></a>一、预处理</h2><p>预处理不对源代码进行解析，主要是 <strong>文本替换</strong>，即展开的过程</p><p>1.文件包含<br>2.宏定义<br>3.条件编译</p><h2 id="一、编译与目标文件"><a href="#一、编译与目标文件" class="headerlink" title="一、编译与目标文件"></a>一、编译与目标文件</h2><h3 id="1-编译"><a href="#1-编译" class="headerlink" title="1.编译"></a>1.编译</h3><p>编译的任务就是将汇编或高级计算机语言源程序转换成目标文件，即机器可以执行的机器指令</p><p>源文件被编译后生成的目标文件可以简单的理解为两部分：</p><p>代码段：源文件中定义的所有函数翻译成机器指令，存放在目标文件的代码部分<br>数据段：源文件中定义的全局变量，存放在目标文件的数据部分<br>（注意：局部变量是函数私有的，所以被放在了代码段中，作为机器指令的操作数）</p><p>在遇到外部定义的全局变量或者函数时 <font color="#f58220"><strong>只要能在当前文件找到其声明</strong></font>，编译器就认为编译正确<br>而寻找使用变量定义的这项任务就被留给了链接器，链接器的其中一项任务就是要确定所使用的变量要有其唯一的定义<br><br></p><h3 id="2-符号表-Symbol-table"><a href="#2-符号表-Symbol-table" class="headerlink" title="2.符号表(Symbol table)"></a>2.符号表(Symbol table)</h3><p>在编译过程中每次遇到一个全局变量或者函数名就会在符号表中添加一项，最终编译器会统计出一张符号表</p><p>符号表中保存的信息有两部分：</p><ul><li>目标文件中引用的全局变量以及函数，仅仅只是声明，未定义</li><li>目标文件中定义的全局变量以及函数</li></ul><p>符号表想表达的两件事：</p><ul><li>我能提供给其它文件使用的符号</li><li>我需要其它文件提供给我使用的符号</li></ul><p>符号表被放在目标文件中<br><br></p><h3 id="3-目标文件"><a href="#3-目标文件" class="headerlink" title="3.目标文件"></a>3.目标文件</h3><p>当前代码中引用，定义在其它源文件中的变量、函数，编译无法确定其内存地址，只有在进行链接时才能够确定这类变量、函数的内存地址</p><p>因此在目标文件中对于这些变量、函数的引用，对应的机器指令可能是:<br><code>call 0x000000</code></p><p>即编译器将不能确定的地址都这设置为空(0x000000)，同时编译器还会生成一条记录，告诉链接器在进行链接时要修正这条指令中的内存地址</p><ul><li>使用外部定义的函数，这个记录就放在了目标文件的.rel.text段中</li><li>使用外部定义的全局变量，则该记录放在了目标文件的.rel.data段中</li></ul><p>即链接器需要在链接过程中根据.rel.data以及.rel.text来填好编译器留下的空白位置(0x000000)</p><p>目标文件的内容如下图：<br><img src="https://image-static.segmentfault.com/340/576/3405765965-5b9f3fc6b5f70" alt=""></p><p><br></p><h2 id="二、链接器"><a href="#二、链接器" class="headerlink" title="二、链接器"></a>二、链接器</h2><h3 id="1-符号表决"><a href="#1-符号表决" class="headerlink" title="1.符号表决"></a>1.符号表决</h3><p>根据编译后得到的目标文件中的符号表，链接器根据所有目表文件进行符号决议，即 <font color="#f58220"><strong>确保所有目标文件中的符号引用都有唯一的定义</strong></font></p><p>1.对于当前目标文件，查找其符号表，并将已定义的符号并添加到已定义符号集合D中<br>2.对于当前目标文件，查找其符号表，将每一个当前目标文件引用的符号与已定义符号集合D进行对比，如果该符号不在集合D中则将其添加到未定义符合集合U中<br>3.当所有文件都扫描完成后，如果 <strong>未定义符号集合U不为空</strong>，则说明当前输入的目标文件集合中有未定义错误，链接器报错，整个编译过程终止<br><br></p><h3 id="2-重定位"><a href="#2-重定位" class="headerlink" title="2.重定位"></a>2.重定位</h3><p>PS：以下关于重定义的分析， <font color="#f58220"><strong>仅限于静态链接</strong></font>，该情况下，代码和数据都合并到可执行文件中，因此需要确定代码和数据的最终位置</p><p>编译时，无法确定，定义在其它源文件中的变量、函数的内存地址<br>链接时，才能确定可执行文件中代码和数据运行时的内存地址</p><p>确定程序运行时地址的过程就是重定位，重定位分为两步：</p><p>1.链接时，需要对所有目标文件的数据段和代码段的内存地址进行修正，编译得到的目标文件得到的只是相对地址<br>2.链接器扫描所有的.rel.text以及.rel.data段并找到相应记录的最终内存地址，并将机器指令中的<code>0x000000</code>修正为最终内存地址</p><p>PS：最后那个博主提出了一个问题，如果运行两次可执行文件，会不会出现内存内存占用的问题，而两个程序之间产生影响</p><p>回答肯定是不会的，从 <strong>操作系统</strong>层面来解释，从<font color="#f58220"><strong>虚拟内存里面看到的内存地址是一样的</strong></font>，但是物理地址不可能一样</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：这个博主连载了四篇关于编译、链接的博文，思路很清晰，推荐看原文，我只是用自己的话做了个总结&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000016433947&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000016433947&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/Sophia0130/Sophia0130.github.io/blob/master/blog-img-%E7%BC%96%E8%AF%91/%E8%BF%87%E7%A8%8B.jpg?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;font color=&quot;#f58220&quot;&gt;&lt;strong&gt;注意：编译包括了使用编译器生成汇编代码，和使用汇编器生成目标文件两部分&lt;/strong&gt;&lt;/font&gt;

&lt;p&gt;1.编译：将一个源文件转为目标文件&lt;br&gt;2.链接：将多个目标文件之间产生关联&lt;/p&gt;
    
    </summary>
    
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux（六）——进程调度</title>
    <link href="http://yoursite.com/2018/12/17/Linux%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    <id>http://yoursite.com/2018/12/17/Linux（六）——进程调度/</id>
    <published>2018-12-17T08:34:34.000Z</published>
    <updated>2018-12-17T08:44:52.829Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：</p><p><a href="https://blog.csdn.net/qq_32811489/article/details/70768264" target="_blank" rel="noopener">https://blog.csdn.net/qq_32811489/article/details/70768264</a></p><a id="more"></a><h2 id="linux内核的三种调度方法"><a href="#linux内核的三种调度方法" class="headerlink" title="linux内核的三种调度方法"></a>linux内核的三种调度方法</h2><p>1.SCHED_OTHER<br>分时调度策略</p><p>2.SCHED_FIFO 实时调度策略，先到先服务，一旦占用cpu则一直运行，直到有更高优先级任务到达或自己放弃 </p><p>3.SCHED_RR<br>实时调度策略，时间片轮转，当进程的时间片用完，系统将重新分配时间片，并置于就绪队列尾，保证了所有具有相同优先级的RR任务的 <strong>调度公平</strong></p><p>实时进程：得到优先调用，实时进程根据 <strong>实时优先级</strong>决定调度权值<br>分时进程：曾经使用cpu最少的进程将会得到优先调度</p><p><br></p><h2 id="既有分时调度，又有时间片轮转调度和先进先出调度"><a href="#既有分时调度，又有时间片轮转调度和先进先出调度" class="headerlink" title="既有分时调度，又有时间片轮转调度和先进先出调度"></a>既有分时调度，又有时间片轮转调度和先进先出调度</h2><p>1.当实时进程准备就绪，如果当前cpu正运行非实时进程，则 <strong>实时进程立即抢占非实时进程</strong></p><p>2.RR进程和FIFO进程都采用实时优先级做为调度的权值</p><p>3.对于FIFO，如果两个进程的优先级一样，则这两个优级一样的进程具体执行哪一个是由其在队列中的位置决定的，这样导致一些不公正性</p><p>4.对于RR，两个优先级一样的任务可以循环执行，保证了公平</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_32811489/article/details/70768264&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_32811489/article/details/70768264&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Dlib 目标检测源码解析</title>
    <link href="http://yoursite.com/2018/12/12/Dlib-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/12/12/Dlib-目标检测源码解析/</id>
    <published>2018-12-12T13:39:46.000Z</published>
    <updated>2018-12-12T13:39:46.300Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Debug、Release版本下 多线程问题</title>
    <link href="http://yoursite.com/2018/11/28/Debug%E3%80%81Release%E7%89%88%E6%9C%AC%E4%B8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/11/28/Debug、Release版本下-多线程问题/</id>
    <published>2018-11-28T09:16:44.000Z</published>
    <updated>2018-11-29T06:21:57.693Z</updated>
    
    <content type="html"><![CDATA[<p>PS：今天做项目的时候，开多线程测试，遇到了一个奇怪的问题，到现在都没有办法解释～<br><a id="more"></a>      </p><p>多线程在Debug版本下的cout部分会正常输出   </p><p>多线程在Release版本下的cout部分似乎受到了阻塞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//开了四个线程</span><br><span class="line">while(times&lt;4) &#123;&#125;;  //保证4个线程运行完进行cout</span><br><span class="line">//其它代码</span><br><span class="line">//cout部分</span><br></pre></td></tr></table></figure><p>Release版本的代码改为以下形式，while里加cout，所有cout部分就都能正常输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//开了四个线程</span><br><span class="line">while(tims&lt;4) &#123;cout&lt;&lt;&quot;&quot;;&#125;       //保证4个线程运行完进行cout</span><br><span class="line">//其它代码</span><br><span class="line">//cout部分</span><br></pre></td></tr></table></figure><p><br><br>很服气，到底cout、while、Release是什么关系</p><hr><p>更新问题：</p><p>哇，真的超级崇拜我家Uncle D，晚上他试了几次，就找到问题所在，其实是 <strong>Release优化</strong>的问题 </p><p>（1）首先，这个和cout无关，之前觉得是cout多线程缓存区刷新的问题，后来发现不论将后面的代码改为printf还是文件输出都没有反应</p><p>（2）其次，这个问题和Release优化相关，将VS项目属性里C/C++下的优化改为禁用，while后面部分就能正常执行</p><p>（3）接着，解释为什么while后面的代码不执行，因为编译器觉得当前线程中times只加1次，所以times不能加到4，while是个死循环，所以while后的代码不执行</p><p>（4）最后，解释为什么在while的循环体内使用cin、cout、printf这些输入输出流，就能跨过while，因为输入输出能够 <strong>触发中断</strong>，这个时候while循环就不会被优化掉</p><p>最后的最后，他说是我程序写的有问题，因为我将times定义为全局，在每个线程结束处进行times++，编译器会觉得times加不到4，用 for和 <code>pthread_join()</code> 等待线程结束，不用while去等待所有线程结束</p><p>怎么办，现在越来越崇拜Uncle D了，无法自拔的痴迷 ~<br>现在发展到，他在旁边报代码，我来写的地步了，这样不好，我得自己思考 ~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：今天做项目的时候，开多线程测试，遇到了一个奇怪的问题，到现在都没有办法解释～&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dlib中imglab生成失败的解决方法</title>
    <link href="http://yoursite.com/2018/11/19/Dlib%E4%B8%ADimglab%E7%94%9F%E6%88%90%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/11/19/Dlib中imglab生成失败的解决方法/</id>
    <published>2018-11-19T01:12:46.000Z</published>
    <updated>2018-11-19T01:38:11.543Z</updated>
    
    <content type="html"><![CDATA[<p>PS：花了一个晚上才把imglab这个标注工具生成失败的问题解决，哎，我真的太木了<br><a id="more"></a></p><h2 id="1-问题所在"><a href="#1-问题所在" class="headerlink" title="1.问题所在"></a>1.问题所在</h2><p><code>dlib\image_saver</code> 下的头文件 <code>save_png.h</code> 出现 Assertion Failed<br>可以看到作者在 <code>#ifndef DLIB_PNG_SUPPORT</code> 下其实打了超多感叹号的注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You are getting this error because you are trying to use save_png() but you haven&apos;t defined DLIB_PNG_SUPPORT.  You must do so to use this function. You must also make sure you set your build environment to link against the libpng library.</span><br></pre></td></tr></table></figure></p><p><br></p><h2 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h2><p>解决方法很简单，我开始还在研究是不是要配置第三方库libpng和zlib的环境<br>其实只要在imglab主函数里声明<br> <code>#define DLIB_PNG_SUPPORT</code> 和 <code>#define DLIB_JPEG_SUPPORT</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：花了一个晚上才把imglab这个标注工具生成失败的问题解决，哎，我真的太木了&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C++学习：多线程</title>
    <link href="http://yoursite.com/2018/11/08/C-%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/11/08/C-学习：多线程/</id>
    <published>2018-11-08T13:09:22.000Z</published>
    <updated>2018-11-08T13:09:41.141Z</updated>
    
    <content type="html"><![CDATA[<p>PS：真的好难啊，看不懂，有没有什么多线程的资料可以系统读一下，完全云里雾里啊~<br><a id="more"></a></p><h2 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h2><p>POSIX 可移植操作系统接口（Portable Operating System Interface of UNIX ）是为了各操作系统间保持兼容性而制定的系列标准，POSIX并不局限于UNIX</p><p>个人理解：应用程序接口 API（Application Programming Interface）是操作系统提供给应用程序调用的代码，POSIX标准就是规范了不同操作系统的API。<strong>这样，为一个POSIX兼容的操作系统编写的应用程序，应该可以在任何其它的POSIX操作系统上编译执行</strong>。<br><br></p><h2 id="POSIX线程"><a href="#POSIX线程" class="headerlink" title="POSIX线程"></a>POSIX线程</h2><p>POSIX线程（POSIX Threads，Pthreads）是POSIX的线程标准，定义了创建和操纵线程的一套API<br>创建线程之后，由CPU决定何时执行线程调用的函数<br><br>   </p><h2 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h2><p><a href="https://www.cnblogs.com/xh0102/p/5710074.html" target="_blank" rel="noopener">https://www.cnblogs.com/xh0102/p/5710074.html</a><br>1.进程<br>每个进程有自己的地址空间。<strong>两个进程中的地址即使值相同，实际指向的位置也不同。</strong>进程间通信一般 <strong>通过操作系统</strong>的公共区进行。<br>2.线程<br>同一进程中的线程属于同一地址空间，<strong>共享全局变量和内存</strong>，所以一个线程的数据可以直接提供给其他线程使用，而 <strong>不必通过操作系统</strong>，也就是内核的调度。<br><br></p><h2 id="并行、并发"><a href="#并行、并发" class="headerlink" title="并行、并发"></a>并行、并发</h2><p>1.并行<br>是指两个或多个独立的操作同时进行。对于多核，多个线程可以在多核上真正独立的并行执行。<br>2.并发<br>是指在一段时间内执行多个操作。对于单核，多个线程是并发的，在一个时间段内轮流执行。<br>例如，4核4线程可以并行4个线程，4核8线程则使用了超线程技术，把一个物理核模拟为2个逻辑核心，可以并行8个线程。<br><br></p><h2 id="可结合和分离的线程"><a href="#可结合和分离的线程" class="headerlink" title="可结合和分离的线程"></a>可结合和分离的线程</h2><p>线程可结合或可分离是属于内核的属性，决定一个线程以什么样的方式来终止自己<br>1.joinable 可结合，非分离状态<br><strong>需要被其他线程收回其资源和杀死</strong>，在被其他线程回收之前，它的存储器资源是不释放的<br>原有的线程等待创建的线程结束，只有当pthread_join（）函数返回时，创建的线程才算终止，才能释放创建的线程占用的系统资源       </p><ol start="2"><li>detached 分离线程<br>一个分离的线程没有被其他的线程所等待，<strong>不能被其他线程回收或杀死</strong>，等到运行结束，线程也就终止，才释放系统资源<br><br></li></ol><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><p>线程通信基本问题是同步和互斥<br>1.线程同步<br>一个线程的执行依赖于另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒<br>线程同步的四种方法：<a href="https://blog.csdn.net/zm_jacker/article/details/9787829" target="_blank" rel="noopener">https://blog.csdn.net/zm_jacker/article/details/9787829</a><br>2.线程互斥<br>当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源<br>同步其实已经实现了互斥，而互斥是一种特殊的同步<br><br></p><h2 id="临界资源、临界区"><a href="#临界资源、临界区" class="headerlink" title="临界资源、临界区"></a>临界资源、临界区</h2><p>临界资源：能够被多个线程共享的数据<br>临界区：对临界资源进行操作的那一段代码<br><br></p><h2 id="互斥锁-互斥锁（mutual-exclusive-lock-variable-mutex-）"><a href="#互斥锁-互斥锁（mutual-exclusive-lock-variable-mutex-）" class="headerlink" title="互斥锁/互斥锁（mutual exclusive lock variable / mutex ）"></a>互斥锁/互斥锁（mutual exclusive lock variable / mutex ）</h2><p>在访问共享资源前对互斥量加锁，在访问完成后释放互斥量上的锁。对互斥量加锁以后，任何其他试图对互斥量加锁的线程将会阻塞，直到当前线程释放该互斥锁。<br>如果释放互斥锁时有多个线程阻塞，所有在该互斥锁上的阻塞线程都会变成可运行状态，第一个变为运行状态的线程可以对互斥锁加锁，其他线程将会看到互斥锁依然被锁住，只能回去再次等待它重新变为可用。<br>个人理解：互斥量和互斥锁是一个意思<br><br></p><h2 id="条件变量和互斥锁"><a href="#条件变量和互斥锁" class="headerlink" title="条件变量和互斥锁"></a>条件变量和互斥锁</h2><p>条件变量是和互斥锁搭配使用<br>线程A需要等某个条件成立才能继续往下执行，现在这个条件不成立，线程A就阻塞等待，而线程B在执行过程中使这个条件成立了，就唤醒线程A继续执行<br><br></p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量强调的是多线程的同步，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作<br><br></p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p><strong>原子操作是CPU执行指令的最小单元</strong>，这种操作一旦开始，就一直运行到结束，不会被中断<br>能够在单条指令中完成的操作都可以认为是原子操作</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：真的好难啊，看不懂，有没有什么多线程的资料可以系统读一下，完全云里雾里啊~&lt;br&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>cs144:1-1</title>
    <link href="http://yoursite.com/2018/10/29/cs144-1-1/"/>
    <id>http://yoursite.com/2018/10/29/cs144-1-1/</id>
    <published>2018-10-29T09:20:55.000Z</published>
    <updated>2018-10-29T09:22:39.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p><img src="http://phcnyb3sl.bkt.clouddn.com/summary.png" alt=""></p><ul><li>模型：Bidirectional byte stream</li><li>模型的三种应用：<ul><li>World Wide Web(HTTP)</li><li>Skype</li><li>BitTorrent</li></ul></li></ul><a id="more"></a><p><br></p><h2 id="1-Bidirectional-byte-stream"><a href="#1-Bidirectional-byte-stream" class="headerlink" title="1. Bidirectional byte stream"></a>1. Bidirectional byte stream</h2><p>The most common communication model of networked applications.</p><p>This allows two programs running on different computers exchange data.</p><p>将网络抽象A和B之间双向的读/写</p><p><img src="http://phcnyb3sl.bkt.clouddn.com/bytestreammodel.png" alt=""></p><p><br></p><h2 id="2-1-World-Wide-Web"><a href="#2-1-World-Wide-Web" class="headerlink" title="2-1 World Wide Web"></a>2-1 World Wide Web</h2><p><img src="http://phcnyb3sl.bkt.clouddn.com/http.png" alt=""></p><p><strong>client-server model    客户端-服务端</strong> </p><p>Client open connection to a server and requests <strong>documents</strong>.</p><p>Server responses documents.</p><p><br></p><h2 id="2-2-BitTorrent"><a href="#2-2-BitTorrent" class="headerlink" title="2-2 BitTorrent"></a>2-2 BitTorrent</h2><p><img src="http://phcnyb3sl.bkt.clouddn.com/bittorrent.png" alt=""></p><p><strong>peer-to-peer model</strong></p><p>Swarms of clients open connections to each other to exchange pieces of data.</p><p>A single client can request from many other clients in parallel.</p><p>每个客户端拥有文件的 <strong>piece</strong> 即一部分，这些客户端形成了<strong>swarms</strong> 即集群，客户端可以选择加入或退出这个 swarm</p><p>客户端要load file时，向Tracker请求拥有piece的client lists客户列表，从各客户端load piece，且是个并发的过程</p><p><br></p><h2 id="2-3-Skype"><a href="#2-3-Skype" class="headerlink" title="2-3 Skype"></a>2-3 Skype</h2><p>Clients can`t open connections directly, so go through Rendezvous or Relay server.</p><p>NAT:Network Address Translator</p><p>个人理解：NAT是个单向的过程，所以需要 reverse connection</p><p>正常情况下，A try to open connection to B，但是由于B在NAT后面，B无法通过NAT回发信息给A，实际上是B open connection to A</p><p>通常，public server 不会在NAT后面，但是 personal machine 为了安全，所以需要NAT</p><p> <img src="http://phcnyb3sl.bkt.clouddn.com/skpye1.png" alt=""></p><p><img src="http://phcnyb3sl.bkt.clouddn.com/skype2.png" alt=""></p><p><br></p><h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><p>互联网包含因特网，因特网包含万维网</p><p><br></p><h3 id="1-互联网"><a href="#1-互联网" class="headerlink" title="1. 互联网"></a>1. 互联网</h3><p>凡是能彼此通信的设备组成的网络就叫互联网</p><p><br></p><h3 id="2-Internet-因特网"><a href="#2-Internet-因特网" class="headerlink" title="2. Internet 因特网"></a>2. Internet 因特网</h3><p><strong>基于TCP/IP协议</strong>让不同的设备可以彼此通信。但使用TCP/IP协议的网络并不一定是因特网，一个局域网也可以使用TCP/IP协议。</p><p>TCP/IP协议由很多协议组成，不同类型的协议又被放在不同的层，其中，位于应用层的协议就有很多，比如FTP、SMTP、HTTP。只要<strong>应用层使用的是HTTP协议，就称为万维网</strong>。</p><p>Internet 提供的主要服务有万维网（WWW）、文件传输（FTP）、电子邮件（E-mail）、远程登录（Telnet）、手机 (3GHZ) 等。</p><p><br></p><h3 id="3-www万维网"><a href="#3-www万维网" class="headerlink" title="3. www万维网"></a>3. www万维网</h3><p>浏览器通过超文本传输协议(HTTP)，将Web服务器上站点的网页代码HTML提取出来，并翻译成网页。</p><p>URL （Uniform Resource Locator，统一资源定位符）：<a href="http://www.microsoft.com/china/index.htm" target="_blank" rel="noopener">http://www.microsoft.com/china/index.htm</a></p><ol><li>http://：超文本传输协议，通常不用输入</li><li>www：一个万维网服务器</li><li>Microsoft.com/：站点服务器的名称</li><li>China/：该服务器上的子目录</li><li>Index.htm：该子目录下的一个HTML文件，HTML语言描述的文件，需要通过www浏览器显示效果</li></ol><p><br></p><p>PS：万维网与因特网的差别，因特网指的是一个硬件的网络，全球的所有电脑通过网络连接后便形成了因特网，而万维网更倾向于一种浏览网页的功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Summary&quot;&gt;&lt;a href=&quot;#Summary&quot; class=&quot;headerlink&quot; title=&quot;Summary&quot;&gt;&lt;/a&gt;Summary&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://phcnyb3sl.bkt.clouddn.com/summary.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模型：Bidirectional byte stream&lt;/li&gt;
&lt;li&gt;模型的三种应用：&lt;ul&gt;
&lt;li&gt;World Wide Web(HTTP)&lt;/li&gt;
&lt;li&gt;Skype&lt;/li&gt;
&lt;li&gt;BitTorrent&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="cs144" scheme="http://yoursite.com/tags/cs144/"/>
    
  </entry>
  
  <entry>
    <title>[置顶]目录检索</title>
    <link href="http://yoursite.com/2018/10/25/%E7%BD%AE%E9%A1%B6-%E7%9B%AE%E5%BD%95%E6%A3%80%E7%B4%A2/"/>
    <id>http://yoursite.com/2018/10/25/置顶-目录检索/</id>
    <published>2018-10-25T01:17:52.000Z</published>
    <updated>2018-10-25T05:32:18.458Z</updated>
    
    <content type="html"><![CDATA[<p>[置顶]检索目录列表</p><a id="more"></a><p><br></p><h2 id="opencv"><a href="#opencv" class="headerlink" title="opencv"></a>opencv</h2><p><a href="https://sophia0130.github.io/2018/05/07/ImageWatch/" target="_blank" rel="noopener">ImageWatch — VS编译小工具</a></p><p>opencv（一）~（六）学习笔记系列 （PS：其实写了很多功能的代码，但是最近实在没有时间整理）</p><p><br></p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>贝叶斯分类器和概率图模型</p><p><a href="https://sophia0130.github.io/2018/05/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%A4%A7%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">机器学习算法大总结</a></p><p><br></p><h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><p><a href="https://sophia0130.github.io/2018/06/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">深度学习与强化学习</a></p><p>Deep-Learning—吴恩达—作业（一）~（七）系列</p><p><br></p><h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><p>1.cs231n笔记（一）~（十一）系列</p><ul><li>线性回归、逻辑回归、多分类</li><li>最优化（Optimization）：最小化损失函数</li><li>反向传播：链式法则求梯度</li><li>深度学习框架：PyTorch（Facebook）、Tensorflow（Google）</li><li>分类、检测、分割、跟踪</li><li>反卷积与特征可视化</li></ul><p>不同种类的网络：</p><ul><li>神经网络</li><li>卷积神经网络</li><li>经典CNN网络</li><li>循环神经网络</li><li>生成式对抗网络</li></ul><p>2.<a href="https://sophia0130.github.io/2018/08/01/NLP%E2%80%94%E2%80%94word2vec/" target="_blank" rel="noopener">NLP——word2vec</a> （PS：了解了一下自然语言处理，果然比图像要难啊 ~）</p><p><br></p><h2 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h2><p><a href="https://sophia0130.github.io/2018/08/05/TensorFlow-%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">TensorFlow 使用总结</a></p><p><a href="https://sophia0130.github.io/2018/08/05/Tensorboard-%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">Tensorboard 使用总结</a></p><p>TensorFlow代码实现（一）~（四）系列</p><p><br></p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>ubuntu（一）~？    </p><p>Linux（一）~？</p><p>CMake（一）~？</p><p><br></p><h2 id="python安装"><a href="#python安装" class="headerlink" title="python安装"></a>python安装</h2><p><a href="https://sophia0130.github.io/2018/06/13/anaconda%EF%BC%8Cconda%EF%BC%8Cpip%E7%9A%84%E5%85%B3%E7%B3%BB/" target="_blank" rel="noopener">anaconda，conda，pip的关系</a></p><p><a href="https://sophia0130.github.io/2018/07/29/Ipython-%E4%B8%8E-Jupyter-Notebook/" target="_blank" rel="noopener">Ipython 与 Jupyter Notebook</a></p><p><a href="https://sophia0130.github.io/2018/06/28/%E8%A7%A3%E5%86%B3pip%E5%AE%89%E8%A3%85%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">解决pip安装慢的问题</a></p><p><br></p><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p><a href="https://sophia0130.github.io/2018/07/14/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/" target="_blank" rel="noopener">《程序是怎样跑起来的》读书笔记</a></p><p><a href="https://sophia0130.github.io/2018/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%90%84%E7%A7%8D%E6%9D%BF%E5%AD%90/" target="_blank" rel="noopener">嵌入式与板子：MCU、ARM、DSP、FPGA、SOC</a></p><p><a href="https://sophia0130.github.io/2018/07/15/%E6%98%BE%E5%8D%A1/" target="_blank" rel="noopener">显卡</a></p><p><a href="https://sophia0130.github.io/2018/07/26/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">进程和线程</a></p><p><br></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><a href="https://sophia0130.github.io/2018/08/22/%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%81%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%81IDE/" target="_blank" rel="noopener">编译器、IDE、编辑器种类整理</a></p><p><a href="https://sophia0130.github.io/2018/05/04/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/" target="_blank" rel="noopener">编译器和解释器</a></p><p>CMake（一）~？</p><p><br></p><h2 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h2><p>剑指offer（一）~？持续更</p><p><br></p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p><a href="https://sophia0130.github.io/2018/05/14/XML%E3%80%81YAML%E3%80%81JSON/" target="_blank" rel="noopener">序列化数据格式 ：xml、yaml、json</a></p><p><a href="https://sophia0130.github.io/2018/05/18/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%BA%91-%E7%89%B9%E5%88%AB%E7%AE%80%E9%99%8B%E7%9A%84%E8%AE%A4%E8%AF%86/" target="_blank" rel="noopener">虚拟机和云</a></p><p><a href="https://sophia0130.github.io/2018/05/04/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%90%86%E8%A7%A3/" target="_blank" rel="noopener">网络基础知识</a></p><p><br></p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p><a href="https://sophia0130.github.io/2018/06/01/Git-%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">Git学习笔记</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[置顶]检索目录列表&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[置顶]分享</title>
    <link href="http://yoursite.com/2018/10/25/%E7%BD%AE%E9%A1%B6-%E5%88%86%E4%BA%AB/"/>
    <id>http://yoursite.com/2018/10/25/置顶-分享/</id>
    <published>2018-10-25T01:14:56.000Z</published>
    <updated>2018-12-08T09:15:21.788Z</updated>
    
    <content type="html"><![CDATA[<p>[置顶] 书单分享和大神的博客分享</p><a id="more"></a><p><br></p><h2 id="一、书单"><a href="#一、书单" class="headerlink" title="一、书单"></a>一、书单</h2><h3 id="数据结构与算法："><a href="#数据结构与算法：" class="headerlink" title="数据结构与算法："></a>数据结构与算法：</h3><ul><li><p>《数据结构与算法C语言版本》</p></li><li><p>《大话数据结构》</p></li></ul><p><br></p><h3 id="C-："><a href="#C-：" class="headerlink" title="C++："></a>C++：</h3><ul><li><p>《C++primer》</p></li><li><p>《effective C++》</p></li><li><p>《深度探索C++对象模型》</p></li></ul><p><br></p><h3 id="计算机："><a href="#计算机：" class="headerlink" title="计算机："></a>计算机：</h3><ul><li><p>《计算机程序的构造和解释（SICP）》</p></li><li><p>《程序员的自我修养——链接、装载与库》</p></li><li><p>《程序是怎样跑起来的》</p></li><li><p>《黑客与画家》</p></li></ul><p><br></p><h2 id="机器学习："><a href="#机器学习：" class="headerlink" title="机器学习："></a>机器学习：</h2><p>《机器学习》</p><p><br></p><h2 id="深度学习："><a href="#深度学习：" class="headerlink" title="深度学习："></a>深度学习：</h2><p>《深度学习500问》GitHub 上：<a href="https://github.com/scutan90" target="_blank" rel="noopener">https://github.com/scutan90</a></p><p><br></p><h2 id="通信网络"><a href="#通信网络" class="headerlink" title="通信网络"></a>通信网络</h2><p>《网络是怎样连接的》</p><p><br></p><h2 id="二、大神-Blog"><a href="#二、大神-Blog" class="headerlink" title="二、大神 Blog"></a>二、大神 Blog</h2><p>邹欣：<a href="https://www.cnblogs.com/xinz/" target="_blank" rel="noopener">https://www.cnblogs.com/xinz/</a> （师兄推荐给我的，对于怎么做工程蛮有帮助的）</p><p>莫烦：<a href="https://morvanzhou.github.io/" target="_blank" rel="noopener">https://morvanzhou.github.io/</a> （深度学习实战使用各种框架的入门教程）</p><p>鸟哥：<a href="http://cn.linux.vbird.org/linux_basic/linux_basic.php" target="_blank" rel="noopener">http://cn.linux.vbird.org/linux_basic/linux_basic.php</a> （为什么要叫这么个名字，Linux 学习）</p><p><br></p><h2 id="三、学习笔记"><a href="#三、学习笔记" class="headerlink" title="三、学习笔记"></a>三、学习笔记</h2><p>吴恩达机器学习课程笔记：</p><p><a href="https://www.cnblogs.com/llhthinker/tag/Machine%20Learning/" target="_blank" rel="noopener">https://www.cnblogs.com/llhthinker/tag/Machine%20Learning/</a></p><p><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener">https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes</a></p><p>吴恩达深度学习课程笔记：</p><p><a href="https://blog.csdn.net/koala_tree/article/details/79913655" target="_blank" rel="noopener">https://blog.csdn.net/koala_tree/article/details/79913655</a></p><p><a href="http://kyonhuang.top/Andrew-Ng-Deep-Learning-notes/#/Convolutional_Neural_Networks/%E6%B7%B1%E5%BA%A6%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C%EF%BC%9A%E5%AE%9E%E4%BE%8B%E6%8E%A2%E7%A9%B6" target="_blank" rel="noopener">http://kyonhuang.top/Andrew-Ng-Deep-Learning-notes/#/Convolutional_Neural_Networks/%E6%B7%B1%E5%BA%A6%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C%EF%BC%9A%E5%AE%9E%E4%BE%8B%E6%8E%A2%E7%A9%B6</a></p><p>cs231n课程笔记：</p><p><a href="https://zhuanlan.zhihu.com/p/21930884" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21930884</a></p><p>作业 <a href="https://github.com/Halfish/cs231n" target="_blank" rel="noopener">https://github.com/Halfish/cs231n</a></p><p>机器学习：</p><p><a href="https://feisky.xyz/machine-learning/" target="_blank" rel="noopener">https://feisky.xyz/machine-learning/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[置顶] 书单分享和大神的博客分享&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>win10+VS2013+Dlib 安装配置</title>
    <link href="http://yoursite.com/2018/10/22/win10-VS2013-Dlib-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/10/22/win10-VS2013-Dlib-安装配置/</id>
    <published>2018-10-22T13:55:40.000Z</published>
    <updated>2018-12-04T01:43:08.534Z</updated>
    
    <content type="html"><![CDATA[<p>PS：我下载的是19.0版本（19.2及以上版本需用vs2015或更高版本）</p><p>（这是之前的Dlib版本：<a href="http://dlib.net/files/" target="_blank" rel="noopener">http://dlib.net/files/</a> ）</p><p>PS：最近移一直被一个问题困惑，Dlib是不依赖于其他库（自带图像编解码库源码），所以直接包含头文件即可，为什么要编译Dlib库，这个Dlib.lib到底有什么用？</p><a id="more"></a><p><br></p><h1 id="一、Cmake-生成-dlib-lib文件"><a href="#一、Cmake-生成-dlib-lib文件" class="headerlink" title="一、Cmake 生成 dlib.lib文件"></a>一、Cmake 生成 dlib.lib文件</h1><h3 id="1-cmake-转-VS-工程"><a href="#1-cmake-转-VS-工程" class="headerlink" title="1. cmake 转 VS 工程"></a>1. cmake 转 VS 工程</h3><p>（1）点击configure，选择 Visual Studio 12 2013 Win64、Visual Studio 12 2013 </p><p><strong>注意：这里的平台和以后用的平台要一致</strong></p><p>PS：之前用的是 Visual Studio 12 2013 Win64  后编译生成 dlib.lib 添加到 Win32 平台就一直报错</p><p>（2）选择Genarate</p><p><br></p><h3 id="2-VS2013编译生成-dlib-lib"><a href="#2-VS2013编译生成-dlib-lib" class="headerlink" title="2. VS2013编译生成 dlib.lib"></a>2. VS2013编译生成 dlib.lib</h3><p>（1）build 文件夹下生成 .sln 解决方案，打开解决方案</p><p>（2）切换 vs2013 的平台至 debug 或 release模式</p><p>（3）找到AllBuild工程右击生成，Debug 文件下会生成dlib.lib</p><p>注意：生成之前，检查dlib项目中的属性配置，参考这篇博文：</p><p><a href="https://blog.csdn.net/Dawnfox/article/details/77282246?utm_source=blogxgwz1" target="_blank" rel="noopener">https://blog.csdn.net/Dawnfox/article/details/77282246?utm_source=blogxgwz1</a></p><p><strong>注意：这里有一个坑，到后面才发现，自己建工程，添加lib后，一直报“Runtime Library”的不匹配项，就是因为，生成dlib.lib时候，dlib 项目中的属性配置中的代码生成运行库需要改，我改成了MTd</strong></p><p>大型项目中必须要求所有组件和第三方库的运行时库是统一的，否则将会出现LNK2005井喷</p><p><br></p><p>注意点：（！！真的要注意，很重要！！）</p><ul><li><strong>cmake 的平台 x64 还是 win32</strong></li><li><strong>编译时的模式 Debug 还是 Release</strong></li><li><strong>链接的 Runtime Library</strong> </li></ul><p>我今天突然对上面有了不一样的领悟</p><p><br></p><h2 id="二、属性配置"><a href="#二、属性配置" class="headerlink" title="二、属性配置"></a>二、属性配置</h2><p>属性配置，验证dlib.lib可用性，完全按照下面这篇博文：</p><p><a href="https://blog.csdn.net/Dawnfox/article/details/77282246?utm_source=blogxgwz1" target="_blank" rel="noopener">https://blog.csdn.net/Dawnfox/article/details/77282246?utm_source=blogxgwz1</a></p><p><br></p><h2 id="三、使用dlib的imglab工具标注数据集"><a href="#三、使用dlib的imglab工具标注数据集" class="headerlink" title="三、使用dlib的imglab工具标注数据集"></a>三、使用dlib的imglab工具标注数据集</h2><p>不知道为什么win10下这个工具编译不成功，只好到虚拟机ubuntu上编译</p><p><a href="https://blog.csdn.net/qq_15715657/article/details/81504253" target="_blank" rel="noopener">https://blog.csdn.net/qq_15715657/article/details/81504253</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：我下载的是19.0版本（19.2及以上版本需用vs2015或更高版本）&lt;/p&gt;
&lt;p&gt;（这是之前的Dlib版本：&lt;a href=&quot;http://dlib.net/files/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://dlib.net/files/&lt;/a&gt; ）&lt;/p&gt;
&lt;p&gt;PS：最近移一直被一个问题困惑，Dlib是不依赖于其他库（自带图像编解码库源码），所以直接包含头文件即可，为什么要编译Dlib库，这个Dlib.lib到底有什么用？&lt;/p&gt;
    
    </summary>
    
    
      <category term="配置" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>C++学习：强制类型转换</title>
    <link href="http://yoursite.com/2018/10/21/C-%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2018/10/21/C-学习：强制类型转换/</id>
    <published>2018-10-21T06:12:41.000Z</published>
    <updated>2018-10-21T06:20:13.180Z</updated>
    
    <content type="html"><![CDATA[<p>z最近晕乎乎的，这部分的内容看得很不明白，只能理解非常浅显，我要加油了 ！</p><p>参考这篇博客：<a href="https://blog.csdn.net/ydar95/article/details/69822540" target="_blank" rel="noopener">https://blog.csdn.net/ydar95/article/details/69822540</a></p><ul><li>去const属性用const_cast</li><li>基本类型转换用static_cast</li><li>多态类之间的类型转换用daynamic_cast</li><li>不同类型的指针类型转换用reinterpreter_cast</li></ul><a id="more"></a><p><br></p><h2 id="C风格"><a href="#C风格" class="headerlink" title="C风格"></a>C风格</h2><p><code>TypeName b = (TypeName)a;</code></p><p><br></p><h2 id="C-风格"><a href="#C-风格" class="headerlink" title="C++风格"></a>C++风格</h2><h3 id="1-const-cast"><a href="#1-const-cast" class="headerlink" title="1. const_cast"></a>1. const_cast</h3><p><strong>去掉类型的 const、volatile 属性</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeWord</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tmp = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(buf);</span><br><span class="line">    tmp[<span class="number">0</span>] = <span class="string">'9'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">"123456789"</span>;</span><br><span class="line">    changeWord(buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-static-cast"><a href="#2-static-cast" class="headerlink" title="2. static_cast"></a>2. static_cast</h3><p>类似于C风格的强制转换</p><ol><li><p>派生类和子类之间转换</p><ul><li><strong>派生类的指针或引用转换成基类是安全的</strong></li></ul></li></ol><ul><li><strong>基类指针或引用转换成派生类是不安全的</strong></li></ul><ol start="2"><li><p>基本数据类型之间的转换，enum, struct, int, char, float 之间的转换</p></li><li><p><strong>static_cast不能去掉类型的const、volitale属性 (用const_cast)</strong></p></li><li><p>c++ 的任何的隐式转换都是使用 static_cast 来实现</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 常规用法 */</span></span><br><span class="line"><span class="keyword">float</span> f_pi=<span class="number">3.141592f</span></span><br><span class="line"><span class="keyword">int</span>   i_pi=<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(f_pi); <span class="comment">// i_pi 的值为 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* class 的上下行转换 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  上行 Sub -&gt; Base</span></span><br><span class="line"><span class="comment">//编译通过，安全</span></span><br><span class="line">Sub sub;</span><br><span class="line">Base *base_ptr = <span class="keyword">static_cast</span>&lt;Base*&gt;(&amp;sub);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//  下行 Base -&gt; Sub</span></span><br><span class="line"><span class="comment">//编译通过，不安全</span></span><br><span class="line">Base base;</span><br><span class="line">Sub *sub_ptr = <span class="keyword">static_cast</span>&lt;Sub*&gt;(&amp;base);</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3-dynamic-cast"><a href="#3-dynamic-cast" class="headerlink" title="3. dynamic_cast"></a>3. dynamic_cast</h3><p>一般是用在基类和派生类的转换上，也与编译器的属性设置有关</p><p>在进行下行转换时，dynamic_cast具有类型检查的功能，比 static_cast更安全</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base() &#123;&#125;</span><br><span class="line">    ~Base() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm Base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">i_am_virtual_foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span>:</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sub() &#123;&#125;</span><br><span class="line">    ~Sub() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm Sub"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">i_am_virtual_foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Sub-&gt;Base"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Sub * sub = <span class="keyword">new</span> Sub();</span><br><span class="line">    sub-&gt;print();</span><br><span class="line">    Base* sub2base = <span class="keyword">dynamic_cast</span>&lt;Base*&gt;(sub);</span><br><span class="line">    <span class="keyword">if</span> (sub2base != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        sub2base-&gt;print();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;sub-&gt;base&gt; sub2base val is: "</span> &lt;&lt; sub2base &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Base-&gt;Sub"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Base *base = <span class="keyword">new</span> Base();</span><br><span class="line">    base-&gt;print();</span><br><span class="line">    Sub  *base2sub = <span class="keyword">dynamic_cast</span>&lt;Sub*&gt;(base);</span><br><span class="line">    <span class="keyword">if</span> (base2sub != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        base2sub-&gt;print();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">"&lt;base-&gt;sub&gt; base2sub val is: "</span>&lt;&lt; base2sub &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> sub;</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* vs2017 输出为</span></span><br><span class="line"><span class="comment">Sub-&gt;Base</span></span><br><span class="line"><span class="comment">I'm Sub</span></span><br><span class="line"><span class="comment">I'm Base</span></span><br><span class="line"><span class="comment">&lt;sub-&gt;base&gt; sub2base val is: 00B9E080   // 注:这个地址是系统分配的,每次不一定一样</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Base-&gt;Sub</span></span><br><span class="line"><span class="comment">I'm Base</span></span><br><span class="line"><span class="comment">&lt;base-&gt;sub&gt; base2sub val is: 00000000   // 对此类错误的转换赋值为nullptr</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><br></p><p>运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表</p><p>当一个类中拥有至少一个虚函数，那么编译器就会构建出一个虚函数表，来指示这些函数的地址，假如继承该类的子类定义并实现了一个同名并具有同样函数签名的方法重写了基类中的方法，那么虚函数表会将该函数指向新的地址。此时多态性就体现出来了</p><p><br></p><h3 id="4-reinterpret-cast"><a href="#4-reinterpret-cast" class="headerlink" title="4. reinterpret_cast"></a>4. reinterpret_cast</h3><p>无关类型转换，将指针转换为其它指针类型、将数字转换为指针或将指针转换为数字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重解析类型转换，前置进行类型转换 </span></span><br><span class="line">    <span class="keyword">char</span> *p1  = <span class="string">"hello world"</span>;                       </span><br><span class="line">    <span class="keyword">int</span>  *p2  = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span> *&gt;(p1);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p2&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 输出一串我也看不懂的数字</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;z最近晕乎乎的，这部分的内容看得很不明白，只能理解非常浅显，我要加油了 ！&lt;/p&gt;
&lt;p&gt;参考这篇博客：&lt;a href=&quot;https://blog.csdn.net/ydar95/article/details/69822540&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/ydar95/article/details/69822540&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;去const属性用const_cast&lt;/li&gt;
&lt;li&gt;基本类型转换用static_cast&lt;/li&gt;
&lt;li&gt;多态类之间的类型转换用daynamic_cast&lt;/li&gt;
&lt;li&gt;不同类型的指针类型转换用reinterpreter_cast&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
</feed>
