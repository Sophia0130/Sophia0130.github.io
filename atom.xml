<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>绿小蕤</title>
  <icon>https://www.gravatar.com/avatar/e4d7a8bd1cb84fb3b4123916b4ea2f6b</icon>
  <subtitle>好逸恶劳,贪生怕死</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-22T11:54:31.493Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>绿小蕤</name>
    <email>528036346@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Titanic: Machine Learning from Disaster（一）</title>
    <link href="http://yoursite.com/2018/05/22/Titanic-Machine-Learning-from-Disaster%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/05/22/Titanic-Machine-Learning-from-Disaster（一）/</id>
    <published>2018-05-22T11:44:16.000Z</published>
    <updated>2018-05-22T11:54:31.493Z</updated>
    
    <content type="html"><![CDATA[<p>PS：入门！！！这个赛题真的很适合小白入门，先做个 baseline model ，一定要每一步走完，不论最后成绩高低，都是一件很有成就感的事啊，而且实践是学习最好的方法，学再多机器学习算法原理，到头来发现别人都帮你把框架搭好了，最重要的还是<strong>特征分析和数据处理</strong> ，这个认知转变真的是在实践才体会到 ~                  <strong>baseline model 基准模型</strong>（要研究一个新的模型，就是在前人的模型基础上新增加了一些组件进行修改）</p><a id="more"></a><hr><p>Kaggle流程：</p><ol><li>了解问题背景：对竞赛的背景进行了解</li><li>下载数据</li><li>分析数据：Explore Data Analysis</li><li>数据处理和特征工程：Data Process and FeatureEngineering</li><li>模型选择：Model Select</li><li>提交结果：Submission</li></ol><p>PS：因为真的是小白，所以看了很多博客，说实在真的没有耐心看大段代码的，下面两篇思路清晰，最重要的是不复杂，哎，后面做优化得看进阶版的，得耐下心来啊 ~                                                      <a href="https://www.kaggle.com/meiyfkaggle/titanic-data-solutions-translate-into-chinese" target="_blank" rel="noopener">https://www.kaggle.com/meiyfkaggle/titanic-data-solutions-translate-into-chinese</a>                              <a href="https://zhuanlan.zhihu.com/p/28586467" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28586467</a></p><hr><h2 id="问题和难题定义"><a href="#问题和难题定义" class="headerlink" title="问题和难题定义"></a>问题和难题定义</h2><p>从列出了在泰坦尼克号灾难中幸存下来或没有生存的乘客的一系列训练样本中学习后，模型能不能通过一个给定的不包含获救信息的测试集，预测测试集中的乘客是否获救。</p><ul><li>1912年4月15日，泰坦尼克号在首次航行中，与冰山相撞后沉没，在2224名乘客和船员中造成1502人死亡。也就是只有32%的存活率。</li><li>其中一个导致了在这场海难中损失如此多生命的原因是乘客和船员没有足够多的救生船。</li><li>尽管这次沉船事件中有一些运气的原因，但一些像女人，孩子，上层人士这类人比其他人幸存的概率更大。</li></ul><h2 id="工作流阶段"><a href="#工作流阶段" class="headerlink" title="工作流阶段"></a>工作流阶段</h2><ul><li>问题的定义</li><li>采集训练集和测试集</li><li>数据规整，预处理，清洗数据</li><li>分析，识别模式和数据挖掘</li><li>模型，预测和解决问题</li></ul><p>寒小阳大神的忠告：</p><ul><li><strong>对数据的认识太重要了！</strong></li><li><strong>数据中的特殊点/离群点的分析和处理太重要了！</strong></li><li><strong>特征工程(feature engineering)太重要了！</strong></li><li><strong>模型融合(model ensemble)太重要了！</strong></li></ul><hr><h2 id="数据分析和模型训练"><a href="#数据分析和模型训练" class="headerlink" title="数据分析和模型训练"></a>数据分析和模型训练</h2><h3 id="一、数据情况分析"><a href="#一、数据情况分析" class="headerlink" title="一、数据情况分析"></a>一、数据情况分析</h3><p>1.读入数据:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data_train = pandas.read_csv(<span class="string">"D:/机器学习/泰坦尼克号生存问题/train.csv"</span>)</span><br><span class="line">data_test = pandas.read_csv(<span class="string">'D:/机器学习/泰坦尼克号生存问题/test.csv'</span>)</span><br></pre></td></tr></table></figure><p>2.获取数据的列信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(data_train.columns.values) <span class="comment">#获取数据所有列</span></span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic1.png" alt="1"></p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic2.jpg" alt="2"></p><p>PassengerId =&gt; 乘客ID</p><p>Survived =&gt; 是否获救</p><p>Pclass =&gt; 乘客等级(1/2/3等舱位)</p><p>Name =&gt; 乘客姓名</p><p>Sex =&gt; 性别</p><p>Age =&gt; 年龄</p><p>SibSp =&gt; 堂兄弟/妹个数</p><p>Parch =&gt; 父母与小孩个数</p><p>Ticket =&gt; 船票信息</p><p>Fare =&gt; 票价</p><p>Cabin =&gt; 客舱</p><p>Embarked =&gt; 登船港口(S、C、Q)</p><p>（去掉PassengerID 、Name、Ticket 、 Cabin）</p><p>分类(categorical)：Survived、Sex、Embarked</p><p>序数(ordinal)：Pclass</p><p>连续(continous)：Age、Fare</p><p>离散的(discrete)：SibSp、Parch</p><p>3.获取数据的整体情况  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> data_train.info()</span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic3.jpg" alt="3"></p><p>（1）可以知道各列数据的缺失状况</p><p>训练数据总共是891条数据</p><p>Age只有714条，缺失177条</p><p>Cabin只有204条，缺失687条，缺失比较严重</p><p>Embarked缺失2条数据</p><p>（2）可以知道数据类型分三种float64、int64、object</p><p>4.数据分布  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_train.describe()</span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic4.png" alt="4"></p><p>count：总数；mean：均值；std：标准差；min：最小值；25%：四分之一分位数；50%：中位数；75%：四分之三分位数；max：最大值</p><p> 5.离散类型数据分布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_train.describe(include=[numpy.object])</span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic5.png" alt="5"></p><p>Count： 统计每一列非空值个数</p><p>Unique：统计每一列不一样的非空值出现次</p><p>Top：出现次数最多的值</p><p>Freq：出现最多值出现的次数</p><h3 id="二、离散数据与Survived的关系"><a href="#二、离散数据与Survived的关系" class="headerlink" title="二、离散数据与Survived的关系"></a>二、离散数据与Survived的关系</h3><p>1.Pclass与Survived</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_train[[<span class="string">'Pclass'</span>, <span class="string">'Survived'</span>]].groupby([<span class="string">'Pclass'</span>]).mean()</span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic6.png" alt="6"></p><p>Pclass的数值越小最后获救的概率越大</p><p>2、Sex与Survived</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_train[[<span class="string">'Sex'</span>, <span class="string">'Survived'</span>]].groupby([<span class="string">'Sex'</span>]).mean()</span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic7.png" alt="7"></p><p>3.SibSp、Parch与Survived</p><p>兄弟姐妹个数、父母与小孩的个数似乎与Survived之间没有明显的关联</p><p> 4.Embarked与Survived</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_train[[<span class="string">'Embarked'</span>, <span class="string">'Survived'</span>]].groupby([<span class="string">'Embarked'</span>]).mean()</span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic8.png" alt="8"></p><p>登船港口C的获救概率要高于Q和S</p><h3 id="三、连续数据与Survived的关系-画图分析数据-数据的可视化"><a href="#三、连续数据与Survived的关系-画图分析数据-数据的可视化" class="headerlink" title="三、连续数据与Survived的关系(画图分析数据) 数据的可视化"></a>三、连续数据与Survived的关系(画图分析数据) 数据的可视化</h3><p>1.Age与Survived</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = sns.FacetGrid(data_train, col=<span class="string">'Survived'</span>)</span><br><span class="line">age.map(plt.hist, <span class="string">'Age'</span>, bins=<span class="number">10</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic9.png" alt="9"></p><p>2.Fare与Survived</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fare = sns.FacetGrid(data_train, col=<span class="string">'Survived'</span>)</span><br><span class="line">fare.map(plt.hist, <span class="string">'Fare'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic10.png" alt="10"></p><h3 id="四、连续和离散数据与Survived的关联"><a href="#四、连续和离散数据与Survived的关联" class="headerlink" title="四、连续和离散数据与Survived的关联"></a>四、连续和离散数据与Survived的关联</h3><p>Fare/Pclass与Survived</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fare_pclass = sns.FacetGrid(data_train,col=&apos;Survived&apos;,row=&apos;Pclass&apos;)</span><br><span class="line">fare_pclass.map(plt.hist,&apos;Age&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic11.png" alt="11"></p><h3 id="五、数据特征处理"><a href="#五、数据特征处理" class="headerlink" title="五、数据特征处理"></a>五、数据特征处理</h3><p><strong>连续值归一化，非连续值因子化</strong></p><p>1.连续值与非连续值的转化                                                                        2.缺省值的处理                                                                                  3.去除不同特征的共线性 PCA                                                                                 4.离群点的处理</p><p>将训练和测试数据合并</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">combine=[data_train,data_test]  <span class="comment">#将训练和测试数据合并后清洗</span></span><br></pre></td></tr></table></figure><h4 id="1-Name"><a href="#1-Name" class="headerlink" title="1.Name"></a>1.Name</h4><p>（1）处理：提取出名字中的头衔和称谓Title</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> combine:</span><br><span class="line">dataset[<span class="string">'Title'</span>] = dataset.Name.str.extract(<span class="string">'([A-Za-z]+\.)'</span>,expand=<span class="keyword">False</span>) </span><br><span class="line"><span class="comment">#提取出名字中的头衔和称谓</span></span><br><span class="line">Title=data_train[[<span class="string">'Title'</span>,<span class="string">'Survived'</span>]].groupby([<span class="string">'Title'</span>]).count() <span class="comment">#每个Title对应的人数</span></span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic12.png" alt="12"></p><p>（2）将一些Title代替，分为五类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dataset[<span class="string">'Title'</span>] = dataset[<span class="string">'Title'</span>].replace([<span class="string">'Lady'</span>, <span class="string">'Countess'</span>, <span class="string">'Col'</span>, <span class="string">'Don'</span>, <span class="string">'Dr'</span>, <span class="string">'Major'</span>, <span class="string">'Rev'</span>, <span class="string">'Sir'</span>, <span class="string">'Jonkheer'</span>, <span class="string">'Dona'</span>,<span class="string">'Capt'</span>], <span class="string">'Rare'</span>)</span><br><span class="line">dataset[<span class="string">'Title'</span>] = dataset[<span class="string">'Title'</span>].replace(<span class="string">'Mlle'</span>, <span class="string">'Mr'</span>)</span><br><span class="line">dataset[<span class="string">'Title'</span>] = dataset[<span class="string">'Title'</span>].replace(<span class="string">'Ms'</span>, <span class="string">'Miss'</span>)</span><br><span class="line">dataset[<span class="string">'Title'</span>] = dataset[<span class="string">'Title'</span>].replace(<span class="string">'Mme'</span>, <span class="string">'Mrs'</span>)</span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic13.png" alt="13"></p><p>（3）将Title映射到具体的数据1-5，将缺失的数据填充为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> combine:</span><br><span class="line">    dataset[<span class="string">'Title'</span>] = dataset.Name.str.extract(<span class="string">'([A-Za-z]+)\.'</span>, expand=<span class="keyword">False</span>) <span class="comment">#提取名字中的称谓</span></span><br><span class="line">    <span class="comment">#将一些Title用别的代替</span></span><br><span class="line">    dataset[<span class="string">'Title'</span>] = dataset[<span class="string">'Title'</span>].replace([<span class="string">'Lady'</span>, <span class="string">'Countess'</span>, <span class="string">'Col'</span>, <span class="string">'Don'</span>, <span class="string">'Dr'</span>, <span class="string">'Major'</span>, <span class="string">'Rev'</span>, <span class="string">'Sir'</span>, <span class="string">'Jonkheer'</span>, <span class="string">'Dona'</span>,<span class="string">'Capt'</span>], <span class="string">'Rare'</span>)</span><br><span class="line">    dataset[<span class="string">'Title'</span>] = dataset[<span class="string">'Title'</span>].replace(<span class="string">'Mlle'</span>, <span class="string">'Mr'</span>)</span><br><span class="line">    dataset[<span class="string">'Title'</span>] = dataset[<span class="string">'Title'</span>].replace(<span class="string">'Ms'</span>, <span class="string">'Miss'</span>)</span><br><span class="line">    dataset[<span class="string">'Title'</span>] = dataset[<span class="string">'Title'</span>].replace(<span class="string">'Mme'</span>, <span class="string">'Mrs'</span>)</span><br><span class="line">    title_map = &#123;<span class="string">'Mr'</span>: <span class="number">1</span>, <span class="string">'Miss'</span>: <span class="number">2</span>, <span class="string">'Mrs'</span>: <span class="number">3</span>, <span class="string">'Master'</span>: <span class="number">4</span>, <span class="string">'Rare'</span>: <span class="number">5</span>&#125;</span><br><span class="line">    dataset[<span class="string">'Title'</span>] = dataset[<span class="string">'Title'</span>].map(title_map) <span class="comment">#将Title映射为数字</span></span><br><span class="line">    dataset[<span class="string">'Title'</span>] = dataset[<span class="string">'Title'</span>].fillna(<span class="number">0</span>)  <span class="comment">#将缺失的数据填充为0</span></span><br><span class="line">Title=data_train[[<span class="string">'Title'</span>,<span class="string">'Survived'</span>]].groupby([<span class="string">'Title'</span>]).count()</span><br><span class="line">print(Title)</span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic14.png" alt="14"></p><h4 id="2-SibSp（堂兄弟-妹个数）和Parch（父母与小孩个数）"><a href="#2-SibSp（堂兄弟-妹个数）和Parch（父母与小孩个数）" class="headerlink" title="2.SibSp（堂兄弟/妹个数）和Parch（父母与小孩个数）"></a>2.SibSp（堂兄弟/妹个数）和Parch（父母与小孩个数）</h4><p>（1）处理：合成为一个新的特征FamilySize</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> combine:</span><br><span class="line">    dataset[<span class="string">'FamilySize'</span>] = dataset[<span class="string">'SibSp'</span>] + dataset[<span class="string">'Parch'</span>] + <span class="number">1</span> <span class="comment">#加1表示他自己</span></span><br><span class="line">Familysize =data_train[[<span class="string">'FamilySize'</span>,<span class="string">'Survived'</span>]].groupby([<span class="string">'FamilySize'</span>]).count()</span><br><span class="line">print(Familysize)</span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic15.png" alt="15"></p><p>（2）处理：根据FamilySize判断是否有家庭还是单个人，形成新的特征IsAlone</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> combine:</span><br><span class="line">    dataset[<span class="string">'IsAlone'</span>] = <span class="number">0</span></span><br><span class="line">    dataset.loc[dataset[<span class="string">'FamilySize'</span>] == <span class="number">1</span>, <span class="string">'IsAlone'</span>] = <span class="number">1</span> <span class="comment">#索引每行的数据</span></span><br><span class="line">Isalone =data_train[[<span class="string">'IsAlone'</span>,<span class="string">'Survived'</span>]].groupby([<span class="string">'IsAlone'</span>]).count()</span><br><span class="line">print(Isalone)</span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic16.png" alt="16"></p><p>（3）对FamilySize做分组处理，形成新的特征FamilySizePlus</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> combine:</span><br><span class="line">    dataset[<span class="string">'FamilySizePlus'</span>] = <span class="number">0</span></span><br><span class="line">    dataset.loc[dataset[<span class="string">'FamilySize'</span>] == <span class="number">1</span>, <span class="string">'FamilySizePlus'</span>] = <span class="number">1</span></span><br><span class="line">    dataset.loc[dataset[<span class="string">'FamilySize'</span>] == <span class="number">2</span>, <span class="string">'FamilySizePlus'</span>] = <span class="number">2</span></span><br><span class="line">    dataset.loc[dataset[<span class="string">'FamilySize'</span>] == <span class="number">3</span>, <span class="string">'FamilySizePlus'</span>] = <span class="number">2</span></span><br><span class="line">    dataset.loc[dataset[<span class="string">'FamilySize'</span>] == <span class="number">4</span>, <span class="string">'FamilySizePlus'</span>] = <span class="number">2</span></span><br><span class="line">    dataset.loc[dataset[<span class="string">'FamilySize'</span>] == <span class="number">5</span>, <span class="string">'FamilySizePlus'</span>] = <span class="number">1</span></span><br><span class="line">    dataset.loc[dataset[<span class="string">'FamilySize'</span>] == <span class="number">6</span>, <span class="string">'FamilySizePlus'</span>] = <span class="number">1</span></span><br><span class="line">    dataset.loc[dataset[<span class="string">'FamilySize'</span>] == <span class="number">7</span>, <span class="string">'FamilySizePlus'</span>] = <span class="number">1</span></span><br><span class="line">Familysizeplus =data_train[[<span class="string">'FamilySizePlus'</span>,<span class="string">'Survived'</span>]].groupby([<span class="string">'FamilySizePlus'</span>]).count()</span><br><span class="line">print(Familysizeplus)</span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic17.png" alt="17"></p><h4 id="3-Sex"><a href="#3-Sex" class="headerlink" title="3.Sex"></a>3.Sex</h4><p>处理：将Sex因子化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> combine:</span><br><span class="line">    dataset[<span class="string">'Sex'</span>] = dataset[<span class="string">'Sex'</span>].map(&#123;<span class="string">'female'</span>: <span class="number">1</span>, <span class="string">'male'</span>: <span class="number">0</span>&#125;).astype(int)</span><br><span class="line">Sex =data_train[[<span class="string">'Sex'</span>,<span class="string">'Survived'</span>]].groupby([<span class="string">'Sex'</span>]).count()</span><br><span class="line">print(Sex)</span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic18.png" alt="18"></p><h4 id="4-Age"><a href="#4-Age" class="headerlink" title="4.Age"></a>4.Age</h4><p>处理：填补缺省的Age值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.遍历Sex(0 or 1)和Pclass(1,2,3)这两个条件猜测年龄</span></span><br><span class="line"><span class="comment">#根据每个船舱的各自性别的年龄的中位数来填充</span></span><br><span class="line">guess_ages = numpy.zeros((<span class="number">2</span>, <span class="number">3</span>)) <span class="comment">#创建一个2*3的数组存放猜测的年龄</span></span><br><span class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> combine:</span><br><span class="line">    <span class="comment">#将需要填充的相应年龄放在guess_ages数组中</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">            guess_df = dataset[(dataset[<span class="string">'Sex'</span>] == i) &amp; (dataset[<span class="string">'Pclass'</span>] == j+<span class="number">1</span>)][<span class="string">'Age'</span>].dropna() <span class="comment">#dataframe.dropna()可以按行丢弃带有nan的数据，排除缺省数据</span></span><br><span class="line">            age_guess = guess_df.median() <span class="comment">#求中位数</span></span><br><span class="line">            guess_ages[i,j] = int(age_guess / <span class="number">0.5</span> + <span class="number">0.5</span>) * <span class="number">0.5</span></span><br><span class="line">print(guess_ages)</span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic19.png" alt="19"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">#2.对缺省值进行填充</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">3</span>):</span><br><span class="line">            dataset.loc[(dataset.Age.isnull()) &amp; (dataset.Sex == i) &amp; (dataset.Pclass == j + <span class="number">1</span>), <span class="string">'Age'</span>] = guess_ages[i, j]</span><br><span class="line">dataset[<span class="string">'Age'</span>] = dataset[<span class="string">'Age'</span>].astype(int)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> combine:</span><br><span class="line">    <span class="comment">#3.对年龄进行分组</span></span><br><span class="line">    dataset.loc[ dataset[<span class="string">'Age'</span>] &lt;= <span class="number">16</span>, <span class="string">'Age'</span>] = <span class="number">0</span></span><br><span class="line">    dataset.loc[(dataset[<span class="string">'Age'</span>] &gt; <span class="number">16</span>) &amp; (dataset[<span class="string">'Age'</span>] &lt;= <span class="number">32</span>), <span class="string">'Age'</span>] = <span class="number">1</span></span><br><span class="line">    dataset.loc[(dataset[<span class="string">'Age'</span>] &gt; <span class="number">32</span>) &amp; (dataset[<span class="string">'Age'</span>] &lt;= <span class="number">48</span>), <span class="string">'Age'</span>] = <span class="number">2</span></span><br><span class="line">    dataset.loc[(dataset[<span class="string">'Age'</span>] &gt; <span class="number">48</span>) &amp; (dataset[<span class="string">'Age'</span>] &lt;= <span class="number">64</span>), <span class="string">'Age'</span>] = <span class="number">3</span></span><br><span class="line">    dataset.loc[ dataset[<span class="string">'Age'</span>] &gt; <span class="number">64</span>, <span class="string">'Age'</span>] = <span class="number">4</span></span><br><span class="line">Age =data_train[[<span class="string">'Age'</span>,<span class="string">'Survived'</span>]].groupby([<span class="string">'Age'</span>]).count()</span><br><span class="line">print(Age)</span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic20.png" alt="20"></p><h4 id="5-Embarked"><a href="#5-Embarked" class="headerlink" title="5.Embarked"></a>5.Embarked</h4><p>处理：对缺省的Embarked，用出现最频繁的值填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">freq_port = data_train.Embarked.dropna().mode()[<span class="number">0</span>] </span><br><span class="line"><span class="comment"># 采用出现最频繁的值填充</span></span><br><span class="line">print(<span class="string">"freq_port ="</span>,freq_port)</span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic21.png" alt="21"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> combine:</span><br><span class="line">    dataset[<span class="string">'Embarked'</span>] = dataset[<span class="string">'Embarked'</span>].fillna(freq_port) <span class="comment">#填充</span></span><br><span class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> combine:</span><br><span class="line">    dataset[<span class="string">'Embarked'</span>] = dataset[<span class="string">'Embarked'</span>].map(&#123;<span class="string">'S'</span>: <span class="number">0</span>, <span class="string">'C'</span>: <span class="number">1</span>, <span class="string">'Q'</span>: <span class="number">2</span>&#125;) <span class="comment">#映射为数字</span></span><br><span class="line">Embarked =data_train[[<span class="string">'Embarked'</span>,<span class="string">'Survived'</span>]].groupby([<span class="string">'Embarked'</span>]).count()</span><br><span class="line">print(Embarked)</span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic22.png" alt="22"></p><h4 id="6-Fare"><a href="#6-Fare" class="headerlink" title="6.Fare"></a>6.Fare</h4><p>处理：对缺省的Fare，用中位数填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">med_fare=data_test[<span class="string">'Fare'</span>].dropna().median()<span class="comment">#中位数</span></span><br><span class="line">print(<span class="string">"med_fare="</span>,med_fare)</span><br></pre></td></tr></table></figure><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic23.png" alt="23"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> dataset <span class="keyword">in</span> combine:</span><br><span class="line">    dataset[<span class="string">'Fare'</span>] = dataset[<span class="string">'Fare'</span>].fillna(med_fare) <span class="comment">#填充</span></span><br></pre></td></tr></table></figure><h4 id="7-最后选取需要的特征"><a href="#7-最后选取需要的特征" class="headerlink" title="7.最后选取需要的特征"></a>7.最后选取需要的特征</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#把不需要的特征丢掉</span></span><br><span class="line">data_train = data_train.drop([<span class="string">'PassengerId'</span>, <span class="string">'Name'</span>, <span class="string">'SibSp'</span>, <span class="string">'Parch'</span>, <span class="string">'Ticket'</span>, <span class="string">'FamilySize'</span>,<span class="string">'Cabin'</span>], axis=<span class="number">1</span>)</span><br><span class="line">data_test  = data_test.drop([<span class="string">'PassengerId'</span>, <span class="string">'Name'</span>, <span class="string">'SibSp'</span>, <span class="string">'Parch'</span>, <span class="string">'Ticket'</span>, <span class="string">'FamilySize'</span>,<span class="string">'Cabin'</span>], axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#选取各数据对应的特征</span></span><br><span class="line">X_train = data_train[[<span class="string">'Pclass'</span>, <span class="string">'Sex'</span>, <span class="string">'Age'</span>, <span class="string">'Fare'</span>, <span class="string">'Embarked'</span>, <span class="string">'Title'</span>, <span class="string">'FamilySizePlus'</span>]]</span><br><span class="line">Y_train = data_train[<span class="string">'Survived'</span>]</span><br><span class="line">X_test = data_test[[<span class="string">'Pclass'</span>, <span class="string">'Sex'</span>, <span class="string">'Age'</span>, <span class="string">'Fare'</span>, <span class="string">'Embarked'</span>, <span class="string">'Title'</span>, <span class="string">'FamilySizePlus'</span>]]</span><br><span class="line">data_train.to_csv(<span class="string">"D:/机器学习/泰坦尼克号生存问题/trainclean.csv"</span>)</span><br><span class="line">X_test.to_csv(<span class="string">"D:/机器学习/泰坦尼克号生存问题/testclean.csv"</span>)</span><br></pre></td></tr></table></figure><p>train 数据</p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic24.png" alt="24"></p><p>test中数据</p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic25.png" alt="25"></p><h3 id="六、模型建立"><a href="#六、模型建立" class="headerlink" title="六、模型建立"></a>六、模型建立</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">###模型训练###</span></span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="comment"># Logistic Regression</span></span><br><span class="line">logreg = LogisticRegression() <span class="comment">#初始化逻辑回归类</span></span><br><span class="line">logreg.fit(X_train, Y_train) <span class="comment">#训练算法</span></span><br><span class="line">Y_pred = logreg.predict(X_test) <span class="comment">#做预测</span></span><br><span class="line">logScore = logreg.score(X_train, Y_train)  <span class="comment">#测试集拟合的结果得到模型预测准确率</span></span><br><span class="line">print(logScore)</span><br></pre></td></tr></table></figure><p>评估分数为：</p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic26.png" alt="26"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###预测和结果输出###</span></span><br><span class="line"><span class="comment"># 创建新的dataframe对象submission，仅含"PassengerID"和"Survived"两列。</span></span><br><span class="line">submission = pandas.DataFrame(&#123;<span class="string">"PassengerId"</span>: data_test[<span class="string">"PassengerId"</span>], <span class="string">"Survived"</span>: Y_pred&#125;)</span><br><span class="line"><span class="comment"># 创建新的dataframe对象submission，仅含"PassengerID"和"Survived"两列</span></span><br><span class="line">submission.to_csv(<span class="string">"D:/机器学习/泰坦尼克号生存问题/submission.csv"</span>, index=<span class="keyword">False</span>)</span><br><span class="line"><span class="comment"># 将submission输出为.csv格式的提交文件</span></span><br></pre></td></tr></table></figure><p>预测结果：</p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic27.png" alt="27"></p><h3 id="七、Kaggle提交结果"><a href="#七、Kaggle提交结果" class="headerlink" title="七、Kaggle提交结果"></a>七、Kaggle提交结果</h3><p>真的好激动啊~第一次做完一个模型，虽然完全是模仿大神的，但是模仿真的是学习的第一步啊，每个流程一定要自己走一遍，真的很重要，实践中会发现乱七八糟的问题。不说了，开心</p><p>~ 提交</p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic28.png" alt="28"></p><p>~ 排名</p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/Titanic29.png" alt="29"></p><hr><h2 id="评估模型"><a href="#评估模型" class="headerlink" title="评估模型"></a>评估模型</h2><p>Validation curve 验证曲线：判断处于过拟合(overfitting/high variace)还是欠拟合(underfitting/high bias)</p><p>Learning curve 学习曲线：判断是否需要增加数据量</p><hr><p>PS：准备好好把这个题目做好，之后准备在baseline上改进 ~</p><p><a href="https://blog.csdn.net/Koala_Tree/article/details/78725881" target="_blank" rel="noopener">https://blog.csdn.net/Koala_Tree/article/details/78725881</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：入门！！！这个赛题真的很适合小白入门，先做个 baseline model ，一定要每一步走完，不论最后成绩高低，都是一件很有成就感的事啊，而且实践是学习最好的方法，学再多机器学习算法原理，到头来发现别人都帮你把框架搭好了，最重要的还是&lt;strong&gt;特征分析和数据处理&lt;/strong&gt; ，这个认知转变真的是在实践才体会到 ~                  &lt;strong&gt;baseline model 基准模型&lt;/strong&gt;（要研究一个新的模型，就是在前人的模型基础上新增加了一些组件进行修改）&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机和云(特别简陋的认识)</title>
    <link href="http://yoursite.com/2018/05/18/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%BA%91-%E7%89%B9%E5%88%AB%E7%AE%80%E9%99%8B%E7%9A%84%E8%AE%A4%E8%AF%86/"/>
    <id>http://yoursite.com/2018/05/18/虚拟机和云-特别简陋的认识/</id>
    <published>2018-05-18T09:00:10.000Z</published>
    <updated>2018-05-18T09:00:47.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><p>PS：我不知道我为啥要写这篇博，单纯就想了解吧，所以记录得乱七八糟，因为自己也没接触这块过。</p><ol><li>宿主机：指要安装虚拟机软件的计算机，你花钱买的物理机。</li><li>虚拟机：利用虚拟机工具构造出的一整套硬件设备，有自己操作系统，应用软件。                    </li><li>虚拟机的简单应用</li></ol><p><a href="http://www.pc841.com/article/20120413-5731.html" target="_blank" rel="noopener">http://www.pc841.com/article/20120413-5731.html</a></p><a id="more"></a><p>1) 最简单我们电脑中没有光驱，如果要安装系统我们就可以<strong>使用虚拟机来安装系统，虚拟机内部拥有虚拟光驱，支持直接打开系统镜像文件安装系统</strong>。</p><p>2) 另外虚拟机技术在游戏爱好者朋友眼中也相当实用，很多游戏不支持同时多开，但我们可以在电脑中多创建几个虚拟机，那么在虚拟机系统中即可单独再运行程序了，这样即可实现一台电脑同时多开同一游戏了。</p><h2 id="虚拟机和云"><a href="#虚拟机和云" class="headerlink" title="虚拟机和云"></a>虚拟机和云</h2><p>这篇知乎写的还是很详细的，但是后面术语真的看不懂。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;虚拟机&quot;&gt;&lt;a href=&quot;#虚拟机&quot; class=&quot;headerlink&quot; title=&quot;虚拟机&quot;&gt;&lt;/a&gt;虚拟机&lt;/h2&gt;&lt;p&gt;PS：我不知道我为啥要写这篇博，单纯就想了解吧，所以记录得乱七八糟，因为自己也没接触这块过。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;宿主机：指要安装虚拟机软件的计算机，你花钱买的物理机。&lt;/li&gt;
&lt;li&gt;虚拟机：利用虚拟机工具构造出的一整套硬件设备，有自己操作系统，应用软件。                    &lt;/li&gt;
&lt;li&gt;虚拟机的简单应用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;http://www.pc841.com/article/20120413-5731.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.pc841.com/article/20120413-5731.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="云" scheme="http://yoursite.com/tags/%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>啥叫运营商</title>
    <link href="http://yoursite.com/2018/05/18/%E5%95%A5%E5%8F%AB%E8%BF%90%E8%90%A5%E5%95%86/"/>
    <id>http://yoursite.com/2018/05/18/啥叫运营商/</id>
    <published>2018-05-18T07:21:14.000Z</published>
    <updated>2018-05-18T07:21:52.920Z</updated>
    
    <content type="html"><![CDATA[<p>运营商是指<strong>提供网络服务的供应商</strong>，如中国联通、中国电信、 中国移动、中国移动这些公司，而诺基亚、三星等这些<strong>通信设备的生产厂家叫生产商</strong>，因为国家在电信管理方面相当严格，只有拥有工信部颁发的运营执照的公司才能架设网络，从通信行业来说，设备生产商和运营商是相互依存的。</p><p>不过今天看到一篇文章讲5G时代的到来对设备商和运营商的影响，感觉还是蛮有趣的，而且对两者会有更深刻的认识吧~                                                                                                            <a href="http://www.sohu.com/a/197243837_100030976" target="_blank" rel="noopener">http://www.sohu.com/a/197243837_100030976</a></p><a id="more"></a><p>随着技术的更新，运营商对于基站的建设可以说是投资巨大，稍有不慎可能全部打水漂，特别是当下技术还不成熟时，这让我想到了当年的液晶和等离子之争，现在的OLED和QLED之争，谁知道几年以后会发生如何的变迁，最重要的是站对阵营啊 ~</p><p>关于为什么要推动5G技术发展，引用文章种中的比喻还是很形象的，设备商是军火商，没有战争，怎么发财。没有新技术，怎么忽悠运营商。而运营商也希望通过网络技术来建筑竞争壁垒，获取技术红利。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;运营商是指&lt;strong&gt;提供网络服务的供应商&lt;/strong&gt;，如中国联通、中国电信、 中国移动、中国移动这些公司，而诺基亚、三星等这些&lt;strong&gt;通信设备的生产厂家叫生产商&lt;/strong&gt;，因为国家在电信管理方面相当严格，只有拥有工信部颁发的运营执照的公司才能架设网络，从通信行业来说，设备生产商和运营商是相互依存的。&lt;/p&gt;
&lt;p&gt;不过今天看到一篇文章讲5G时代的到来对设备商和运营商的影响，感觉还是蛮有趣的，而且对两者会有更深刻的认识吧~                                                                                                            &lt;a href=&quot;http://www.sohu.com/a/197243837_100030976&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.sohu.com/a/197243837_100030976&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>图像处理之坐标系和宽高</title>
    <link href="http://yoursite.com/2018/05/16/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B9%8B%E5%9D%90%E6%A0%87%E7%B3%BB%E5%92%8C%E5%AE%BD%E9%AB%98/"/>
    <id>http://yoursite.com/2018/05/16/图像处理之坐标系和宽高/</id>
    <published>2018-05-16T12:31:13.000Z</published>
    <updated>2018-05-16T12:48:07.284Z</updated>
    
    <content type="html"><![CDATA[<p>PS：为啥写这篇博，因为我傻啊 ~ 每次写程序遇到图像  <strong>坐标系-宽高-行列</strong>，就开始抓狂                        哎呀到底是(i，j)还是(j，i)，这篇博写的很详细啦 ~</p><p><a href="https://blog.csdn.net/oqqenvy12/article/details/71933651" target="_blank" rel="noopener">https://blog.csdn.net/oqqenvy12/article/details/71933651</a></p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PS：为啥写这篇博，因为我傻啊 ~ 每次写程序遇到图像  &lt;strong&gt;坐标系-宽高-行列&lt;/strong&gt;，就开始抓狂                        哎呀到底是(i，j)还是(j，i)，这篇博写的很详细啦 ~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https:
      
    
    </summary>
    
    
      <category term="opencv" scheme="http://yoursite.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>XML、YAML、JSON</title>
    <link href="http://yoursite.com/2018/05/14/XML%E3%80%81YAML%E3%80%81JSON/"/>
    <id>http://yoursite.com/2018/05/14/XML、YAML、JSON/</id>
    <published>2018-05-14T09:04:32.000Z</published>
    <updated>2018-05-14T09:44:25.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XML、YML-、JSON-是序列化数据格式"><a href="#XML、YML-、JSON-是序列化数据格式" class="headerlink" title="XML、YML 、JSON 是序列化数据格式"></a>XML、YML 、JSON 是序列化<strong>数据格式</strong></h2><p>PS：为什么要写这个呢，以为今天看opencv的时候讲到了XML、YAML 文件的输入输出，觉得这个经常听到名字但是不知道干啥用的~然后前几天搭博客，又一直出现JSON ~~ 心累，我的理解就是某种数据格式，方便数据的传输吧~~下面这篇篇博客讲了几个的简单区别，了解就可以了                                            <a href="http://rensanning.iteye.com/blog/2379083" target="_blank" rel="noopener">http://rensanning.iteye.com/blog/2379083</a></p><a id="more"></a><h2 id="OpenCV-使用XML和YAML实现文件输入和输出"><a href="#OpenCV-使用XML和YAML实现文件输入和输出" class="headerlink" title="OpenCV 使用XML和YAML实现文件输入和输出"></a>OpenCV 使用XML和YAML实现文件输入和输出</h2><p>为什么需要呢？因为当处理完图像后需要将数据保存到文件上。                                                                举个栗子：我们对一幅图像进行特征提取之后，需要把特征点信息保存到文件上，以供后面的机器学习分类操作。所以我们需要搭建<strong>小型数据库文件</strong>，将数据写到文件上，下次需要时从文件里读出。实现上述方法，需要使用xml和yml，具有可读性。</p><p>PS：opencv 自带的教程实在是太复杂了可以直接看下面这篇的案例，简单好懂~~                                        <a href="http://www.cnblogs.com/skyfsm/p/7182313.html" target="_blank" rel="noopener">http://www.cnblogs.com/skyfsm/p/7182313.html</a></p><p>XML/YAML文件在OpenCV中的数据结构为FileStorage</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;XML、YML-、JSON-是序列化数据格式&quot;&gt;&lt;a href=&quot;#XML、YML-、JSON-是序列化数据格式&quot; class=&quot;headerlink&quot; title=&quot;XML、YML 、JSON 是序列化数据格式&quot;&gt;&lt;/a&gt;XML、YML 、JSON 是序列化&lt;strong&gt;数据格式&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;PS：为什么要写这个呢，以为今天看opencv的时候讲到了XML、YAML 文件的输入输出，觉得这个经常听到名字但是不知道干啥用的~然后前几天搭博客，又一直出现JSON ~~ 心累，我的理解就是某种数据格式，方便数据的传输吧~~下面这篇篇博客讲了几个的简单区别，了解就可以了                                            &lt;a href=&quot;http://rensanning.iteye.com/blog/2379083&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://rensanning.iteye.com/blog/2379083&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="opencv" scheme="http://yoursite.com/tags/opencv/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>傅里叶变换和图像处理</title>
    <link href="http://yoursite.com/2018/05/14/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E5%92%8C%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/05/14/傅里叶变换和图像处理/</id>
    <published>2018-05-14T07:28:48.000Z</published>
    <updated>2018-05-14T07:30:43.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="离散傅里叶变换"><a href="#离散傅里叶变换" class="headerlink" title="离散傅里叶变换"></a>离散傅里叶变换</h2><p>原理：傅立叶变换是一个将函数分解的工具，任一函数都可以表示成无数个正弦和余弦函数的和的形式。对一张图像使用傅立叶变换就是将它分解成正弦和余弦两部分，也就是将图像从空间域(spatial domain)转换到频域(frequency domain)</p><h2 id="离散傅里叶变化-DFT"><a href="#离散傅里叶变化-DFT" class="headerlink" title="离散傅里叶变化 DFT"></a>离散傅里叶变化 DFT</h2><p><strong>图像去噪</strong>： 当图像出现的噪声是有规律的，去某个频率的波，比如高斯噪声。但是当出现的噪声是没有规律的，随机出现的一些东西，DFT是没有作用的。</p><h2 id="离散余弦变换-DCT"><a href="#离散余弦变换-DCT" class="headerlink" title="离散余弦变换 DCT"></a>离散余弦变换 DCT</h2><p>图像的余弦波由实偶函数组成</p><p><strong>图像压缩</strong>：JPEG格式的图片就是用Huffman编码方式压缩图片的DCT的系数</p><a id="more"></a><p>PS：这个东西我真的理解了很多遍，还是等要用的时候再说吧，下面这个代码可以看懂，但是原理就…</p><p><a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/core/discrete_fourier_transform/discrete_fourier_transform.html" target="_blank" rel="noopener">http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/core/discrete_fourier_transform/discrete_fourier_transform.html</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//离散傅里叶变换 DFT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/core.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgproc.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgcodecs.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"This program demonstrated the use of the discrete Fourier transform (DFT). "</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"The dft of an image is taken and it's power spectrum is displayed."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">help();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* filename = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">Mat I = imread(filename, IMREAD_GRAYSCALE);</span><br><span class="line"><span class="keyword">if</span> (I.empty())&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Error opening image"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! [expand]  当图像的尺寸是2， 3，5的整数倍时，傅里叶变换的计算速度最快</span></span><br><span class="line">Mat padded; </span><br><span class="line"><span class="keyword">int</span> m = getOptimalDFTSize(I.rows); <span class="comment">//获取最佳尺寸</span></span><br><span class="line"><span class="keyword">int</span> n = getOptimalDFTSize(I.cols);</span><br><span class="line">copyMakeBorder(I, padded, <span class="number">0</span>, m - I.rows, <span class="number">0</span>, n - I.cols, BORDER_CONSTANT, Scalar::all(<span class="number">0</span>)); <span class="comment">//将边缘像素填充为0</span></span><br><span class="line"><span class="comment">//! [expand]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! [complex_and_real] 为傅里叶变换的实部虚部分配内存</span></span><br><span class="line">Mat planes[] = &#123; Mat_&lt;<span class="keyword">float</span>&gt;(padded), Mat::zeros(padded.size(), CV_32F) &#125;; </span><br><span class="line">    <span class="comment">//在padded基础上加一个初始化为0的通道</span></span><br><span class="line">Mat complexI;</span><br><span class="line">merge(planes, <span class="number">2</span>, complexI);  <span class="comment">//将单通道数组合并成一个多通道的数组，从而创建出一个多通道阵列 </span></span><br><span class="line"><span class="comment">//! [complex_and_real]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! [dft]</span></span><br><span class="line">dft(complexI, complexI); </span><br><span class="line"><span class="comment">//! [dft]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the magnitude </span></span><br><span class="line"><span class="comment">//! [magnitude]</span></span><br><span class="line">split(complexI, planes);    <span class="comment">// planes[0] = Re(DFT(I), planes[1] = Im(DFT(I))</span></span><br><span class="line">magnitude(planes[<span class="number">0</span>], planes[<span class="number">1</span>], planes[<span class="number">0</span>]);<span class="comment">// 计算实部和虚部的幅值，放在planes[0]</span></span><br><span class="line">Mat magI = planes[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//! [magnitude]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! [log] switch to logarithmic scale</span></span><br><span class="line"><span class="comment">// =&gt; log(1 + sqrt(Re(DFT(I))^2 + Im(DFT(I))^2))</span></span><br><span class="line">magI += Scalar::all(<span class="number">1</span>); <span class="comment">//傅立叶变换的幅度值范围大到不适合在屏幕上显示，需要做对数尺度缩放</span></span><br><span class="line"><span class="built_in">log</span>(magI, magI);</span><br><span class="line"><span class="comment">//! [log]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! [crop_rearrange]</span></span><br><span class="line"><span class="comment">// crop the spectrum, if it has an odd number of rows or columns</span></span><br><span class="line">magI = magI(Rect(<span class="number">0</span>, <span class="number">0</span>, magI.cols &amp; <span class="number">-2</span>, magI.rows &amp; <span class="number">-2</span>)); <span class="comment">//剔除添加的像素(和-2按位与) ？？实在不懂是为什么啊</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rearrange the quadrants of Fourier image  so that the origin is at the image center 重分布幅度图象限</span></span><br><span class="line"><span class="keyword">int</span> cx = magI.cols / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> cy = magI.rows / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">Mat q0(magI, Rect(0, 0, cx, cy));   // Top-Left - Create a ROI per quadrant</span><br><span class="line">Mat q1(magI, Rect(cx, 0, cx, cy));  // Top-Right</span><br><span class="line">Mat q2(magI, Rect(0, cy, cx, cy));  // Bottom-Left</span><br><span class="line">Mat q3(magI, Rect(cx, cy, cx, cy)); // Bottom-Right</span><br><span class="line"></span><br><span class="line">Mat tmp;                           <span class="comment">// swap quadrants (Top-Left with Bottom-Right)</span></span><br><span class="line">q0.copyTo(tmp);</span><br><span class="line">q3.copyTo(q0);</span><br><span class="line">tmp.copyTo(q3);</span><br><span class="line"></span><br><span class="line">q1.copyTo(tmp);                    <span class="comment">// swap quadrant (Top-Right with Bottom-Left)</span></span><br><span class="line">q2.copyTo(q1);</span><br><span class="line">tmp.copyTo(q2);</span><br><span class="line"><span class="comment">//! [crop_rearrange]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! [normalize]</span></span><br><span class="line">normalize(magI, magI, <span class="number">0</span>, <span class="number">1</span>, NORM_MINMAX);<span class="comment">//数将幅度归一化到可显示范围//（不能放到0-255）</span></span><br><span class="line"><span class="comment">//! [normalize]</span></span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"Input Image"</span>, I);    </span><br><span class="line">imshow(<span class="string">"spectrum magnitude"</span>, magI);</span><br><span class="line">waitKey();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;离散傅里叶变换&quot;&gt;&lt;a href=&quot;#离散傅里叶变换&quot; class=&quot;headerlink&quot; title=&quot;离散傅里叶变换&quot;&gt;&lt;/a&gt;离散傅里叶变换&lt;/h2&gt;&lt;p&gt;原理：傅立叶变换是一个将函数分解的工具，任一函数都可以表示成无数个正弦和余弦函数的和的形式。对一张图像使用傅立叶变换就是将它分解成正弦和余弦两部分，也就是将图像从空间域(spatial domain)转换到频域(frequency domain)&lt;/p&gt;
&lt;h2 id=&quot;离散傅里叶变化-DFT&quot;&gt;&lt;a href=&quot;#离散傅里叶变化-DFT&quot; class=&quot;headerlink&quot; title=&quot;离散傅里叶变化 DFT&quot;&gt;&lt;/a&gt;离散傅里叶变化 DFT&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;图像去噪&lt;/strong&gt;： 当图像出现的噪声是有规律的，去某个频率的波，比如高斯噪声。但是当出现的噪声是没有规律的，随机出现的一些东西，DFT是没有作用的。&lt;/p&gt;
&lt;h2 id=&quot;离散余弦变换-DCT&quot;&gt;&lt;a href=&quot;#离散余弦变换-DCT&quot; class=&quot;headerlink&quot; title=&quot;离散余弦变换 DCT&quot;&gt;&lt;/a&gt;离散余弦变换 DCT&lt;/h2&gt;&lt;p&gt;图像的余弦波由实偶函数组成&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图像压缩&lt;/strong&gt;：JPEG格式的图片就是用Huffman编码方式压缩图片的DCT的系数&lt;/p&gt;
    
    </summary>
    
    
      <category term="opencv" scheme="http://yoursite.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>opencv基本绘图</title>
    <link href="http://yoursite.com/2018/05/14/opencv%E5%9F%BA%E6%9C%AC%E7%BB%98%E5%9B%BE/"/>
    <id>http://yoursite.com/2018/05/14/opencv基本绘图/</id>
    <published>2018-05-14T03:37:13.000Z</published>
    <updated>2018-05-14T03:38:53.823Z</updated>
    
    <content type="html"><![CDATA[<p>PS：其实本来不想写这篇的，实在太简单了，但是当做个检索吧，以备不时之需~~</p><p><a href="https://blog.csdn.net/ubunfans/article/details/24421981" target="_blank" rel="noopener">https://blog.csdn.net/ubunfans/article/details/24421981</a></p><a id="more"></a><h3 id="Point"><a href="#Point" class="headerlink" title="Point"></a>Point</h3><h3 id="Scalar"><a href="#Scalar" class="headerlink" title="Scalar"></a>Scalar</h3><h3 id="Rectangle"><a href="#Rectangle" class="headerlink" title="Rectangle"></a>Rectangle</h3><h3 id="Line"><a href="#Line" class="headerlink" title="Line"></a>Line</h3><h3 id="Circle"><a href="#Circle" class="headerlink" title="Circle"></a>Circle</h3><h3 id="Ellipse"><a href="#Ellipse" class="headerlink" title="Ellipse"></a>Ellipse</h3><h3 id="PolyLine-多边形的绘制"><a href="#PolyLine-多边形的绘制" class="headerlink" title="PolyLine   多边形的绘制"></a>PolyLine   多边形的绘制</h3><h3 id="PutText-在窗口显示文本-但是只能显示英文，中文不支持"><a href="#PutText-在窗口显示文本-但是只能显示英文，中文不支持" class="headerlink" title="PutText     在窗口显示文本(但是只能显示英文，中文不支持)"></a>PutText     在窗口显示文本(但是<strong>只能显示英文</strong>，中文不支持)</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：其实本来不想写这篇的，实在太简单了，但是当做个检索吧，以备不时之需~~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ubunfans/article/details/24421981&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/ubunfans/article/details/24421981&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="opencv" scheme="http://yoursite.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>图像读取的四种方法</title>
    <link href="http://yoursite.com/2018/05/14/%E5%9B%BE%E5%83%8F%E8%AF%BB%E5%8F%96%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/14/图像读取的四种方法/</id>
    <published>2018-05-14T03:06:31.000Z</published>
    <updated>2018-05-14T03:09:23.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扫描、读取图像的四种方法"><a href="#扫描、读取图像的四种方法" class="headerlink" title="扫描、读取图像的四种方法"></a>扫描、读取图像的四种方法</h2><p>1.C operator [] 指针</p><p>2.iterator 迭代法 用迭代器遍历 [推荐使用]</p><p>3.on-the-fly address generation  .at()函数</p><p>4.LUT function [推荐使用]</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扫描图像的四种方法的比较</span></span><br><span class="line"><span class="comment">//输入的三个参数  imageName.jpg  divideWith  intValueToReduce [G](可省略)</span></span><br><span class="line"><span class="comment">//项目属性需要更改：项目属性 -&gt; 配置属性 -&gt; C/C++ -&gt; 代码生成 -&gt; 运行库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/utility.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgcodecs.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span></span><br><span class="line">&lt;&lt; <span class="string">"\n--------------------------------------------------------------------------"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"This program shows how to scan image objects in OpenCV (cv::Mat)."</span></span><br><span class="line">&lt;&lt; <span class="string">" we take an input image and divide the native color palette (255) with the input. "</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"Shows C operator[] method, iterators and at function for on-the-fly item address calculation."</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"./输入三个参数 &lt;imageNameToUse&gt; &lt;divideWith&gt; &lt;G&gt;(可省略)"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"if you add a G parameter the image is processed in gray scale"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"--------------------------------------------------------------------------"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat&amp; <span class="title">ScanImageAndReduceC</span><span class="params">(Mat&amp; I, <span class="keyword">const</span> uchar* table)</span></span>;</span><br><span class="line"><span class="function">Mat&amp; <span class="title">ScanImageAndReduceIterator</span><span class="params">(Mat&amp; I, <span class="keyword">const</span> uchar* table)</span></span>;</span><br><span class="line"><span class="function">Mat&amp; <span class="title">ScanImageAndReduceRandomAccess</span><span class="params">(Mat&amp; I, <span class="keyword">const</span> uchar * table)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">help();</span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Not enough parameters"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mat I, J;</span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">4</span> &amp;&amp; !<span class="built_in">strcmp</span>(argv[<span class="number">3</span>], <span class="string">"G"</span>))</span><br><span class="line">I = imread(argv[<span class="number">1</span>], IMREAD_GRAYSCALE);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">I = imread(argv[<span class="number">1</span>], IMREAD_COLOR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (I.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"The image"</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="string">" could not be loaded."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用命令行参数argv[2]给出的整数进行颜色缩减</span></span><br><span class="line"><span class="keyword">int</span> divideWith = <span class="number">0</span>; <span class="comment">// convert our input string to number - C++ style</span></span><br><span class="line"><span class="built_in">stringstream</span> s;</span><br><span class="line">s &lt;&lt; argv[<span class="number">2</span>];</span><br><span class="line">s &gt;&gt; divideWith;</span><br><span class="line"><span class="keyword">if</span> (!s || !divideWith)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Invalid number entered for dividing. "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找表</span></span><br><span class="line">uchar table[<span class="number">256</span>]; <span class="comment">//查找表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">table[i] = (uchar)(divideWith * (i / divideWith));</span><br><span class="line"><span class="comment">//divideWith=10时，0到9取为0，10到19取为10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时间-单位毫秒</span></span><br><span class="line"><span class="comment">// getTickCount() 返回CPU自某个事件以来走过的时钟周期数</span></span><br><span class="line"><span class="comment">// getTickFrequency()  返回CPU一秒钟所走的时钟周期数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> times = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">double</span> t;</span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line">t = (<span class="keyword">double</span>)getTickCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cv::Mat clone_i = I.clone();</span><br><span class="line">J = ScanImageAndReduceC(clone_i, table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t = <span class="number">1000</span> * ((<span class="keyword">double</span>)getTickCount() - t) / getTickFrequency();</span><br><span class="line">t /= times;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Time of reducing with the C operator [] (averaged for "</span></span><br><span class="line">&lt;&lt; times &lt;&lt; <span class="string">" runs): "</span> &lt;&lt; t &lt;&lt; <span class="string">" milliseconds."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line">t = (<span class="keyword">double</span>)getTickCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cv::Mat clone_i = I.clone();</span><br><span class="line">J = ScanImageAndReduceIterator(clone_i, table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t = <span class="number">1000</span> * ((<span class="keyword">double</span>)getTickCount() - t) / getTickFrequency();</span><br><span class="line">t /= times;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Time of reducing with the iterator (averaged for "</span></span><br><span class="line">&lt;&lt; times &lt;&lt; <span class="string">" runs): "</span> &lt;&lt; t &lt;&lt; <span class="string">" milliseconds."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//方法3</span></span><br><span class="line">t = (<span class="keyword">double</span>)getTickCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cv::Mat clone_i = I.clone();</span><br><span class="line">ScanImageAndReduceRandomAccess(clone_i, table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t = <span class="number">1000</span> * ((<span class="keyword">double</span>)getTickCount() - t) / getTickFrequency();</span><br><span class="line">t /= times;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Time of reducing with the on-the-fly address generation - at function (averaged for "</span></span><br><span class="line">&lt;&lt; times &lt;&lt; <span class="string">" runs): "</span> &lt;&lt; t &lt;&lt; <span class="string">" milliseconds."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//方法3</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//方法4</span></span><br><span class="line"><span class="comment">//最被推荐的用于实现批量图像元素查找和更该操作图像方法，在图像处理中，对于一个给定的值，将其替换成其他的值是一个很常见的操作</span></span><br><span class="line"><span class="function">Mat <span class="title">lookUpTable</span><span class="params">(<span class="number">1</span>, <span class="number">256</span>, CV_8U)</span></span>;</span><br><span class="line">uchar* p = lookUpTable.ptr();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">p[i] = table[i]; <span class="comment">//table数组的值赋给lookUpTable Mat</span></span><br><span class="line"><span class="comment">//! [table-init]</span></span><br><span class="line"></span><br><span class="line">t = (<span class="keyword">double</span>)getTickCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; ++i)</span><br><span class="line"><span class="comment">//! [table-use]</span></span><br><span class="line">LUT(I, lookUpTable, J);</span><br><span class="line"><span class="comment">//! [table-use]</span></span><br><span class="line"></span><br><span class="line">t = <span class="number">1000</span> * ((<span class="keyword">double</span>)getTickCount() - t) / getTickFrequency();</span><br><span class="line">t /= times;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Time of reducing with the LUT function (averaged for "</span></span><br><span class="line">&lt;&lt; times &lt;&lt; <span class="string">" runs): "</span> &lt;&lt; t &lt;&lt; <span class="string">" milliseconds."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="comment">//方法4</span></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! [scan-c] c语言风格，用指针</span></span><br><span class="line"><span class="function">Mat&amp; <span class="title">ScanImageAndReduceC</span><span class="params">(Mat&amp; I, <span class="keyword">const</span> uchar* <span class="keyword">const</span> table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// accept only char type matrices</span></span><br><span class="line">CV_Assert(I.depth() == CV_8U); <span class="comment">//CV_Assert()若括号中的表达式值为false，则返回一个错误信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> channels = I.channels();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nRows = I.rows;</span><br><span class="line"><span class="keyword">int</span> nCols = I.cols * channels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (I.isContinuous()) <span class="comment">//判断图像在内存中是否连续存储</span></span><br><span class="line">&#123;</span><br><span class="line">nCols *= nRows;   <span class="comment">//若图像连续存储将图像作为一维数组</span></span><br><span class="line">nRows = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若图像连续存储，则可以将图像的数据看成是一个一维数组</span></span><br><span class="line"><span class="comment">//p（uchar*）就是指向图像数据的第一个字节的，因此可以用data指针访问图像的数据,从而加速Mat图像的访问速度</span></span><br><span class="line"><span class="comment">//一般经过裁剪的Mat图像，都不再连续了</span></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">uchar* p;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nRows; ++i)</span><br><span class="line">&#123;</span><br><span class="line">p = I.ptr&lt;uchar&gt;(i);</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nCols; ++j)</span><br><span class="line">&#123;</span><br><span class="line">p[j] = table[p[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> I;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//! [scan-c]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代法</span></span><br><span class="line"><span class="comment">//! [scan-iterator] 获得图像矩阵的begin和end</span></span><br><span class="line"><span class="function">Mat&amp; <span class="title">ScanImageAndReduceIterator</span><span class="params">(Mat&amp; I, <span class="keyword">const</span> uchar* <span class="keyword">const</span> table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// accept only char type matrices</span></span><br><span class="line">CV_Assert(I.depth() == CV_8U);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> channels = I.channels();</span><br><span class="line"><span class="keyword">switch</span> (channels)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line">  MatIterator_&lt;uchar&gt; it, end;</span><br><span class="line">  <span class="keyword">for</span> (it = I.begin&lt;uchar&gt;(), end = I.end&lt;uchar&gt;(); it != end; ++it)</span><br><span class="line">  *it = table[*it];</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">&#123;</span><br><span class="line">  MatIterator_&lt;Vec3b&gt; it, end;</span><br><span class="line">  <span class="keyword">for</span> (it = I.begin&lt;Vec3b&gt;(), end = I.end&lt;Vec3b&gt;(); it != end; ++it)</span><br><span class="line">  &#123;</span><br><span class="line">  (*it)[<span class="number">0</span>] = table[(*it)[<span class="number">0</span>]];</span><br><span class="line">  (*it)[<span class="number">1</span>] = table[(*it)[<span class="number">1</span>]];</span><br><span class="line">  (*it)[<span class="number">2</span>] = table[(*it)[<span class="number">2</span>]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> I;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//! [scan-iterator]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// On-the-fly 地址计算</span></span><br><span class="line"><span class="comment">//! [scan-random] 这个方法并不推荐被用来进行图像扫描，需要知道元素的所在行数与列数还有数据类型</span></span><br><span class="line"><span class="function">Mat&amp; <span class="title">ScanImageAndReduceRandomAccess</span><span class="params">(Mat&amp; I, <span class="keyword">const</span> uchar* <span class="keyword">const</span> table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// accept only char type matrices</span></span><br><span class="line">CV_Assert(I.depth() == CV_8U);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> channels = I.channels();</span><br><span class="line"><span class="keyword">switch</span> (channels)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; I.rows; ++i)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; I.cols; ++j)</span><br><span class="line">  I.at&lt;uchar&gt;(i, j) = table[I.at&lt;uchar&gt;(i, j)];</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">&#123;</span><br><span class="line">  Mat_&lt;Vec3b&gt; _I = I;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; I.rows; ++i)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; I.cols; ++j)</span><br><span class="line">  &#123;</span><br><span class="line">  _I(i, j)[<span class="number">0</span>] = table[_I(i, j)[<span class="number">0</span>]];</span><br><span class="line">  _I(i, j)[<span class="number">1</span>] = table[_I(i, j)[<span class="number">1</span>]];</span><br><span class="line">  _I(i, j)[<span class="number">2</span>] = table[_I(i, j)[<span class="number">2</span>]];</span><br><span class="line">  &#125;</span><br><span class="line">  I = _I;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> I;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果比较"><a href="#结果比较" class="headerlink" title="结果比较"></a>结果比较</h2><p>不同的图片几种方法得到的执行时间差很大。                                                        <strong>尽量使用 OpenCV 内置函数</strong>，调用LUT 函数可以获得最快的速度，这是因为OpenCV库可以通过英特尔线程架构启用多线程。                                                                                        指针法也很快，但是前提是指针连续。                                                                                        .at()函数方法并不推荐被用来进行图像扫描。</p><h2 id="程序解读"><a href="#程序解读" class="headerlink" title="程序解读"></a>程序解读</h2><h3 id="1-计算运算时间的方法"><a href="#1-计算运算时间的方法" class="headerlink" title="1.计算运算时间的方法"></a>1.计算运算时间的方法</h3><p>getTickCount() 返回CPU自某个事件以来走过的时钟周期数<br>getTickFrequency()  返回CPU一秒钟所走的时钟周期数</p><h3 id="2-查找表缩短颜色空间"><a href="#2-查找表缩短颜色空间" class="headerlink" title="2.查找表缩短颜色空间"></a>2.查找表缩短颜色空间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uchar table[<span class="number">256</span>]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">       table[i] = divideWith* (i/divideWith); <span class="comment">//当divideWith=10时，0到9取为0，10到19取为10</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;扫描、读取图像的四种方法&quot;&gt;&lt;a href=&quot;#扫描、读取图像的四种方法&quot; class=&quot;headerlink&quot; title=&quot;扫描、读取图像的四种方法&quot;&gt;&lt;/a&gt;扫描、读取图像的四种方法&lt;/h2&gt;&lt;p&gt;1.C operator [] 指针&lt;/p&gt;
&lt;p&gt;2.iterator 迭代法 用迭代器遍历 [推荐使用]&lt;/p&gt;
&lt;p&gt;3.on-the-fly address generation  .at()函数&lt;/p&gt;
&lt;p&gt;4.LUT function [推荐使用]&lt;/p&gt;
    
    </summary>
    
    
      <category term="opencv" scheme="http://yoursite.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法大总结</title>
    <link href="http://yoursite.com/2018/05/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%A4%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/05/11/机器学习算法大总结/</id>
    <published>2018-05-11T07:42:09.000Z</published>
    <updated>2018-05-11T08:10:15.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习算法分类"><a href="#机器学习算法分类" class="headerlink" title="机器学习算法分类"></a>机器学习算法分类</h1><ul><li><p>监督学习(有标签)      根据预测结果分成两类</p><ul><li>分类问题-离散值</li><li>回归问题-连续值</li></ul></li><li><p>无监督学习(无标签)</p></li><li><p>半监督学习(一半有标签，一般无标签)</p><p><a id="more"></a>​</p></li></ul><h2 id="回归算法-Regression-Algorithms"><a href="#回归算法-Regression-Algorithms" class="headerlink" title="回归算法(Regression Algorithms)"></a>回归算法(Regression Algorithms)</h2><p>自变量与因变量之间的显著关系，下面列出了七种回归问题</p><p><a href="https://www.jianshu.com/p/15dd20f8d02c" target="_blank" rel="noopener">https://www.jianshu.com/p/15dd20f8d02c</a></p><h2 id="基于实例的算法-Instance-based-Algorithms"><a href="#基于实例的算法-Instance-based-Algorithms" class="headerlink" title="基于实例的算法(Instance-based Algorithms)"></a>基于实例的算法(Instance-based Algorithms)</h2><p><strong>最后建成的模型，对原始数据样本实例依旧有很强的依赖性</strong>。这类算法在做预测决策时，一般都是使用某类相似度准则，去<strong>比对待预测的样本和原始样本的相近度</strong>，再给出相应的预测结果。</p><h2 id="决策树类算法-Decision-Tree-Algorithms"><a href="#决策树类算法-Decision-Tree-Algorithms" class="headerlink" title="决策树类算法(Decision Tree Algorithms)"></a>决策树类算法(Decision Tree Algorithms)</h2><p>决策树是一个树结构，每个非叶节点表示一个<strong>特征属性</strong>上的测试，每个分支代表这个特征属性在某个值域上的输出，而每个叶节点存放一个<strong>类别</strong>。使用决策树进行决策的过程就是从根节点开始，测试待分类项中相应的特征属性，并按照其值选择输出分支，直到到达叶子节点，<strong>将叶子节点存放的类别作为决策结果</strong>。                    PS：西瓜书里的这张图很好解释啥叫决策树，还好学了数据结构里的树结构，现在感觉学的东西都是相通的~~</p><p><img src="https://pic3.zhimg.com/v2-39d109b46ea4f34d5efbf67edc11d57d_r.jpg" alt="决策树"></p><h2 id="贝叶斯类算法-Bayesian-Algorithms"><a href="#贝叶斯类算法-Bayesian-Algorithms" class="headerlink" title="贝叶斯类算法(Bayesian Algorithms)"></a>贝叶斯类算法(Bayesian Algorithms)</h2><p>在分类和回归问题中，隐含使用了贝叶斯原理的算法</p><p>PS：都是概率统计里的数学知识啊~概率服从一定的分布( y随x的变化规律)    <del>下面这篇博客写的简直太好了，用了一个栗子讲解朴素贝叶斯</del></p><p><a href="https://blog.csdn.net/amds123/article/details/70173402" target="_blank" rel="noopener">https://blog.csdn.net/amds123/article/details/70173402</a></p><p>用上面这篇博客里的栗子解释朴素贝叶斯：如果一对男女朋友，男生想女生求婚，男生的四个特点分别是不帅，性格不好，身高矮，不上进，请你判断一下女生是嫁还是不嫁？                                                                这是一个典型的分类问题，<strong>转为数学问题就是比较p(嫁|(不帅、性格不好、身高矮、不上进))与p(不嫁|(不帅、性格不好、身高矮、不上进))的概率</strong>，谁的概率大，我就能给出嫁或者不嫁的答案！    </p><h2 id="聚类算法-Clustering-Algorithms"><a href="#聚类算法-Clustering-Algorithms" class="headerlink" title="聚类算法(Clustering Algorithms)"></a>聚类算法(Clustering Algorithms)</h2><p>用于进行数据分类，把不同的数据分到不同的群组</p><p><a href="https://miketech.it/k-means/" target="_blank" rel="noopener">https://miketech.it/k-means/</a>        </p><h2 id="关联规则算法-Association-Rule-Learning-Algorithms"><a href="#关联规则算法-Association-Rule-Learning-Algorithms" class="headerlink" title="关联规则算法(Association Rule Learning Algorithms)"></a>关联规则算法(Association Rule Learning Algorithms)</h2><p>抽取出最能解释观察到的训练样本之间关联关系的规则，也就是获取一个事件和其他事件之间依赖或关的知识                利用一些度量指标来分辨数据库中存在的强规则，也就是说<strong>关联规则挖掘是用于知识发现</strong>，而<strong>非预测</strong>，所以是属于<strong>无监督</strong>的机器学习方法                                                                                        <a href="https://www.jianshu.com/p/7d459ace31ab" target="_blank" rel="noopener">https://www.jianshu.com/p/7d459ace31ab</a></p><h2 id="人工神经网络类算法-Artificial-Neural-Network-Algorithms"><a href="#人工神经网络类算法-Artificial-Neural-Network-Algorithms" class="headerlink" title="人工神经网络类算法(Artificial Neural Network Algorithms)"></a>人工神经网络类算法(Artificial Neural Network Algorithms)</h2><p>人工神经网络(ANN) ，简称神经网络(缩写)，模拟生物神经网络，是一类模式匹配算法。通常用于解决分类和回归问题，其中深度学习就是其中的一类算法</p><h2 id="深度学习-Deep-Learning-Algorithms"><a href="#深度学习-Deep-Learning-Algorithms" class="headerlink" title="深度学习(Deep Learning Algorithms)"></a>深度学习(Deep Learning Algorithms)</h2><p>PS：Deap Learning和NN的区别，说实在的除了网络层级不同，下面的那个特征挑选，真没懂。</p><p><a href="https://zhidao.baidu.com/question/554111494800207612.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/554111494800207612.html</a></p><ul><li>神经网络只有输入层、隐藏层、输出层<br>深度学习 输入层 - 卷积层 -降维层 -卷积层 - 降维层 – …. – 隐藏层 -输出层</li><li>多层神经网络做的步骤是：特征-&gt;值，<strong>特征是人工挑选</strong>。<br>深度学习做的步骤是：信号-&gt;特征-&gt;值，<strong>特征是网络自己选择</strong>。</li></ul><h2 id="降维算法-Dimensionality-Reduction-Algorithms"><a href="#降维算法-Dimensionality-Reduction-Algorithms" class="headerlink" title="降维算法(Dimensionality Reduction Algorithms)"></a>降维算法(Dimensionality Reduction Algorithms)</h2><p>降维就是指采用某种映射方法，<strong>将原高维空间中的数据点映射到低维度的空间</strong>， 降维算法一般在数据的<strong>可视化</strong>，或者是降低数据计算空间有很大的作用。它作为一种机器学习的算法，很多时候用它先<strong>处理数据</strong>，再灌入别的机器学习算法学习。</p><h2 id="模型融合算法-Ensemble-Algorithms"><a href="#模型融合算法-Ensemble-Algorithms" class="headerlink" title="模型融合算法(Ensemble Algorithms)"></a>模型融合算法(Ensemble Algorithms)</h2><p>融合不算是一种机器学习算法，而更像是一种<strong>优化手段</strong>，它通常是结合多个简单的弱机器学习算法，去做更可靠的决策。                                                                                                                                            拿分类问题举个例，直观的理解，就是单个分类器的分类是可能出错，不可靠的，但是如果<strong>多个分类器投票，那可靠度就会高很多</strong>。</p><h1 id="机器学习算法使用图谱"><a href="#机器学习算法使用图谱" class="headerlink" title="机器学习算法使用图谱"></a>机器学习算法使用图谱</h1><p>scikit-learn作为一个丰富的python机器学习库，实现了绝大多数机器学习的算法。</p><p><img src="https://img-blog.csdn.net/20160930051801241?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>上图是scikit-learn的路径图，分成了分类、聚类、回归和降维四个方法</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;机器学习算法分类&quot;&gt;&lt;a href=&quot;#机器学习算法分类&quot; class=&quot;headerlink&quot; title=&quot;机器学习算法分类&quot;&gt;&lt;/a&gt;机器学习算法分类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;监督学习(有标签)      根据预测结果分成两类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分类问题-离散值&lt;/li&gt;
&lt;li&gt;回归问题-连续值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;无监督学习(无标签)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;半监督学习(一半有标签，一般无标签)&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>opencv(二) imgproc 模块</title>
    <link href="http://yoursite.com/2018/05/09/opencv-%E4%BA%8C-imgproc-%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/05/09/opencv-二-imgproc-模块/</id>
    <published>2018-05-09T13:37:55.000Z</published>
    <updated>2018-05-12T12:58:47.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="imgproc模块"><a href="#imgproc模块" class="headerlink" title="imgproc模块"></a>imgproc模块</h2><ul><li><p>PS：具体代码参考opencv /samples里的源码，这里不放了</p><h2 id="1-平滑图像-模糊"><a href="#1-平滑图像-模糊" class="headerlink" title="1. 平滑图像/模糊"></a>1. 平滑图像/模糊</h2><p>(1)模糊 cv :: blur                                                                            (2)高斯平滑 cv :: GaussianBlur                                                                                                                                            (3)中值滤波 cv :: medianBlur                                                                                                                                                            (4)双边滤波 cv :: bilateralFilter</p><p>​</p><h2 id="2-腐蚀和膨胀"><a href="#2-腐蚀和膨胀" class="headerlink" title="2. 腐蚀和膨胀"></a>2. 腐蚀和膨胀</h2><p>看图理解膨胀腐蚀                                                                                                                                        (1)腐蚀 cv::erode  输出像素的值是原图被掩膜所覆盖的所有像素中取<strong>最小像素</strong>                                                                                                                                            <img src="https://img.w3cschool.cn/attachments/image/20170901/1504236679969494.png" alt="腐蚀">                                                                                                                                                            (2)膨胀 cv::dilate   输出像素的值是原图被掩膜所覆盖的所有像素中取<strong>最大像素</strong>                                                                                                    <img src="https://img.w3cschool.cn/attachments/image/20170901/1504236632842236.gif" alt="膨胀"></p><p>​</p><h2 id="3-更多形态变化"><a href="#3-更多形态变化" class="headerlink" title="3. 更多形态变化"></a>3. 更多形态变化</h2><p>cv :: morphologyEx<br>开运算 、闭运算 、形态梯度、 顶帽 、黑帽</p><a id="more"></a><p>​</p><h2 id="4-Hit-or-Miss-击中击不中"><a href="#4-Hit-or-Miss-击中击不中" class="headerlink" title="4. Hit-or-Miss 击中击不中"></a>4. Hit-or-Miss 击中击不中</h2><p>cv :: morphologyEx 函数有一个参数 MORPH_HITMISS 实现击中击不中，不过是比较<strong>新的opencv版本</strong>才有</p><p>PS：知乎上的大神说就是一个完全的<strong>模板匹配过程</strong>                                                                                                                                                        原理看这篇比较简单  <a href="https://blog.csdn.net/horseinch/article/details/50127955" target="_blank" rel="noopener">https://blog.csdn.net/horseinch/article/details/50127955</a>                                                        但是结合具体找钥匙的应用，一下子就明白啥叫击中击不中，猛推这篇博文，简直一语戳醒我~~                                            <strong>击中击不中变换是形态学中用来检测特定形状所处位置的一个基本工具</strong>                                                                                                                                                                        <a href="https://blog.csdn.net/jinshengtao/article/details/20707711" target="_blank" rel="noopener">https://blog.csdn.net/jinshengtao/article/details/20707711</a></p><p>​</p><h2 id="5-使用形态学操作来提取水平和垂直线，加水印的方法"><a href="#5-使用形态学操作来提取水平和垂直线，加水印的方法" class="headerlink" title="5. 使用形态学操作来提取水平和垂直线，加水印的方法"></a>5. 使用形态学操作来提取水平和垂直线，加水印的方法</h2><p>(1) 形态学是一组图像处理操作，其基于预定义的也称为内核的结构元素来处理图像，两个最基本的形态操作是腐蚀和膨胀。                                                                                                获得水平线，根据结构元素<img src="https://img.w3cschool.cn/attachments/image/20170901/1504236903564726.png" alt="水平">先腐蚀得到水平线，再膨胀加粗</p><p>同理，获得竖直线，只不过结构元素需要改变<img src="https://img.w3cschool.cn/attachments/image/20170901/1504236942451433.png" alt="竖直">                                                        这种方法结构元素的大小和形状很关键，不然找直线还是用霍夫变换吧</p><p>​</p><p>(2) PS：这个程序里用到了 copyTo 加了个mask参数，查了一下，竟然是一种<strong>做水印的方法</strong>！！神奇~~                                                                                                                        src.copyTo(dst)     src.copyTo(dst, mask)                                                                                                            原理：<strong>src为水印图片，mask作为一个掩模板，mask在(i, j)其值为1，则把src.at(i, j)处的值直接赋给dst.at(i, j)                                        mask在(i, j)其值为0，dst.at(i, j)处保留其原始像素值</strong>                                                            (mask 可以由src 经过阈值化得到，mask为1的地方就是水印src需要加上去的地方，mask为0的地方，就是水印src，即原图dst不会被掩盖)                                                                                                                水印案例：可以参考下面这个博文~~                                                                                                                                                                                                                                <a href="http://www.cnblogs.com/xianglan/archive/2011/07/30/2122186.html" target="_blank" rel="noopener">http://www.cnblogs.com/xianglan/archive/2011/07/30/2122186.html</a></p><p>​</p><h2 id="6-图像金字塔"><a href="#6-图像金字塔" class="headerlink" title="6. 图像金字塔"></a>6. 图像金字塔</h2><p>可以看浅墨大神写的 ~ ~ <a href="https://blog.csdn.net/poem_qianmo/article/details/26157633" target="_blank" rel="noopener">https://blog.csdn.net/poem_qianmo/article/details/26157633</a></p><p>图像金字塔是图像中多尺度表达的一种，是来源于同一张原始图的图像集合。                                                        越向上层级越大，图像越小，分辨率越低，金字塔<strong>底部是高分辨率图像</strong>，而<strong>顶部是低分辨率</strong>的近似。</p><h3 id="1-图像金字塔和采样"><a href="#1-图像金字塔和采样" class="headerlink" title="(1)图像金字塔和采样"></a>(1)图像金字塔和采样</h3><ul><li>高斯金字塔: 用来向下采样，从低层向上(这句话一定要看下面这张图理解)</li><li>拉普拉斯金字塔: <strong>将拉普拉斯金字塔理解为高斯金字塔的逆形式</strong></li></ul></li></ul><ul><li><p>向上采样：pyrUp                                                                                                                                                                                        </p><ul><li>向下采样：pyrDown                                                                    </li></ul><p>PS：<strong>采样方向和金字塔方向相反</strong>(重要的事情不说三遍) 在这里卡了好久，<strong>金字塔的上下按照层级来，采样的上下按照尺寸来</strong>，直接上图吧，好理解~~</p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/pyramid.png" alt=""></p><p><strong>pryUp不是PryDown的逆操作</strong>。图像首先在每个维度上扩大为原来的两倍，新增的行（偶数行）以0填充，用指定的滤波器卷积，估计“丢失”像素的近似值。</p><p>pryDown( )是一个会丢失信息的函数。为了恢复原来更高的分辨率的图像，要获得由降采样操作丢失的信息，这些数据就和拉普拉斯金字塔有关系。</p><h3 id="2-图像金字塔的作用"><a href="#2-图像金字塔的作用" class="headerlink" title="(2) 图像金字塔的作用"></a>(2) 图像金字塔的作用</h3></li><li><p>图像压缩</p></li><li><p>图像金字塔<strong>构建尺度空间</strong>，用于<strong>目标检测</strong></p><p>下面这篇博文提到了SIFT特征，没想到图像金字塔引出的尺寸空间这么有用~~</p><p><a href="https://blog.csdn.net/xiaowei_cqu/article/details/8069548" target="_blank" rel="noopener">https://blog.csdn.net/xiaowei_cqu/article/details/8069548</a></p><h3 id="3-SIFT"><a href="#3-SIFT" class="headerlink" title="(3) SIFT"></a>(3) SIFT</h3><p>SIFT特征对旋转、<strong>尺度缩放</strong>、亮度变化等保持不变性，是非常稳定的局部特征                                    下面这篇博文能够快速理解<strong>SIFT特征用于目标检测</strong>                                                        <a href="https://blog.csdn.net/haluoluo211/article/details/52767143" target="_blank" rel="noopener">https://blog.csdn.net/haluoluo211/article/details/52767143</a></p><p>​</p><h2 id="7-阈值操作"><a href="#7-阈值操作" class="headerlink" title="7. 阈值操作"></a>7. 阈值操作</h2></li><li><p>cv :: threshold</p></li><li><p>cv :: inRange</p><p>区别：两个函数都能实现二值化                                                                                                                      但是 <strong>inRange()可以同时针对多通道操作</strong>，使用起来非常方便</p><p>​</p><h2 id="8-线性滤波器"><a href="#8-线性滤波器" class="headerlink" title="8. 线性滤波器"></a>8. 线性滤波器</h2><p>cv::filter2D</p><p>​</p><h2 id="9-设置边框"><a href="#9-设置边框" class="headerlink" title="9. 设置边框"></a>9. 设置边框</h2><p>cv::copyMakeBorder</p><p>除了字面上的添加边框外，还有一个实际用处，如果<strong>评估点位于图像的边缘，如何卷积图像</strong>？                                                                                                            大多数OpenCV功能是将给定的图像复制到另一个稍大的图像上，然后用上式自动填充边界</p><p><strong>随机数生成器RNG</strong>                                                                             uniform函数可以返回指定范围的随机数，gaussian函数返回一个高斯随机数，fill则用随机数填充矩阵                <a href="https://blog.csdn.net/zyttae/article/details/41719349" target="_blank" rel="noopener">https://blog.csdn.net/zyttae/article/details/41719349</a></p><p>​</p><h2 id="10-霍夫变换"><a href="#10-霍夫变换" class="headerlink" title="10. 霍夫变换"></a>10. 霍夫变换</h2><h3 id="1-Hough-Line变换-找直线"><a href="#1-Hough-Line变换-找直线" class="headerlink" title="1.Hough Line变换 找直线"></a>1.Hough Line变换 找直线</h3><p>cv::HoughLines<br>cv::HoughLinesP</p><h3 id="2-Hough-Circle变换-找圆-圆心和半径"><a href="#2-Hough-Circle变换-找圆-圆心和半径" class="headerlink" title="2.Hough Circle变换 找圆(圆心和半径)"></a>2.Hough Circle变换 找圆(圆心和半径)</h3><p>cv::HoughCircles</p><p>​</p><h2 id="11-重映射（Remapping）"><a href="#11-重映射（Remapping）" class="headerlink" title="11.重映射（Remapping）"></a>11.重映射（Remapping）</h2><p>cv::remap</p><p>重映射，重新映射，就是从图像中的一个位置获取像素并将它们定位在新图像中的另一位置的过程。为了完成映射过程，可能需要对非整数像素位置进行一些<strong>插值</strong>，因为在源图像和目的图像之间不一定存在一对一像素的对应关系。</p><p><a href="https://blog.csdn.net/poem_qianmo/article/details/30974513" target="_blank" rel="noopener">https://blog.csdn.net/poem_qianmo/article/details/30974513</a></p><p>​</p><h2 id="12-仿射变换（Affine-Transformations）"><a href="#12-仿射变换（Affine-Transformations）" class="headerlink" title="12. 仿射变换（Affine Transformations）"></a>12. 仿射变换（Affine Transformations）</h2><p>实现仿射：                                                                                                                cv::warpAffine   可以实现平移(Translation)、缩放(Scale)、旋转(Rotation)</p><p>计算仿射矩阵的两种方法    ：                                                          cv::getRotationMatrix2D  根据三个系数<strong>center旋转中心 、angle旋转角度、 scale、缩放系数</strong>计算仿射矩阵，用                                                                                        cv::getAffineTransform  根据三个点的映射计算仿射矩阵</p><p>2 x 3的矩阵M来表示仿射变换        <img src="http://p8ge6t5tt.bkt.clouddn.com/affine.png" alt=""></p><p>再上浅墨大神的教程~~ <a href="https://blog.csdn.net/poem_qianmo/article/details/33320997" target="_blank" rel="noopener">https://blog.csdn.net/poem_qianmo/article/details/33320997</a></p><p>​</p><h2 id="13-直方图"><a href="#13-直方图" class="headerlink" title="13. 直方图"></a>13. 直方图</h2><h3 id="1-计算直方图"><a href="#1-计算直方图" class="headerlink" title="1.计算直方图"></a>1.计算直方图</h3><p>cv::split 将图像分割成对应的平面，将图像分解为R，G和B平面<br>cv::calcHist 来计算图像数组的直方图<br>cv::normalize 对数组进行归一化</p><h3 id="2-直方图均衡化"><a href="#2-直方图均衡化" class="headerlink" title="2.直方图均衡化"></a>2.直方图均衡化</h3><p>对图像中像素个数多的灰度级进行展宽，像素个数少的灰度进行压缩，从而提高了对比度和灰度色调的变化，使图像更加清晰)                                                                                                                                                cv::equalizeHis</p><h3 id="3-直方图比较"><a href="#3-直方图比较" class="headerlink" title="3.直方图比较"></a>3.直方图比较</h3><p>使用不同的指标来比较直方图，两个直方图相互匹配的程度，提供了四种比较方法                            cv::compareHist</p><h3 id="4-反向投影"><a href="#4-反向投影" class="headerlink" title="4.反向投影"></a>4.反向投影</h3><p><strong>反向投影图是指图像的某一位置上像素值用对应在直方图的所属于的bin上的值来代替该像素值</strong>，不想看文字，可以看下面这篇博文的数学描述                                                                                            <a href="https://blog.csdn.net/chenjiazhou12/article/details/22150421" target="_blank" rel="noopener">https://blog.csdn.net/chenjiazhou12/article/details/22150421</a>    </p><p>PS：开始觉得这个反向投影能有啥用啊，如果你和我一样，看看下面，反向投影在<strong>定位</strong>上可是很有用~~            反向投影用于在输入图像 (通常较大) 中<strong>查找特定的模板图像</strong> (通常较小) 最匹配的点或者区域最亮。                                    cv::calcBackProject </p><p>​</p><h2 id="15-模板匹配"><a href="#15-模板匹配" class="headerlink" title="15. 模板匹配"></a>15. 模板匹配</h2><p>通过滑动，从左到右，从上到下，在各个位置，比较模板和源图的匹配程度<br><strong>矩阵R用于存放metric</strong>，即匹配好坏程度的值 ，R中(x,y)存放对应位置的匹配度量</p><p>cv::matchTemplate() 用来搜索模板和输入图像之间的匹配<br>cv::minMaxLoc() 用来查找R矩阵，即匹配好坏程度中的最大值和最小值(以及位置)</p><p>​</p><h2 id="16-轮廓查找"><a href="#16-轮廓查找" class="headerlink" title="16. 轮廓查找"></a>16. 轮廓查找</h2><p>cv::findContours      查找轮廓<br>cv::drawContours     画轮廓</p><p>​</p><h2 id="17-凸包"><a href="#17-凸包" class="headerlink" title="17. 凸包"></a>17. 凸包</h2><p>凸包又叫凸壳，凸包能包含点集中所有的点，如果在集合A内连接任意两个点的直线段都在A的内部，则称集合A是凸形的。字面意思，就是一个多边型，没有凹的地方。</p><p><a href="https://blog.csdn.net/keith_bb/article/details/70194073" target="_blank" rel="noopener">https://blog.csdn.net/keith_bb/article/details/70194073</a></p><p>​</p><h2 id="18-为轮廓创建边界框和圆"><a href="#18-为轮廓创建边界框和圆" class="headerlink" title="18. 为轮廓创建边界框和圆"></a>18. 为轮廓创建边界框和圆</h2><p>cv::approxPolyDP  对边缘轮廓进行多边形拟合                                                                                                            对于拟合后的轮廓求包围盒</p><p><a href="http://www.cnblogs.com/mikewolf2002/p/3427079.html" target="_blank" rel="noopener">http://www.cnblogs.com/mikewolf2002/p/3427079.html</a></p><p>​</p><h2 id="19-空间矩，中心矩，归一化中心矩，Hu矩"><a href="#19-空间矩，中心矩，归一化中心矩，Hu矩" class="headerlink" title="19. 空间矩，中心矩，归一化中心矩，Hu矩"></a>19. 空间矩，中心矩，归一化中心矩，Hu矩</h2><p>PS：关于矩的概念，若不想深究，只看公式，可以看下面这篇~~<br>中心矩：<strong>平移不变性</strong><br>归一化中心矩：<strong>平移不变性，比例不变性</strong><br>Hu矩：利用二阶和三阶中心矩构造<strong>七个不变矩</strong>，具有<strong>平移、缩放、旋转不变性</strong><br><a href="https://blog.csdn.net/kuweicai/article/details/79027388" target="_blank" rel="noopener">https://blog.csdn.net/kuweicai/article/details/79027388</a></p><p>cv::moments 计算图像的中心矩<br>cv::HuMoments  由中心矩计算Hu矩<br>cv::contourArea 计算轮廓面积<br>cv::arcLength  计算封闭轮廓或曲线长度</p><p>​</p><h2 id="20-判断点在多边形内部还是外部"><a href="#20-判断点在多边形内部还是外部" class="headerlink" title="20. 判断点在多边形内部还是外部"></a>20. 判断点在多边形内部还是外部</h2><p>cv::pointPolygonTest  返回值是图像中的该点到某轮廓的最短距离，通过返回值的正负，判断该点在这个轮廓里面还是外面</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;imgproc模块&quot;&gt;&lt;a href=&quot;#imgproc模块&quot; class=&quot;headerlink&quot; title=&quot;imgproc模块&quot;&gt;&lt;/a&gt;imgproc模块&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;PS：具体代码参考opencv /samples里的源码，这里不放了&lt;/p&gt;
&lt;h2 id=&quot;1-平滑图像-模糊&quot;&gt;&lt;a href=&quot;#1-平滑图像-模糊&quot; class=&quot;headerlink&quot; title=&quot;1. 平滑图像/模糊&quot;&gt;&lt;/a&gt;1. 平滑图像/模糊&lt;/h2&gt;&lt;p&gt;(1)模糊 cv :: blur                                                                            (2)高斯平滑 cv :: GaussianBlur                                                                                                                                            (3)中值滤波 cv :: medianBlur                                                                                                                                                            (4)双边滤波 cv :: bilateralFilter&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;h2 id=&quot;2-腐蚀和膨胀&quot;&gt;&lt;a href=&quot;#2-腐蚀和膨胀&quot; class=&quot;headerlink&quot; title=&quot;2. 腐蚀和膨胀&quot;&gt;&lt;/a&gt;2. 腐蚀和膨胀&lt;/h2&gt;&lt;p&gt;看图理解膨胀腐蚀                                                                                                                                        (1)腐蚀 cv::erode  输出像素的值是原图被掩膜所覆盖的所有像素中取&lt;strong&gt;最小像素&lt;/strong&gt;                                                                                                                                            &lt;img src=&quot;https://img.w3cschool.cn/attachments/image/20170901/1504236679969494.png&quot; alt=&quot;腐蚀&quot;&gt;                                                                                                                                                            (2)膨胀 cv::dilate   输出像素的值是原图被掩膜所覆盖的所有像素中取&lt;strong&gt;最大像素&lt;/strong&gt;                                                                                                    &lt;img src=&quot;https://img.w3cschool.cn/attachments/image/20170901/1504236632842236.gif&quot; alt=&quot;膨胀&quot;&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;h2 id=&quot;3-更多形态变化&quot;&gt;&lt;a href=&quot;#3-更多形态变化&quot; class=&quot;headerlink&quot; title=&quot;3. 更多形态变化&quot;&gt;&lt;/a&gt;3. 更多形态变化&lt;/h2&gt;&lt;p&gt;cv :: morphologyEx&lt;br&gt;开运算 、闭运算 、形态梯度、 顶帽 、黑帽&lt;/p&gt;
    
    </summary>
    
    
      <category term="opencv" scheme="http://yoursite.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>opencv(一) HighGUI 模块</title>
    <link href="http://yoursite.com/2018/05/09/opencv-%E4%B8%80-HighGUI-%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2018/05/09/opencv-一-HighGUI-模块/</id>
    <published>2018-05-09T13:36:05.000Z</published>
    <updated>2018-05-09T13:36:43.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HighGUI-模块"><a href="#HighGUI-模块" class="headerlink" title="HighGUI 模块"></a>HighGUI 模块</h2><p>PS：HighGUI 图形用户界面模块，包括图像和视频的读入显示、编码解码、图形交互界面接口(啥意思？后来想想可能是指滑动条这种可以产生交互的函数)</p><p><strong>滑动条的使用</strong>                                                                                 1.创建窗口       namedWindow()                                                                                                                     2.创建滑动条   createTrackbar()                                                                        3.回掉函数       on_trackbar()  函数原型必须是 void XX(int,void*)  第一个为轨迹位置，第二个为用户数据        滑动条位置改变，调用回掉函数</p><p>PS：<strong>void* 表明该指针与一地址值有关，但不知道存储在此地址上的对象的类型</strong>                                              void*只支持有限的操作，<strong>向函数传递void<em>指针或者返回void\</em>指针，给另一个void*指针赋值</strong>                                                                 int i = 1   void *pi = &amp;i</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HighGUI-模块&quot;&gt;&lt;a href=&quot;#HighGUI-模块&quot; class=&quot;headerlink&quot; title=&quot;HighGUI 模块&quot;&gt;&lt;/a&gt;HighGUI 模块&lt;/h2&gt;&lt;p&gt;PS：HighGUI 图形用户界面模块，包括图像和视频的读入显示、编码解码、
      
    
    </summary>
    
    
      <category term="opencv" scheme="http://yoursite.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>python入门编程</title>
    <link href="http://yoursite.com/2018/05/09/python%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/05/09/python入门编程/</id>
    <published>2018-05-09T09:19:06.000Z</published>
    <updated>2018-05-22T12:09:33.713Z</updated>
    
    <content type="html"><![CDATA[<p>PS：结合下面这篇博客的第一个代码，写写关于python的入门编程理解</p><p><a href="https://blog.csdn.net/han_xiaoyang/article/details/49123419" target="_blank" rel="noopener">https://blog.csdn.net/han_xiaoyang/article/details/49123419</a></p><a id="more"></a><h2 id="用-python-shell-运行data1-py"><a href="#用-python-shell-运行data1-py" class="headerlink" title="用 python shell 运行data1.py"></a>用 python shell 运行data1.py</h2><ol><li>打开python shell —new file 新建一个.py 文件并保存                                         </li><li>run — run model 然后python shell 会出现相应的结果                                               </li></ol><p>PS：嫌弃我讲的太敷衍可以参考这片百度知道哪<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https://zhidao.baidu.com/question/1958691628398602620.html</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">#data1.py</span><br><span class="line">#用到包里的函数</span><br><span class="line">from numpy import loadtxt, where  </span><br><span class="line">from pylab import scatter, show, legend, xlabel, ylabel  </span><br><span class="line"></span><br><span class="line">#load the dataset  </span><br><span class="line">data = loadtxt(&apos;D:/机器学习/逻辑回归/data1.txt&apos;, delimiter=&apos;,&apos;)  </span><br><span class="line">  </span><br><span class="line">X = data[:, 0:2]  </span><br><span class="line">y = data[:, 2]  </span><br><span class="line">  </span><br><span class="line">pos = where(y == 1)  </span><br><span class="line">neg = where(y == 0)  </span><br><span class="line">scatter(X[pos, 0], X[pos, 1], marker=&apos;o&apos;, c=&apos;b&apos;)  </span><br><span class="line">scatter(X[neg, 0], X[neg, 1], marker=&apos;x&apos;, c=&apos;r&apos;)  </span><br><span class="line">xlabel(&apos;Feature1/Exam 1 score&apos;)  </span><br><span class="line">ylabel(&apos;Feature2/Exam 2 score&apos;)  </span><br><span class="line">legend([&apos;Fail&apos;, &apos;Pass&apos;])  </span><br><span class="line">show()  </span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"> 代码运行的结果![data1结果](http://p8ge6t5tt.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%2817%29.png)</span><br><span class="line"></span><br><span class="line">## 使用pip工具安装包</span><br><span class="line"></span><br><span class="line">pip是python的一个非常好用的包管理工具，可以很方便地安装和管理各种三方库    </span><br><span class="line"></span><br><span class="line">具体可以参考下面这篇博客~~</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/zhangxinyu11021130/article/details/50987631</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意事项：                                                                                                                    </span><br><span class="line"></span><br><span class="line">1. 要设置系统变量</span><br><span class="line">2. 要下载相应版本的包 我的是python3.5.264位</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">下面是更新包的简单方法    </span><br><span class="line"></span><br><span class="line">1. 进入cmd cd D:/program/python/pythoninstall/Scripts</span><br><span class="line">2. pip install pandas     </span><br><span class="line">3. 进入python ，import  pandas 查看是否导入成功</span><br><span class="line"></span><br><span class="line">PyPi地址在国外，因为有墙的原因所以有些地区使用pip安装第三方库的时候会出现下载慢甚至严重的无法访问导致安装失败。通过更换pip镜像源为国内地址可以解决上述问题       </span><br><span class="line"></span><br><span class="line">开源软件镜像站 https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/                                                                                </span><br><span class="line"></span><br><span class="line">PS：真的是遇到一件超级诡异的事情，用pandas里面的describe没有反应，害我以为我pandas没有装好！但是在shell里面一条条指令输进去有结果，但是在.py文件里一口气run竟然不行！！！哇哦，要不是师兄，我还一个下午都在纠结我的包是不是没有装好</span><br></pre></td></tr></table></figure></p><p>~~ 好了，这条诡异的PS总算解决了，因为我没有用print函数，当然不会输出结果 ~~ 哎 ~ 傻了吧唧的 ~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：结合下面这篇博客的第一个代码，写写关于python的入门编程理解&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/han_xiaoyang/article/details/49123419&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/han_xiaoyang/article/details/49123419&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>CommandLineParse类</title>
    <link href="http://yoursite.com/2018/05/08/CommandLineParse%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/05/08/CommandLineParse类/</id>
    <published>2018-05-08T08:53:09.000Z</published>
    <updated>2018-05-08T08:57:14.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CommandLineParse类-命令行解析类"><a href="#CommandLineParse类-命令行解析类" class="headerlink" title="CommandLineParse类(命令行解析类)"></a>CommandLineParse类(命令行解析类)</h2><p>PS：看例程的时候特别不理解这个类是啥意思，可以看下面这个</p><p><a href="https://blog.csdn.net/jkhere/article/details/8674019" target="_blank" rel="noopener">https://blog.csdn.net/jkhere/article/details/8674019</a></p><p>但是我个人觉得用我自己写的程序更好理解 keys，这种简单明了的比较适合我们小白~~</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgcodecs.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgproc.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* keys =</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"&#123;input |C:/Users/king/Pictures/Saved Pictures/1.jpg| string |input image&#125;"</span></span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">//分别表示简称，文件来源，文件值和帮助语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Mat src, dst;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* source_window = <span class="string">"Source image"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* equalized_window = <span class="string">"Equalized Image"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load image</span></span><br><span class="line"><span class="function">CommandLineParser <span class="title">parser</span><span class="params">(argc, argv, keys)</span></span>;</span><br><span class="line">src = imread(parser.get&lt;String&gt;(<span class="string">"input"</span>), IMREAD_COLOR);</span><br><span class="line"><span class="keyword">if</span> (src.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not open or find the image!\n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cvtColor(src, src, COLOR_BGR2GRAY);</span><br><span class="line">equalizeHist(src, dst);</span><br><span class="line"></span><br><span class="line">namedWindow(source_window, WINDOW_AUTOSIZE);</span><br><span class="line">namedWindow(equalized_window, WINDOW_AUTOSIZE);</span><br><span class="line"></span><br><span class="line">imshow(source_window, src);</span><br><span class="line">imshow(equalized_window, dst);</span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.这个类的作用</p><p>以前没这个类时，如果要运行带参数的.exe，必须在命令行中输入文件路径以及各种参数，一不小心就输错了，很不方便。<br>现在有了这个类，只需要<strong>改keys</strong>里面的内容就可以了，并且运行时可以<strong>直接在vs下用F5，不需要cmd命令行带参运行</strong>。</p><p>2.keys</p><p>keys中间的内容分成4断，用”|”分隔开，分别表示简称，文件来源，文件值和帮助语句                PS：文件的值我不是很理解，如果类型是bool，那就有值0或，如果是类型是图像，它的值可以<strong>省略</strong>，我这边文件的值用了string，也运行成功了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CommandLineParse类-命令行解析类&quot;&gt;&lt;a href=&quot;#CommandLineParse类-命令行解析类&quot; class=&quot;headerlink&quot; title=&quot;CommandLineParse类(命令行解析类)&quot;&gt;&lt;/a&gt;CommandLineParse类(命令行解析类)&lt;/h2&gt;&lt;p&gt;PS：看例程的时候特别不理解这个类是啥意思，可以看下面这个&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/jkhere/article/details/8674019&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/jkhere/article/details/8674019&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是我个人觉得用我自己写的程序更好理解 keys，这种简单明了的比较适合我们小白~~&lt;/p&gt;
    
    </summary>
    
    
      <category term="opencv" scheme="http://yoursite.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>argc和argv</title>
    <link href="http://yoursite.com/2018/05/08/argc%E5%92%8Cargv/"/>
    <id>http://yoursite.com/2018/05/08/argc和argv/</id>
    <published>2018-05-08T07:00:22.000Z</published>
    <updated>2018-05-08T11:57:39.773Z</updated>
    
    <content type="html"><![CDATA[<p>int main(int argc, char **argv)和int main(int argc, char *arg[])的区别</p><h3 id="1-字符和指针"><a href="#1-字符和指针" class="headerlink" title="1. 字符和指针"></a>1. 字符和指针</h3><p>1.char *a: 一级指针，a数据地址，*a指针指向的数据<br>printf(“%c”,*a)输出一个字符，printf(“%s”,a)输出字符串<br>举个栗子：<br>char *p1,*p2<br>char str[]=”study” 字符数组，内容可变<br>p1=str<br>p2=”hard” 字符串，字符串以字符数组存储，以’\0’结束,内容不可变</p><p>2.char **a: 二级指针，指向char *a[]<br>printf(“%c”,**a)输出一个字符，printf(“%s”,*a)输出字符串<br>举个栗子：<br>char **w<br>char *week={“Moday”,”Tuesday”,”Thursday”}<br>w=week</p><p>3.char *a[]: a是一个数组，数组的元素是字符串地址，地址包含的值是字符型数据<br>printf(“%c”,*a[i])输出一个字符，printf(“%s”,a[i]))输出字符串<br>举个栗子：<br>char *a[]={“study”,”hard”}</p><a id="more"></a><h3 id="2-argc-和-argv"><a href="#2-argc-和-argv" class="headerlink" title="2. argc 和 argv"></a>2. argc 和 argv</h3><p>argc是命令行总的参数个数  <strong>argc 至少是1</strong>                                                                                argv[]是argc个参数  <strong>其中第0个参数是程序的全名</strong> 后面的参数是命令行用户输入的参数</p><h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3. 区别"></a>3. 区别</h3><p>(int argc,char *argv[])  argv指向字符串的指针数组<br>(int argc,char **argv)   argv指向char *，即argv存的是指向字符串的指针数组的地址</p><h3 id="4-VS中如何使用argv"><a href="#4-VS中如何使用argv" class="headerlink" title="4. VS中如何使用argv"></a>4. VS中如何使用argv</h3><p>命令参数里输入参数，试一下下面这个简单例程就理解了</p><p><a href="https://blog.csdn.net/ly763124994/article/details/13627971" target="_blank" rel="noopener">https://blog.csdn.net/ly763124994/article/details/13627971</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;int main(int argc, char **argv)和int main(int argc, char *arg[])的区别&lt;/p&gt;
&lt;h3 id=&quot;1-字符和指针&quot;&gt;&lt;a href=&quot;#1-字符和指针&quot; class=&quot;headerlink&quot; title=&quot;1. 字符和指针&quot;&gt;&lt;/a&gt;1. 字符和指针&lt;/h3&gt;&lt;p&gt;1.char *a: 一级指针，a数据地址，*a指针指向的数据&lt;br&gt;printf(“%c”,*a)输出一个字符，printf(“%s”,a)输出字符串&lt;br&gt;举个栗子：&lt;br&gt;char *p1,*p2&lt;br&gt;char str[]=”study” 字符数组，内容可变&lt;br&gt;p1=str&lt;br&gt;p2=”hard” 字符串，字符串以字符数组存储，以’\0’结束,内容不可变&lt;/p&gt;
&lt;p&gt;2.char **a: 二级指针，指向char *a[]&lt;br&gt;printf(“%c”,**a)输出一个字符，printf(“%s”,*a)输出字符串&lt;br&gt;举个栗子：&lt;br&gt;char **w&lt;br&gt;char *week={“Moday”,”Tuesday”,”Thursday”}&lt;br&gt;w=week&lt;/p&gt;
&lt;p&gt;3.char *a[]: a是一个数组，数组的元素是字符串地址，地址包含的值是字符型数据&lt;br&gt;printf(“%c”,*a[i])输出一个字符，printf(“%s”,a[i]))输出字符串&lt;br&gt;举个栗子：&lt;br&gt;char *a[]={“study”,”hard”}&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo主题的优化</title>
    <link href="http://yoursite.com/2018/05/08/Hexo%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/05/08/Hexo主题的优化/</id>
    <published>2018-05-08T06:53:54.000Z</published>
    <updated>2018-05-08T07:11:58.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主题优化"><a href="#主题优化" class="headerlink" title="主题优化"></a>主题优化</h1><p>不知道从哪几个方面来优化的可以参考以下案例~~</p><p><a href="http://blog.magicwang.tech/post/Hexo-Yilia-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">http://blog.magicwang.tech/post/Hexo-Yilia-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</a></p><p><a href="http://www.yfshare.vip/categories/Hexo/" target="_blank" rel="noopener">http://www.yfshare.vip/categories/Hexo/</a></p><a id="more"></a><h2 id="1-添加文章阅读统计-网页设计"><a href="#1-添加文章阅读统计-网页设计" class="headerlink" title="1. 添加文章阅读统计-网页设计"></a>1. 添加文章阅读统计-网页设计</h2><p>添加文章阅读统计，文章阅读统计使用不蒜子：一行脚本+一行标签</p><p>PS：对网页设计真的是一窍不通，完全看别人写的东西，凭感觉改，很简单几行就搞定</p><p>文章阅读统计使用不蒜子：一行脚本+一行标签</p><p><a href="http://www.janszeng.top/2017/08/30/hexo_yilia_count/#0x02-" target="_blank" rel="noopener">http://www.janszeng.top/2017/08/30/hexo_yilia_count/#0x02-</a></p><p>PS：以下是对网页设计最基础的理解</p><p><strong>1.HTML：负责网页的结构，又称语义层</strong></p><p>(1) HTML 是用来描述网页的一种语言 ，<strong>超文本标记语言</strong>(Hyper Text Markup Language)</p><ul><li>HTML 不是一种编程语言，而是一种<strong>标记语言</strong>(markup language)</li></ul><ul><li>HTML 使用标记标签来描述网页</li></ul><p>(2) HTML 标记标签(HTML tag)</p><ul><li><p>HTML 标签是由<em>尖括号</em> 包围的关键词，标签通常是<em>成对</em> 出现的</p><p>举个栗子： <b> 和 </b>标签对中的第一个标签是<em>开始标签</em>，第二个标签是<em>结束标签</em>                                    开始和结束标签也被称为<em>开放标签</em>和<em>闭合标签</em></p></li></ul><p>(3) HTML 文档 / 网页</p><ul><li>HTML 文档也被称为<strong>网页</strong></li></ul><ul><li>包含 HTML 标签和纯文本</li></ul><p>Web 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释页面的内容。</p><p><strong>2.CSS ：负责网页的样式，又称视觉层</strong></p><p>级联样式表、风格样式表，它是用来进行网页风格设计的。CSS不仅可以很好的控制网页外观效果，而且还能扩充精确指定网页元素位置。</p><p><strong>3.JavaScript ：负责网页的逻辑和交互，又称逻辑层或交互层</strong></p><ul><li>JavaScript是一种可以被浏览器解析的解释型脚本语言，为了让页面动起来。</li></ul><ul><li>脚本语言是为了缩短传统的“编写、编译、链接、运行”过程而创建的，目的就是希望能让程序员快速完成程序的编写工作，不需要编译过程，就直接可以执行。</li></ul><p>HTML是肉身、CSS就是皮相、Javascript 就是灵魂</p><h2 id="2-RSS"><a href="#2-RSS" class="headerlink" title="2.RSS"></a>2.RSS</h2><p>PS：研究了很久到底啥是RSS，我选择放弃，当它是一种订阅功能吧~(超沮丧的)</p><p><a href="http://hanhailong.com/2015/10/08/Hexo%E2%80%94%E6%AD%A3%E7%A1%AE%E6%B7%BB%E5%8A%A0RSS%E8%AE%A2%E9%98%85/" target="_blank" rel="noopener">http://hanhailong.com/2015/10/08/Hexo%E2%80%94%E6%AD%A3%E7%A1%AE%E6%B7%BB%E5%8A%A0RSS%E8%AE%A2%E9%98%85/</a></p><h2 id="3-添加版权"><a href="#3-添加版权" class="headerlink" title="3.添加版权"></a>3.添加版权</h2><p>找到的，最简单的一种方法，适合我这种小白</p><p><a href="http://wellliu.com/2016/11/18/%E5%9C%A8hexo%E5%8D%9A%E5%AE%A2foot%E4%BD%8D%E7%BD%AE%E5%A4%84%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E8%AF%B4%E6%98%8E/" target="_blank" rel="noopener">http://wellliu.com/2016/11/18/%E5%9C%A8hexo%E5%8D%9A%E5%AE%A2foot%E4%BD%8D%E7%BD%AE%E5%A4%84%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E8%AF%B4%E6%98%8E/</a></p><h2 id="4-添加评论"><a href="#4-添加评论" class="headerlink" title="4.添加评论"></a>4.添加评论</h2><p><strong>第三方社会化评论系统</strong>  ：部署插件或添加两行代码即可使用。第三方网站为自己的网站搭建起一个强大的社会化评论系统，可将评论一键同步到微博与社区（目前支持10个社交媒体），同时将评论的回复与跟帖同步至使用的网站上。但是……</p><p>多说、优言要关闭了，哎……</p><p>畅言还要有备案号，又pass，哎……</p><p>国外的 Disqus 要翻墙评论，哎……</p><p>我选择不开评论<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**************************</span><br><span class="line"></span><br><span class="line">5.相册</span><br><span class="line"></span><br><span class="line">看了两天还做不出来</span><br></pre></td></tr></table></figure></p><p>图床一般是指储存图片的服务器，同时允许你把图片对外连接的网上空间。有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。</p><p><a href="https://www.jianshu.com/p/a9f309aaa0e0" target="_blank" rel="noopener">https://www.jianshu.com/p/a9f309aaa0e0</a></p><p>相册功能 我一定要做出来！</p><p>GitHub 或者 七牛</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;主题优化&quot;&gt;&lt;a href=&quot;#主题优化&quot; class=&quot;headerlink&quot; title=&quot;主题优化&quot;&gt;&lt;/a&gt;主题优化&lt;/h1&gt;&lt;p&gt;不知道从哪几个方面来优化的可以参考以下案例~~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.magicwang.tech/post/Hexo-Yilia-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.magicwang.tech/post/Hexo-Yilia-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.yfshare.vip/categories/Hexo/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.yfshare.vip/categories/Hexo/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>ImageWatch</title>
    <link href="http://yoursite.com/2018/05/07/ImageWatch/"/>
    <id>http://yoursite.com/2018/05/07/ImageWatch/</id>
    <published>2018-05-07T13:23:47.000Z</published>
    <updated>2018-05-07T13:29:06.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ImageWatch"><a href="#ImageWatch" class="headerlink" title="ImageWatch"></a>ImageWatch</h2><p>PS：师兄告诉我的一个调试小工具，哈哈哈~很满意</p><p>Image Watch是一个VS插件，能够让你在调试一个OpenCV程序的时候，看到内存中的图像，<strong>不能在Release版本下调试</strong>，是显示不出图像的。</p><p>mage Watch左上角有两个单选按钮Locals和Watch，分别对应两种模式 ：<br>Locals模式显示当前栈中所有的与变量，Watch模式显示用户手动添加的变量</p><p><a href="https://blog.csdn.net/chaipp0607/article/details/71155601" target="_blank" rel="noopener">https://blog.csdn.net/chaipp0607/article/details/71155601</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ImageWatch&quot;&gt;&lt;a href=&quot;#ImageWatch&quot; class=&quot;headerlink&quot; title=&quot;ImageWatch&quot;&gt;&lt;/a&gt;ImageWatch&lt;/h2&gt;&lt;p&gt;PS：师兄告诉我的一个调试小工具，哈哈哈~很满意&lt;/p&gt;
&lt;p&gt;Image 
      
    
    </summary>
    
    
      <category term="opencv" scheme="http://yoursite.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>天池比赛入门</title>
    <link href="http://yoursite.com/2018/05/07/%E5%A4%A9%E6%B1%A0%E6%AF%94%E8%B5%9B%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/05/07/天池比赛入门/</id>
    <published>2018-05-07T01:59:32.000Z</published>
    <updated>2018-05-07T02:03:44.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="天池、Kaggle、DataCastle"><a href="#天池、Kaggle、DataCastle" class="headerlink" title="天池、Kaggle、DataCastle"></a>天池、Kaggle、DataCastle</h2><p>天池、Kaggle、DataCastle这几个大数据+机器学习的大赛平台初步了解。</p><p><a href="https://www.zhihu.com/question/41450532/answer/91372849" target="_blank" rel="noopener">https://www.zhihu.com/question/41450532/answer/91372849</a></p><p>加油！！！我一定可以做出来的！！！</p><hr><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>大神总结的机器学习是什么，简单而又醍醐灌顶：机器学习最大的特点，或者说它的发展方向，就是<strong>不要有人工干预</strong>，自己学习。通过迭代，降低自己的loss（error），提升自己的accuracy 。你只要告诉它学习的方向，剩下的就是开着它跑，给它时间，让它自己学完就好了。(满脸迷妹崇拜大神~)</p><p>PS：实际上，机器大量时间花在数据处理上，小部分时间花在模型，模型都是现有的，具体做的就是，如何选择模型，如何调节参数。</p><a id="more"></a><h2 id="机器学习应用流程"><a href="#机器学习应用流程" class="headerlink" title="机器学习应用流程"></a>机器学习应用流程</h2><p>机器学习常用算法 </p><p>常用工具</p><p>建模与问题解决流程</p><p>(1) 数据处理</p><p>(2) 特征工程</p><p>(3) 模型选择</p><p>(4) 寻找最佳超参数 ：交叉验证</p><p>(5) 模型分析与模型融合</p><h2 id="机器学习算法"><a href="#机器学习算法" class="headerlink" title="机器学习算法"></a>机器学习算法</h2><p>1.算法分类</p><p><img src="http://7xo0y8.com1.z0.glb.clouddn.com/ml_conceptml_algorithms.png" alt="算法分类">2.算法选择路径图scikit-learn algorithm cheat-sheet</p><p><img src="https://img-blog.csdn.net/20160930051801241?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="算法选择路径图"></p><p>classification 分类</p><p>regression连续值预测 回归</p><p>clustering 聚类(不同于分类，是无监督的，也就是寻找关联规则)</p><p>dimensionality reduction  降维 特征非常多</p><h2 id="机器学习开源项目"><a href="#机器学习开源项目" class="headerlink" title="机器学习开源项目"></a>机器学习开源项目</h2><p>就把它看做是一项工具，现成的库，里面的函数实现特定功能，直接拿来用即可。</p><p>下面是网上一位大神做的总结，内容很全，值得参考。</p><p><a href="https://yq.aliyun.com/articles/30794" target="_blank" rel="noopener">https://yq.aliyun.com/articles/30794</a></p><p><a href="https://yq.aliyun.com/articles/30796?spm=a2c4e.11153940.blogcont30794.29.40072508tHSzWa" target="_blank" rel="noopener">https://yq.aliyun.com/articles/30796?spm=a2c4e.11153940.blogcont30794.29.40072508tHSzWa</a></p><p>PS：一些经常看到的项目，反正我没用过。</p><p>1.TensorFlow                                                                            TensorFlow 是谷歌发布的第二代机器学习系统，是一个利用数据流图（Data Flow Graphs）进行数值计算的开源软件库。                                                                                                                                                                 主要用在<strong>深度神经网络</strong>方面。</p><p>2.Scikit-Learn                                                                                Scikit-Learn 是用于机器学习的Python 模块，建立在NumPy、SciPy 和 matplotlib基础上，<strong>非常全</strong>的库。            基本功能主要被分为六个部分：<strong>分类、回归、聚类、数据降维、模型选择、数据预处理</strong>。</p><p>3.Caffe                                                                                            Caffe 是做深度学习的框架。                                                                                                                                  目前Caffe应用实践主要有数据整理、设计网络结构、训练结果、基于现有训练模型，使用Caffe直接识别。</p><p>4.Keras                                                                                                Keras 是极其精简并高度模块化的神经网络库，在TensorFlow 或 Theano 上都能够运行，是一个高度模块化的神经网络库，支持GPU和CPU运算。同时支持卷积网络和递归网络，以及两者之间的组合。</p><p>5.MXNet                                                                                                                        MXNet 是一个兼具效率和灵活性的<strong>深度学习框架</strong>。它允许使用者将符号编程和命令式编程相结合，以追求效率和生产力的最大化。该库轻量且便携带，并且可扩展到多个GPU和多台主机上。</p><p>6.XGBoost                                                                                                            XGBoot 是设计为高效、灵活、可移植的优化分布式梯度 Boosting库。它实现了 Gradient Boosting 框架下的机器学习算法。XGBoost通过提供并行树Boosting（也被称为GBDT、GBM），以一种快速且准确的方式解决了许多数据科学问题。</p><p><strong>Boosting 提升或叫增强</strong>，是一个机器学习技术，可以用于<strong>回归</strong>和<strong>分类</strong>问题，它每一步产生一个<strong>弱预测模型</strong>(如决策树)，并<strong>加权累加</strong>到总模型中。提升的理论意义，如果一个问题存在弱分类器，则 可以通过提升的办法得到强分类器。</p><p>如果每一步的弱预测模型生成都是依据损失函数的<strong>梯度方向</strong>，则称之为梯度提升(Gradient boosting)。        </p><p>7.gensim                                                                                     用于NLP<strong>自然语言处理</strong>Natural Language Processing</p><p>8.Numpy                                                                                                                            用于科学计算 </p><p>9.Matplotlib                                                                                                              Matplotlib 是一个非常强大的 Python 画图工具，可视化数据</p><p>10.pandas                                                                                     数据清洗 数据预处理</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;天池、Kaggle、DataCastle&quot;&gt;&lt;a href=&quot;#天池、Kaggle、DataCastle&quot; class=&quot;headerlink&quot; title=&quot;天池、Kaggle、DataCastle&quot;&gt;&lt;/a&gt;天池、Kaggle、DataCastle&lt;/h2&gt;&lt;p&gt;天池、Kaggle、DataCastle这几个大数据+机器学习的大赛平台初步了解。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/41450532/answer/91372849&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/41450532/answer/91372849&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;加油！！！我一定可以做出来的！！！&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;机器学习&quot;&gt;&lt;a href=&quot;#机器学习&quot; class=&quot;headerlink&quot; title=&quot;机器学习&quot;&gt;&lt;/a&gt;机器学习&lt;/h2&gt;&lt;p&gt;大神总结的机器学习是什么，简单而又醍醐灌顶：机器学习最大的特点，或者说它的发展方向，就是&lt;strong&gt;不要有人工干预&lt;/strong&gt;，自己学习。通过迭代，降低自己的loss（error），提升自己的accuracy 。你只要告诉它学习的方向，剩下的就是开着它跑，给它时间，让它自己学完就好了。(满脸迷妹崇拜大神~)&lt;/p&gt;
&lt;p&gt;PS：实际上，机器大量时间花在数据处理上，小部分时间花在模型，模型都是现有的，具体做的就是，如何选择模型，如何调节参数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>编译器和解释器</title>
    <link href="http://yoursite.com/2018/05/04/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    <id>http://yoursite.com/2018/05/04/编译器和解释器/</id>
    <published>2018-05-04T12:42:04.000Z</published>
    <updated>2018-05-04T12:46:12.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编译器、解释器"><a href="#编译器、解释器" class="headerlink" title="编译器、解释器"></a>编译器、解释器</h2><p>1.编译器：将源程序编译成机器语言，保存成二进制文件，运行速度快</p><p>2.解释器：执程序时一条条解释成机器语言，运行速度慢</p><h2 id="编译型语言、解释型语言"><a href="#编译型语言、解释型语言" class="headerlink" title="编译型语言、解释型语言"></a>编译型语言、解释型语言</h2><p>1.编译型语言：不能独立运行，使用了库函数，需要链接，最后输出可执行代码 (C、C++)</p><p>缺点：编译成特定平台的机器码，无法将可执行文件移植到其它平台，可以移植也需要采用该平台的编译器重新编译</p><a id="more"></a><p>2.解释型语言：生成中间代码，同于机器码，再解释成可执行的机器码 (java、python)</p><p>优点：跨平台容易，只需要特定平台的解释器</p><p>缺点：牺牲了程序的执行效率，才方便移植</p><p>举个栗子：Java能够一次编译，导出运行Java编译成Java字节码，Java虚拟机 (JVM) 将字节码解释成具体平台上的机器指令来执行</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编译器、解释器&quot;&gt;&lt;a href=&quot;#编译器、解释器&quot; class=&quot;headerlink&quot; title=&quot;编译器、解释器&quot;&gt;&lt;/a&gt;编译器、解释器&lt;/h2&gt;&lt;p&gt;1.编译器：将源程序编译成机器语言，保存成二进制文件，运行速度快&lt;/p&gt;
&lt;p&gt;2.解释器：执程序时一条条解释成机器语言，运行速度慢&lt;/p&gt;
&lt;h2 id=&quot;编译型语言、解释型语言&quot;&gt;&lt;a href=&quot;#编译型语言、解释型语言&quot; class=&quot;headerlink&quot; title=&quot;编译型语言、解释型语言&quot;&gt;&lt;/a&gt;编译型语言、解释型语言&lt;/h2&gt;&lt;p&gt;1.编译型语言：不能独立运行，使用了库函数，需要链接，最后输出可执行代码 (C、C++)&lt;/p&gt;
&lt;p&gt;缺点：编译成特定平台的机器码，无法将可执行文件移植到其它平台，可以移植也需要采用该平台的编译器重新编译&lt;/p&gt;
    
    </summary>
    
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>make和CMake</title>
    <link href="http://yoursite.com/2018/05/04/make%E5%92%8CCMake/"/>
    <id>http://yoursite.com/2018/05/04/make和CMake/</id>
    <published>2018-05-04T12:24:18.000Z</published>
    <updated>2018-05-04T12:45:49.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="makefile-和-make"><a href="#makefile-和-make" class="headerlink" title="makefile 和 make"></a>makefile 和 make</h2><p>1.makefile 文件</p><p>一个工程中有很多源文件，makefile定义了整个工程的编译规则，哪些文件先编译，哪些文件后编译，哪些文件重新编译。malefile是<strong>自动化编译</strong>，一旦写好，只需一个make，整个工程自动编译。</p><p>windows平台下，VS开发环境自动生成makefile文件</p><p>Linux平台下，Qt Creator自动生成了类似makeile的 .pro文件</p><a id="more"></a><p>2.编译器和 make</p><p>编译器是编译一个文件</p><p>make是编译多个源文件的工具，解释makefile中的指令，看作是编译器的调度器</p><h2 id="CmakeList-txt-和-CMake"><a href="#CmakeList-txt-和-CMake" class="headerlink" title="CmakeList.txt 和 CMake"></a>CmakeList.txt 和 CMake</h2><p>CMake是种跨平台编译工具，Cmake 将 CMakeList.txt 转化为make 需要的 makefile 文件，用make编译</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;makefile-和-make&quot;&gt;&lt;a href=&quot;#makefile-和-make&quot; class=&quot;headerlink&quot; title=&quot;makefile 和 make&quot;&gt;&lt;/a&gt;makefile 和 make&lt;/h2&gt;&lt;p&gt;1.makefile 文件&lt;/p&gt;
&lt;p&gt;一个工程中有很多源文件，makefile定义了整个工程的编译规则，哪些文件先编译，哪些文件后编译，哪些文件重新编译。malefile是&lt;strong&gt;自动化编译&lt;/strong&gt;，一旦写好，只需一个make，整个工程自动编译。&lt;/p&gt;
&lt;p&gt;windows平台下，VS开发环境自动生成makefile文件&lt;/p&gt;
&lt;p&gt;Linux平台下，Qt Creator自动生成了类似makeile的 .pro文件&lt;/p&gt;
    
    </summary>
    
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub+Hexo 搭建自己的博客</title>
    <link href="http://yoursite.com/2018/05/04/GitHub-Hexo-%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/05/04/GitHub-Hexo-搭建自己的博客/</id>
    <published>2018-05-04T09:24:31.000Z</published>
    <updated>2018-05-08T06:54:24.922Z</updated>
    
    <content type="html"><![CDATA[<font color="gray" size="2">PS：参考网上各种大神的博客，作为一个小白，我真的东拼西凑，半懂不懂搭出来了自己的博客页面，所以看到这篇博文的你，一定要有信心~</font><h2 id="搭建过程和遇到的问题"><a href="#搭建过程和遇到的问题" class="headerlink" title="搭建过程和遇到的问题"></a>搭建过程和遇到的问题</h2><p>自己搭的时候参考了好几篇，大神太多啦，推荐看这位的就够了</p><p><a href="https://www.cnblogs.com/jackyroc/p/7681938.html" target="_blank" rel="noopener">https://www.cnblogs.com/jackyroc/p/7681938.html</a></p><p>下面罗列一下几个遇到的问题：</p><p>1.Node.js安装及环境配置之Windows，这位写得很详细啦~</p><p><a href="https://www.cnblogs.com/zhouyu2017/p/6485265.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhouyu2017/p/6485265.html</a></p><p>2.配置SSH Key到GitHub，在这个地方卡了好久，好多博文这里一笔带过写了，推荐下面这位啦~</p><p><a href="https://blog.csdn.net/gulingfengze/article/details/69665223" target="_blank" rel="noopener">https://blog.csdn.net/gulingfengze/article/details/69665223</a></p><a id="more"></a><p>3._config.yml配置，我用记事本打开中文出现乱码，用代码编辑器就好了，我下了个sublime</p><p>4.部署HEXO时出现ERROR Deployer not found : github</p><p><a href="https://blog.csdn.net/crow1108/article/details/50445671" target="_blank" rel="noopener">https://blog.csdn.net/crow1108/article/details/50445671</a></p><p>5.新手特别需要的Markdown语法 与 Hexo常用指令，其实网上很多，下面这个罗列的是很常用的</p><p><a href="http://www.mamicode.com/info-detail-1275803.html" target="_blank" rel="noopener">http://www.mamicode.com/info-detail-1275803.html</a></p><h2 id="发表新文章的总结"><a href="#发表新文章的总结" class="headerlink" title="发表新文章的总结"></a>发表新文章的总结</h2><p>GitHub+Hexo 搭建博客</p><p>1.进入Hexo放在的文件 右键-Git Bash</p><p>2.发布文章的步骤<br>  1).hexo new 创建文章<br>  2).Markdown语法编辑文章<br>  3).部署<br>  hexo clean #清除缓存 网页正常情况下可以忽略此条命令<br>  hexo generate #生成<br>  hexo server #启动服务预览，非必要，可本地浏览网页<br>  hexo deploy #部署发布</p><p>~~最后，强推一把我的博客 <a href="https://sophia0130.github.io/" target="_blank" rel="noopener">https://sophia0130.github.io/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;PS：参考网上各种大神的博客，作为一个小白，我真的东拼西凑，半懂不懂搭出来了自己的博客页面，所以看到这篇博文的你，一定要有信心~&lt;/font&gt;

&lt;h2 id=&quot;搭建过程和遇到的问题&quot;&gt;&lt;a href=&quot;#搭建过程和遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;搭建过程和遇到的问题&quot;&gt;&lt;/a&gt;搭建过程和遇到的问题&lt;/h2&gt;&lt;p&gt;自己搭的时候参考了好几篇，大神太多啦，推荐看这位的就够了&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jackyroc/p/7681938.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/jackyroc/p/7681938.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面罗列一下几个遇到的问题：&lt;/p&gt;
&lt;p&gt;1.Node.js安装及环境配置之Windows，这位写得很详细啦~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhouyu2017/p/6485265.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/zhouyu2017/p/6485265.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.配置SSH Key到GitHub，在这个地方卡了好久，好多博文这里一笔带过写了，推荐下面这位啦~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/gulingfengze/article/details/69665223&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/gulingfengze/article/details/69665223&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
