<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>绿小蕤</title>
  <icon>https://www.gravatar.com/avatar/e4d7a8bd1cb84fb3b4123916b4ea2f6b</icon>
  <subtitle>好逸恶劳,贪生怕死</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-09T09:30:22.903Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>绿小蕤</name>
    <email>528036346@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux（三）—— 环境变量</title>
    <link href="http://yoursite.com/2018/09/09/Linux%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2018/09/09/Linux（三）——-环境变量/</id>
    <published>2018-09-09T09:29:37.000Z</published>
    <updated>2018-09-09T09:30:22.903Z</updated>
    
    <content type="html"><![CDATA[<p>Linux是一个<strong>多用户多任务</strong>的操作系统，每个用户登录系统后，都会有一个专用的运行环境。</p><p><a href="https://blog.csdn.net/u010533843/article/details/54986646" target="_blank" rel="noopener">https://blog.csdn.net/u010533843/article/details/54986646</a></p><a id="more"></a><p><br></p><h3 id="一、环境变量按照生命周期来分"><a href="#一、环境变量按照生命周期来分" class="headerlink" title="一、环境变量按照生命周期来分"></a>一、环境变量按照生命周期来分</h3><ol><li>永久的：需要用户修改相关的<strong>配置文件</strong>，变量永久生效。</li><li>临时的：用户利用export命令，在当前终端下声明环境变量，<strong>关闭Shell终端失效</strong>。</li></ol><p><br></p><h3 id="二、环境变量按照作用域来分"><a href="#二、环境变量按照作用域来分" class="headerlink" title="二、环境变量按照作用域来分"></a>二、环境变量按照作用域来分</h3><p>1.<strong>系统环境变量</strong>：对该系统中所有用户都有效</p><ul><li><p>/etc/environment：</p><p>是系统在登录时读取的第一个文件，该文件设置的是整个系统的环境，只要启动系统就会读取该文件，用于为所有进程设置环境变量。</p><p>系统使用此文件时并不是执行此文件中的命令，而是根据KEY=VALUE模式的代码，对KEY赋值以VALUE，因此文件中如果要定义PATH环境变量，只需加入 PATH=$PATH:/xxx/bin</p></li><li><p>/etc/profile：</p><p>是系统登录时执行的第二个文件，为系统的每个用户设置环境信息。当用户登录时，该文件被执行一次，并从 /etc/profile.d 目录的配置文件中搜集shell 的设置。  </p></li></ul><ul><li><p>/etc/bashrc：</p><p>针对所有用户的bash初始化文件，当 bash shell 被打开时，该文件被读取，即每次新打开一个终端 shell，该文件就会被读取。</p></li></ul><p><br></p><p>2.<strong>用户环境变量</strong>：只对特定的用户有效</p><ul><li><p>~/.profile：</p><p>只对单个用户生效，当用户登录时该文件仅执行一次。用户可使用该文件添加自己使用的 shell 变量信息。</p></li><li><p>~/.bash_profile：</p><p> 是交互式、login 方式进入bash 运行</p><p>包含专用于用户的bash shell的bash信息，当用户登录时，该文件仅仅执行一次。默认情况下，他设置一些环境变量，执行用户的.bashrc文件。</p></li><li><p>~/.bashrc：</p><p>是交互式 non-login 方式进入bash 运行</p><p>包含专用于用户的bash shell的bash信息，当用户登录时以及每次打开新的shell时，该文件被读取。（每个用户都有一个.bashrc文件，在用户目录下）</p></li></ul><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>shell 是用户和Linux 内核之间的接口程序，你在提示符下输入的每个命令都由shell先解释然后传给Linux内核，<strong>shell 是一个命令行解释器</strong>。</p><p> bash 是 Linux 默认的 shell  ，相对应的，windows shell就是cmd。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux是一个&lt;strong&gt;多用户多任务&lt;/strong&gt;的操作系统，每个用户登录系统后，都会有一个专用的运行环境。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u010533843/article/details/54986646&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/u010533843/article/details/54986646&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux（二）—— 系统目录结构</title>
    <link href="http://yoursite.com/2018/09/09/Linux%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94-%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/09/09/Linux（二）——-系统目录结构/</id>
    <published>2018-09-09T09:27:53.000Z</published>
    <updated>2018-09-09T09:28:38.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-系统目录结构"><a href="#Linux-系统目录结构" class="headerlink" title="Linux 系统目录结构"></a>Linux 系统目录结构</h2><p>Linux系统目录是树状目录结构，”/ “ 根是所有目录的起点</p><p><strong>/home</strong>：用户的主目录，一般该目录名是以用户的账号命名的</p><p><strong>/root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。</p><p><strong>/usr</strong> ：是系统存放程序的目录</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/003vPl7Rty6E8kZRlAEdc690.jpg" alt="003vPl7Rty6E8kZRlAEdc&amp;690"></p><a id="more"></a><p>终端默认的启动位置是当前用户目录 home</p><ul><li><p>如果只是访问而不涉及修改的话，不需要root权限</p><p><code>cd /</code> 回到根目录cd</p></li></ul><p><code>cd /usr</code> 访问usr文件</p><ul><li>如果需要对根用户权限下的文件或文件夹做修改的话，需要把自身权限提为root权限，方法就是在命令前加上一个sudo，然后按照提示输入root密码即可</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux-系统目录结构&quot;&gt;&lt;a href=&quot;#Linux-系统目录结构&quot; class=&quot;headerlink&quot; title=&quot;Linux 系统目录结构&quot;&gt;&lt;/a&gt;Linux 系统目录结构&lt;/h2&gt;&lt;p&gt;Linux系统目录是树状目录结构，”/ “ 根是所有目录的起点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;/home&lt;/strong&gt;：用户的主目录，一般该目录名是以用户的账号命名的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;/root&lt;/strong&gt;：该目录为系统管理员，也称作超级权限者的用户主目录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;/usr&lt;/strong&gt; ：是系统存放程序的目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.runoob.com/wp-content/uploads/2014/06/003vPl7Rty6E8kZRlAEdc690.jpg&quot; alt=&quot;003vPl7Rty6E8kZRlAEdc&amp;amp;690&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux（一）—— 为什么要用Linux做开发</title>
    <link href="http://yoursite.com/2018/09/09/Linux%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Linux%E5%81%9A%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2018/09/09/Linux（一）——-为什么要用Linux做开发/</id>
    <published>2018-09-09T09:23:41.000Z</published>
    <updated>2018-09-09T09:25:08.525Z</updated>
    
    <content type="html"><![CDATA[<p>一直在纠结什么开发要用Linux系统， <strong>Linux占据了主要服务器市场</strong> ，windows则是桌面领域</p><p>下面来盘一下逻辑：因为Linux相比于windows好，为什么好，比如，Linux 没有把图形用户界面GUI写入内核kernel，就不会那么浪费资源和空间。所以大多数公司的服务器是Linux，所以要学习Linux下的开发</p><p><strong>1. 稳定性高</strong></p><p><strong>2. 成本低</strong></p><p><strong>3. 低维护成本</strong></p><p><strong>4. 病毒造成破坏低</strong></p><p>……</p><p><a href="https://blog.csdn.net/dolphin_LYG/article/details/59121002" target="_blank" rel="noopener">https://blog.csdn.net/dolphin_LYG/article/details/59121002</a></p><p>可能是我用的太少了，实在没有体会到，Linux 相较于 windows 的不同与优势。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直在纠结什么开发要用Linux系统， &lt;strong&gt;Linux占据了主要服务器市场&lt;/strong&gt; ，windows则是桌面领域&lt;/p&gt;
&lt;p&gt;下面来盘一下逻辑：因为Linux相比于windows好，为什么好，比如，Linux 没有把图形用户界面GUI写入内核kern
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Win10使用VMware虚拟机安装ubuntu</title>
    <link href="http://yoursite.com/2018/09/06/Win10%E4%BD%BF%E7%94%A8VMware%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85ubuntu/"/>
    <id>http://yoursite.com/2018/09/06/Win10使用VMware虚拟机安装ubuntu/</id>
    <published>2018-09-06T14:10:59.000Z</published>
    <updated>2018-09-09T09:27:15.737Z</updated>
    
    <content type="html"><![CDATA[<p>Win10使用VMware虚拟机安装ubuntu</p><p>PS：又被汪大蕾骂了一顿，还是装个虚拟机吧，毕竟做开发还是要靠Linux</p><a id="more"></a><p><br></p><h2 id="一、压缩卷新建磁盘分区"><a href="#一、压缩卷新建磁盘分区" class="headerlink" title="一、压缩卷新建磁盘分区"></a>一、压缩卷新建磁盘分区</h2><p>具体操作：<a href="https://jingyan.baidu.com/article/4f7d5712c415091a21192761.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/4f7d5712c415091a21192761.html</a></p><p>压缩卷：从一个盘里边把没有用到的空间分到未使用的磁盘空间里</p><p>扩展卷：从未使用空间里向现有的盘增加空间</p><p>磁盘格式：不同格式会在磁盘分区容量、单个文件容量、安全方面等存在区别</p><p>格式化：对磁盘或磁盘中的分区（partition）进行初始化的一种操作，这种操作通常会导致现有的磁盘或分区中所有的文件被清除</p><p>windows下磁盘格式主要有FAT16、FAT32、NTFS 等，最新格式为exFAT</p><p><br></p><h2 id="二、虚拟机和双系统"><a href="#二、虚拟机和双系统" class="headerlink" title="二、虚拟机和双系统"></a>二、虚拟机和双系统</h2><p>一直在纠结是装双系统还是虚拟机，但是看帖子说，双系统会不稳定，新手还是建议虚拟机 ~ </p><p>不过运行虚拟机，相当于运行两个系统，比较占用资源，不过拖拽文件会比较方便，双系统就需要切换</p><p><br></p><h3 id="1-虚拟机-（Virtual-Machine）"><a href="#1-虚拟机-（Virtual-Machine）" class="headerlink" title="1.  虚拟机 （Virtual Machine）"></a>1.  虚拟机 （Virtual Machine）</h3><p>通过软件模拟出来的具有完整的硬件系统功能的，运行在宿主机上的一个隔离环境中的计算机系统</p><p><strong>宿主机</strong> 是指直接运行在我们物理硬件的操作系统，而 <strong>虚拟机</strong> 则是运行在宿主机之上，所以当我们运行一个虚拟机的时候，实际上我们是在同时运行两个系统，这对我们的物理硬件要求比较高（主要是内存）</p><h3 id="2-双系统"><a href="#2-双系统" class="headerlink" title="2. 双系统"></a>2. 双系统</h3><p>双系统并不是同时运行两个系统，而是指两个系统都在存储空间中，我们可以选择其中一个进行启动</p><p><br></p><h2 id="三、Win10使用VMware虚拟机安装ubuntu"><a href="#三、Win10使用VMware虚拟机安装ubuntu" class="headerlink" title="三、Win10使用VMware虚拟机安装ubuntu"></a>三、Win10使用VMware虚拟机安装ubuntu</h2><p>具体操作：<a href="https://blog.csdn.net/dcrmg/article/details/74075254" target="_blank" rel="noopener">https://blog.csdn.net/dcrmg/article/details/74075254</a></p><p>​                   <a href="https://www.jianshu.com/p/3379892948da" target="_blank" rel="noopener">https://www.jianshu.com/p/3379892948da</a></p><p><br></p><p>ubuntu-16.04.5-desktop-amd64.iso ： <a href="http://mirrors.zju.edu.cn/ubuntu-releases/16.04/" target="_blank" rel="noopener">http://mirrors.zju.edu.cn/ubuntu-releases/16.04/</a></p><p>VMware Workstation 12.5.7 Pro for Windows</p><p><br></p><p><strong>注意：装虚拟机其中有一步是关于处理器配置</strong></p><p>VMWare中的CPU数量与核心数量意义</p><p>处理器数量 ：是指CPU核数（例如：单核/双核），并不是指CPU颗数</p><p>每个处理的核心数量：是指CPU中的线程，并不是指核心（Core）</p><p><br></p><p>windows 查看CPU数、核心数、线程数</p><p><a href="https://blog.csdn.net/ksws0292756/article/details/79119961" target="_blank" rel="noopener">https://blog.csdn.net/ksws0292756/article/details/79119961</a></p><p><br></p><h2 id="四、VMware安装VMware-Tools"><a href="#四、VMware安装VMware-Tools" class="headerlink" title="四、VMware安装VMware Tools"></a>四、VMware安装VMware Tools</h2><p>提示是在客户机安装虚拟CD驱动器 ，下面是解决办法</p><p><a href="https://blog.csdn.net/AHAU10/article/details/52611765" target="_blank" rel="noopener">https://blog.csdn.net/AHAU10/article/details/52611765</a></p><p>更改路径后，一路yes下去，最后出现enjoy安装算是成功了</p><p><a href="https://blog.csdn.net/u013142781/article/details/50539574" target="_blank" rel="noopener">https://blog.csdn.net/u013142781/article/details/50539574</a></p><p><br></p><h2 id="五、ubuntu-下python版本切换"><a href="#五、ubuntu-下python版本切换" class="headerlink" title="五、ubuntu 下python版本切换"></a>五、ubuntu 下python版本切换</h2><p>ubuntu 本身是自带 python，这样就减少了在windows下的下载和环境变量配置，但是本身是自带两个版本的python，2.X和3.X,两个版本，两个版本默认的是使用2.X</p><ul><li>python    默认版本 2.7.12</li><li>python3  版本是 3.5.2</li></ul><p>ubuntu 下 python 的版本切换：<a href="https://blog.csdn.net/beijiu5854/article/details/77897767" target="_blank" rel="noopener">https://blog.csdn.net/beijiu5854/article/details/77897767</a></p><p><br></p><h2 id="六、Ubantu下-Sublime-Text3-python-环境的搭建"><a href="#六、Ubantu下-Sublime-Text3-python-环境的搭建" class="headerlink" title="六、Ubantu下 Sublime Text3  python 环境的搭建"></a>六、Ubantu下 Sublime Text3  python 环境的搭建</h2><p><a href="https://blog.csdn.net/mao19931004/article/details/51834616" target="_blank" rel="noopener">https://blog.csdn.net/mao19931004/article/details/51834616</a></p><p>一直想实现ubuntu下终端用subl命令打开文件，呵呵呵呵，一个下午差点把sublime玩崩 ~ </p><p>我大概知道应该是路径的问题，一直链接不上，但是不知道怎么改啊~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Win10使用VMware虚拟机安装ubuntu&lt;/p&gt;
&lt;p&gt;PS：又被汪大蕾骂了一顿，还是装个虚拟机吧，毕竟做开发还是要靠Linux&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>DLL的创建与使用</title>
    <link href="http://yoursite.com/2018/09/04/DLL%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/09/04/DLL的创建与使用/</id>
    <published>2018-09-04T06:50:48.000Z</published>
    <updated>2018-09-04T06:55:22.852Z</updated>
    
    <content type="html"><![CDATA[<p>PS：前几天朱大丽，和我说她不会生成自己的DLL，我也不会啊，有什么办法，只能宠着她帮她做呗。不然整体阿谀奉承我，让我略略略 ~</p><a id="more"></a><p><br></p><h2 id="一、VS创建DLL"><a href="#一、VS创建DLL" class="headerlink" title="一、VS创建DLL"></a>一、VS创建DLL</h2><p><a href="http://wangzi6147.github.io/2015/05/05/DLL.html" target="_blank" rel="noopener">http://wangzi6147.github.io/2015/05/05/DLL.html</a></p><p>1.创建一个DLL工程</p><p><img src="http://wangzi6147.github.io/public/img/DLL_1.jpg" alt="img"></p><p><br></p><p>2.添加头文件 MyDllCalculator.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DLL_API  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLL_API __declspec(dllexport)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DLL_API代表可供调用者调用的函数 </span></span><br><span class="line"><span class="function">DLL_API  <span class="keyword">int</span> <span class="title">MyAdd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function">DLL_API  <span class="keyword">int</span> <span class="title">MyMul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><p><br></p><p>3.添加源文件 MyDllCalculator.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MyDllCalculator.h"</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyAdd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MyMul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><p>4.生成解决方案，生成Debug版本的库文件，所以在Debug文件下生成.lib和.dll</p><p>注意：如果生成的库依赖其他动态链接库，需要把依赖的.dll文件一同打包发布</p><p><br></p><p><br></p><h2 id="二、使用DLL"><a href="#二、使用DLL" class="headerlink" title="二、使用DLL"></a>二、使用DLL</h2><ol><li><p>添加工程的头文件目录：工程—属性—配置属性—c/c++—常规—附加包含目录：加上头文件存放目录</p><p>MyDllCalculator.h 的存放路径</p></li><li><p>添加文件引用的lib静态库路径：工程—属性—配置属性—链接器—常规—附加库目录：加上lib文件存放目录</p></li><li><p>添加工程引用的lib文件名：工程—属性—配置属性—链接器—输入—附加依赖项：加上lib文件名（用绝对路径）</p></li><li><p>添加工程引用的dll动态库：把引用的dll放到工程的 <strong>可执行文件</strong> 所在的目录下</p></li></ol><p>程序运行结果</p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/dll1.JPG" alt=""></p><p><br></p><p><br></p><h2 id="三、DLL-导入导出"><a href="#三、DLL-导入导出" class="headerlink" title="三、DLL 导入导出"></a>三、DLL 导入导出</h2><h3 id="1-declspec-dllexport"><a href="#1-declspec-dllexport" class="headerlink" title="1. __declspec(dllexport)"></a>1. <code>__declspec(dllexport)</code></h3><p>声明一个导出函数，即这个函数要从本DLL导出。省掉在DEF文件中手工定义导出哪些函数的一个方法。但是，如果DLL里全是C++的类，无法在DEF里指定导出的函数,，只能用<code>__declspec(dllexport)</code>导出类</p><p><br></p><h3 id="2-declspec-dllimport"><a href="#2-declspec-dllimport" class="headerlink" title="2. __declspec(dllimport)"></a>2. <code>__declspec(dllimport)</code></h3><p>声明一个导入函数，是说这个函数是从别的DLL导入。不使用，也能正确编译，但使用，可以使编译器生成更好的代码，因为它可以确定函数是否存在于 DLL 中，这使得编译器可以生成跳过间接寻址级别的代码，而这些代码通常会出现在跨 DLL 边界的函数调用中。但是，必须使用<code>__declspec(dllimport)</code>才能导入 DLL 中使用的变量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：前几天朱大丽，和我说她不会生成自己的DLL，我也不会啊，有什么办法，只能宠着她帮她做呗。不然整体阿谀奉承我，让我略略略 ~&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剑指offer（一）</title>
    <link href="http://yoursite.com/2018/08/22/%E5%89%91%E6%8C%87offer%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/08/22/剑指offer（一）/</id>
    <published>2018-08-22T13:52:48.000Z</published>
    <updated>2018-09-09T06:55:09.102Z</updated>
    
    <content type="html"><![CDATA[<p><strong>面试题一：赋值运算符函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CMyString(<span class="keyword">char</span>* pData = <span class="literal">NULL</span>);</span><br><span class="line">CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">~CMyString(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p><br></p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>没有返回值</p><p>构造函数的重载</p><p><br></p><h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>没有传入参数、没有返回值、一个类只能有一个析构函数</p><p>先构造的对象，后析构</p><p><br></p><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>根据一个类的对象，复制一个一样的对象</p><p>拷贝构造函数分为浅拷贝和深拷贝两种：</p><ul><li>浅拷贝只是复制指针的地址，会导致两个指针指向同一块内存，在分别delete时就会出现重复释放</li><li>深拷贝则创建新内存，把值拷贝进新开的内存，指针指向新开的内存</li></ul><p><br></p><h2 id="赋值运算符函数重载"><a href="#赋值运算符函数重载" class="headerlink" title="赋值运算符函数重载"></a>赋值运算符函数重载</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><ol><li><p><strong>返回值为类型的引用</strong>，函数结束前返回实例自身的引用 return *this  </p><p>若返回void，则不能做<strong>连续赋值操作</strong> a=b=c</p></li><li><p><strong>传入的参数为常量引用</strong> </p><p>引用可以<strong>避免从形参到实参会调用一次拷贝构造函数</strong>，提高效率 </p><p>const 不改变传入的实例</p></li><li><p><strong>重新分配内存时候，必须要释放之前自己已有的空间，否则会导致内存泄漏</strong> </p><p>m_pData之前指向的内存释放</p></li><li><p>判断传入的参数和当前的实例*this是否为同一实例，即this == &amp;str</p><p>若是同一个，不进行赋值</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>=&amp;str)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> []m_pData;  <span class="comment">//释放原有内存</span></span><br><span class="line">    m_pData=<span class="literal">NULL</span>;</span><br><span class="line">    m_pData=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData)+<span class="number">1</span>];  <span class="comment">//分配新内存</span></span><br><span class="line">    stpcpy(m_pData,str.m_pData);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p>先释放之前的内存再开辟新空间，如果此时内存不足导致new时抛出异常，那么此时m_pData已经为空指针，<strong>原来实例的状态被修改</strong>，这样违背了异常安全性（Exception Safety）的原则</p><p>因可以先创建一个临时实例，再交换临时实例和原来的实例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CMyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> !=&amp;str)</span><br><span class="line">    &#123;</span><br><span class="line"> <span class="comment">//临时对象strTemp，运行到if作用域外，就用自动调用strTemp的析构函数从而完成了内存的释放</span></span><br><span class="line">        CMyString strTemp(str）；   <span class="comment">//先创建一个临时对象strTemp</span></span><br><span class="line">        <span class="keyword">char</span>* pTemp=strTemp.m_pData;</span><br><span class="line">        strTemp.m_pData=m_pData;   <span class="comment">//strTemp.m_pData就是实例的m_pData之前指向的内存</span></span><br><span class="line">        m_pData=pTemp；    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：<strong>内存泄漏</strong>—程序中己动态分配的堆内存，由于某种原因程序未释放，造成系统内存的浪费</p><p><br></p><hr><p>以下是这道题涉及到的其它知识点</p><p><br></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li>引用是变量的别名，一旦把引用初始化为某个变量，就可以使用该引用名指向变量</li><li><strong>引用与指针</strong>的区别：</li><li><ul><li>不存在空引用，引用必须连接到一块合法的内存</li><li>一旦引用被初始化，就不能被指向到另一个对象，指针可以在任何时候指向到另一个对象</li><li>引用必须在创建时被初始化，指针可以在任何时间被初始化</li></ul></li></ol><p><br></p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h3 id="1-const修饰变量"><a href="#1-const修饰变量" class="headerlink" title="1. const修饰变量"></a>1. const修饰变量</h3><p>const修饰的类型为TYPE的变量value是不可变的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const TYPE ValueName = value;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-指针使用const"><a href="#2-指针使用const" class="headerlink" title="2. 指针使用const"></a>2. 指针使用const</h3><p>(1) 指针本身是常量不可变</p><p><code>char* const pContent;</code></p><p>(2) 指针所指向的内容是常量不可变</p><p><code>const char* pContent;</code></p><p>(3)两者都不可变</p><p><code>const char* const pContent;</code></p><p> <br></p><h3 id="3-函数中使用const"><a href="#3-函数中使用const" class="headerlink" title="3. 函数中使用const"></a>3. 函数中使用const</h3><p>(1)const修饰函数参数<br>a.传递过来的参数在函数内不可以改变(无意义，因为Var本身就是形参)</p><p><code>void function(const int Var);</code></p><p>b.参数指针所指内容为常量不可变</p><p><code>void function(const char* Var);</code></p><p>c.参数指针本身为常量不可变(也无意义，因为char* Var也是形参)</p><p><code>void function(char* const Var);</code></p><p>d.参数为引用，为了增加效率同时防止修改</p><p><code>void function(const Class&amp; Var);</code>//引用参数在函数内不可以改变</p><p><code>void function(const TYPE&amp; Var);</code> //引用参数在函数内为常量不可变</p><p>(2)const 修饰函数返回值</p><p><br></p><p><strong>将const类型转化为非const类型的方法</strong> ：</p><p>const_cast &lt; type_id &gt;  (expression) </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;面试题一：赋值运算符函数&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CMyString&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CMyString(&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* pData = &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CMyString(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; CMyString&amp;amp; str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;~CMyString(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt;* m_pData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>编译器、编辑器、IDE</title>
    <link href="http://yoursite.com/2018/08/22/%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%81%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%81IDE/"/>
    <id>http://yoursite.com/2018/08/22/编译器、编辑器、IDE/</id>
    <published>2018-08-22T08:59:22.000Z</published>
    <updated>2018-08-22T09:24:21.709Z</updated>
    
    <content type="html"><![CDATA[<p>PS：关于版本和各种编辑器、编译器、IDE</p><a id="more"></a><h2 id="C-版本"><a href="#C-版本" class="headerlink" title="C++版本"></a>C++版本</h2><ul><li>C++03</li><li>C++11</li><li>C++14</li></ul><p><br></p><h2 id="python版本"><a href="#python版本" class="headerlink" title="python版本"></a>python版本</h2><ul><li>python2.x</li><li>python3.x</li></ul><p><br></p><h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>编译器是编译一个文件</p><ul><li>gcc/g++</li><li>clang</li></ul><p><br></p><h2 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h2><p>make是<strong>编译多个源文件</strong>的工具，解释makefile中的指令，看作是编译器的调度器</p><p>make通过读入makefile，执行一组以gcc/g++为主的shell命令序列，输入文件主要用来记录文件之间的依赖关系和命令执行顺序</p><p><br></p><h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>CMake是一种跨平台编译工具</p><p>CMake主要是编写CMakeLists.txt文件，然后用cmake命令将CMakeLists.txt文件转化为make所需要的makefile文件，最后用make命令编译源码生成可执行程序或共享库 so(shared object)</p><p><br></p><h2 id="集成开发环境IDE"><a href="#集成开发环境IDE" class="headerlink" title="集成开发环境IDE"></a>集成开发环境IDE</h2><p>集成开发环境（IDE，Integrated Development Environment ）：一般包括代码编辑器、编译器、调试器和图形用户界面等工具。</p><ul><li>Microsoft Visual C++：（简称Visual C++、MSVC、VC++或VC）是微软公司的C++开发工具</li><li>Eclipse：开源的、跨平台的 IDE</li><li>Qt Creator：收费的、跨平台的 IDE</li><li>Visual Studio：Windows平台应用程序的集成开发环境</li><li>Android Studio： Android平台开发程序的集成开发环境</li></ul><p><br></p><h2 id="代码编辑器"><a href="#代码编辑器" class="headerlink" title="代码编辑器"></a>代码编辑器</h2><ul><li>Atom  ：跨平台的文本编辑器</li><li>Sublime Text：跨平台的文本编辑器</li><li>VI/VIM：Unix/Linux </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：关于版本和各种编辑器、编译器、IDE&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>VS+opencv的配置</title>
    <link href="http://yoursite.com/2018/08/19/VS-opencv%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/08/19/VS-opencv的配置/</id>
    <published>2018-08-19T05:53:29.000Z</published>
    <updated>2018-08-22T09:01:42.962Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/u013634684/article/details/48289449" target="_blank" rel="noopener">https://blog.csdn.net/u013634684/article/details/48289449</a></p><p><a href="https://blog.csdn.net/woainishifu/article/details/53507723" target="_blank" rel="noopener">https://blog.csdn.net/woainishifu/article/details/53507723</a></p><p>PS ：关于使用VS时，遇到的一些疑问，做了个整理 ~ </p><p>想要发一些感慨，之前很多东西其实是不理解的，现在看多了，慢慢脑子里面有个大概的图谱，把学到的东西串起来，这样有了更深入的理解</p><a id="more"></a><p><br></p><h2 id="一、VS"><a href="#一、VS" class="headerlink" title="一、VS"></a>一、VS</h2><ul><li><strong>.sln：解决方案文件</strong></li></ul><p>一个解决方案里面可以包含多个工程</p><ul><li><strong>.vcproj：工程文件</strong></li></ul><p>只打开vcproj文件编译不了，可能是因为这个工程里面用到了同一个解决方案中其它工程</p><p><br></p><h2 id="二、Debug和Relesse版本"><a href="#二、Debug和Relesse版本" class="headerlink" title="二、Debug和Relesse版本"></a>二、Debug和Relesse版本</h2><h3 id="1-Debug"><a href="#1-Debug" class="headerlink" title="1. Debug"></a>1. Debug</h3><p>调试版本，包含调试信息，除了.exe 和 .dll 文件外，还包括了.pdb文件记录代码断点等调试信息</p><p>使用调试版本运行时刻的函数库</p><h3 id="2-Release"><a href="#2-Release" class="headerlink" title="2.Release"></a>2.Release</h3><p>发布版本，不进行调试，编译时对速度进行优化</p><p>使用发布版本运行时刻的函数库</p><p><br></p><h2 id="三、运行时库"><a href="#三、运行时库" class="headerlink" title="三、运行时库"></a>三、运行时库</h2><h3 id="1-运行时库"><a href="#1-运行时库" class="headerlink" title="1. 运行时库"></a>1. 运行时库</h3><p> Runtime Library 就是运行时库，也简称 CRT（C Run Time Library），是程序在运行时所需要的库文件，通常运行时库是以 lib 或 dll 形式提供的</p><p>运行时库指的就是对这些底层的基础功能实现的动态库（dll），只有程序用到了它才会被加载，没有程序使用的时候不会驻留内存的</p><p>虽然运行时库应该是动态库，但 <strong>习惯上把与动态运行时库相同代码编译出来的静态库也称为运行时库</strong></p><h3 id="2-设置"><a href="#2-设置" class="headerlink" title="2. 设置"></a>2. 设置</h3><p>Properties-&gt;Configuration Properties-&gt;C/C++-&gt;Code Generation-&gt;Runtime Library 中设置采用的运行时库的类型</p><p><br></p><h3 id="3-CRT的类型"><a href="#3-CRT的类型" class="headerlink" title="3. CRT的类型"></a>3. CRT的类型</h3><ul><li>MT：Release版的多线程静态库</li><li>MTd： Debug版的多线程静态库</li><li>DLL/MD：Release版的多线程动态库</li><li>DLL/MDd：Debug版的多线程动态库</li></ul><p><br></p><h2 id="四、opencv"><a href="#四、opencv" class="headerlink" title="四、opencv"></a>四、opencv</h2><p><strong>1.vc10, vc11, vc12</strong> </p><p>vc10, vc11, vc12 分别表示VS2010, VS2012, VS2013的Visual Studio使用的<strong>编译器版本</strong></p><p><strong>2.x86, x64</strong></p><p>不同的指令集架构：</p><ul><li>x86  支持32位的intel/AMD/VIA的CPU，并向下兼容16位  32位系统</li><li>x64 支持32位和64位的intel/AMD CPU，指令集与x86兼容，并向下兼容16位、64位系统</li></ul><p><strong>3.配置第三方库</strong></p><p>（1）头文件：一般放在include路径下</p><p>h文件是<strong>头文件</strong>，需要通过#include这种方式引用的，所以对应的是包含目录</p><p>（2）dll文件：一般放在bin 路径下</p><p><strong>dll文件是可执行文件</strong>，所以对应的是可执行文件目录</p><p>（3）lib文件：一般放在lib路径下</p><p><strong>lib文件是库文件</strong>，所以对应的是库目录</p><p><br></p><p>关于静态链接和动态链接：</p><p><a href="https://sophia0130.github.io/2018/08/19/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/" target="_blank" rel="noopener">https://sophia0130.github.io/2018/08/19/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u013634684/article/details/48289449&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/u013634684/article/details/48289449&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/woainishifu/article/details/53507723&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/woainishifu/article/details/53507723&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PS ：关于使用VS时，遇到的一些疑问，做了个整理 ~ &lt;/p&gt;
&lt;p&gt;想要发一些感慨，之前很多东西其实是不理解的，现在看多了，慢慢脑子里面有个大概的图谱，把学到的东西串起来，这样有了更深入的理解&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>静态链接和动态链接</title>
    <link href="http://yoursite.com/2018/08/19/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2018/08/19/静态链接和动态链接/</id>
    <published>2018-08-19T05:36:50.000Z</published>
    <updated>2018-08-19T05:39:42.156Z</updated>
    
    <content type="html"><![CDATA[<p>预处理（需要头文件）（.c） -&gt; 编译（.asm） -&gt; 汇编 （.obj）-&gt; 链接（需要库文件）（.exe）-&gt;运行（动态链接）</p><p><img src="https://images0.cnblogs.com/blog/92071/201310/16201602-9c6047fe25ac46659d0a5ab2945552ce.png" alt=""></p><a id="more"></a><p><br></p><h2 id="一、编译和链接"><a href="#一、编译和链接" class="headerlink" title="一、编译和链接"></a>一、编译和链接</h2><p>编译：只要有头文件中的声明就足够了，头文件只是告诉编译器，函数是如何去调用如何返回</p><p>链接：把已经编译好的.obj和现有的.lib文件进行链接，这时生成可执行文件</p><p><br></p><h2 id="二、头文件和库文件"><a href="#二、头文件和库文件" class="headerlink" title="二、头文件和库文件"></a>二、头文件和库文件</h2><p>头文件：提供声明，编译的时候需要</p><p>库文件：提供定义/实现，链接时将指定的目标文件抽取出</p><p><br></p><h2 id="三、库"><a href="#三、库" class="headerlink" title="三、库"></a>三、库</h2><h3 id="1-lib后缀的库有两种"><a href="#1-lib后缀的库有两种" class="headerlink" title="1. lib后缀的库有两种"></a>1. lib后缀的库有两种</h3><ol><li>静态链接库（.lib）：静态库是一个或者多个obj文件的打包，包含了实际执行代码</li><li>动态链接库的导入库（.lib）：属于动态链接库的附加依赖项，只包含了确保程序找到对应函数的一些基本索引信息</li></ol><p><br></p><h3 id="2-dll后缀的库"><a href="#2-dll后缀的库" class="headerlink" title="2. dll后缀的库"></a>2. dll后缀的库</h3><p>动态链接库（.dll）：是具体的实现，程序运行时动态调用</p><p><br></p><h2 id="四、静态链接"><a href="#四、静态链接" class="headerlink" title="四、静态链接"></a>四、静态链接</h2><h3 id="1-用到的库"><a href="#1-用到的库" class="headerlink" title="1. 用到的库"></a>1. 用到的库</h3><p>静态链接库：（.lib为后缀）是一个或者多个obj文件的打包 ，<strong>『 链接时使用』</strong></p><h3 id="2-静态链接"><a href="#2-静态链接" class="headerlink" title="2. 静态链接"></a>2. 静态链接</h3><p>把.lib文件中用到的函数代码直接链接进可执行文件，程序运行的时候不再需要其它的库文件</p><h3 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h3><p>程序在运行时与其它库函数无关，用户安装时就不需要再挂动态库，移植方便</p><h3 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4. 缺点"></a>4. 缺点</h3><p>所有相关的目标文件和函数库被链接合成一个可执行文件，当多个程序都调用相同函数时，内存中就会存在这个函数的多个拷贝，浪费空间和资源</p><p><br></p><h2 id="五、动态链接"><a href="#五、动态链接" class="headerlink" title="五、动态链接"></a>五、动态链接</h2><h3 id="1-用到的库-1"><a href="#1-用到的库-1" class="headerlink" title="1. 用到的库"></a>1. 用到的库</h3><ul><li>动态链接库的导入库： （.lib为后缀）属于动态链接库的附加依赖项，一般是一些索引信息，告诉链接器调用的函数在哪个dll中，函数执行代码在dll中的什么位置，<strong>『 链接时使用』</strong></li><li>动态链接库：（.dll为后缀）具体的实现，<strong>『 程序运行时使用』</strong></li></ul><h3 id="2-动态链接"><a href="#2-动态链接" class="headerlink" title="2. 动态链接"></a>2. 动态链接</h3><p>调用的函数代码并没有被拷贝到可执行文件中，仅仅在其中加入了所调用函数的索引信息，只有当应用程序被装入内存开始运行时，在Windows的管理下，才在应用程序与相应的dll之间建立链接关系。</p><h3 id="3-优点-1"><a href="#3-优点-1" class="headerlink" title="3. 优点"></a>3. 优点</h3><p>这样当一个或多个应用程序运行时，才将程序代码和被调用的函数代码链接起来，从而节省了内存资源</p><h3 id="4-缺点-1"><a href="#4-缺点-1" class="headerlink" title="4. 缺点"></a>4. 缺点</h3><p>dll 和 lib 文件必须随应用程序一起发行，否则应用程序将会产生错误</p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;预处理（需要头文件）（.c） -&amp;gt; 编译（.asm） -&amp;gt; 汇编 （.obj）-&amp;gt; 链接（需要库文件）（.exe）-&amp;gt;运行（动态链接）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog/92071/201310/16201602-9c6047fe25ac46659d0a5ab2945552ce.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>置顶目录</title>
    <link href="http://yoursite.com/2018/08/15/%E7%BD%AE%E9%A1%B6%E7%9B%AE%E5%BD%95/"/>
    <id>http://yoursite.com/2018/08/15/置顶目录/</id>
    <published>2018-08-15T01:59:20.000Z</published>
    <updated>2018-08-23T08:22:49.013Z</updated>
    
    <content type="html"><![CDATA[<p>检索目录列表</p><a id="more"></a><p><br></p><h2 id="opencv"><a href="#opencv" class="headerlink" title="opencv"></a>opencv</h2><p><a href="https://sophia0130.github.io/2018/05/07/ImageWatch/" target="_blank" rel="noopener">ImageWatch — VS编译小工具</a></p><p>opencv（一）~（？）学习笔记系列 ~ 持更</p><p><br></p><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>贝叶斯分类器和概率图模型</p><p><a href="https://sophia0130.github.io/2018/05/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E5%A4%A7%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">机器学习算法大总结</a></p><p><br></p><h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><p><a href="https://sophia0130.github.io/2018/06/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">深度学习与强化学习</a></p><p>Deep-Learning—吴恩达—作业（一）~（七）系列</p><p><br></p><h2 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h2><p>1.cs231n笔记（一）~（十一）系列</p><ul><li>线性回归、逻辑回归、多分类</li><li>最优化（Optimization）：最小化损失函数</li><li>反向传播：链式法则求梯度</li><li>深度学习框架：PyTorch（Facebook）、Tensorflow（Google）</li><li>分类、检测、分割、跟踪</li><li>反卷积与特征可视化</li></ul><p>不同种类的网络：</p><ul><li>神经网络</li><li>卷积神经网络</li><li>经典CNN网络</li><li>循环神经网络</li><li>生成式对抗网络</li></ul><p>2.<a href="https://sophia0130.github.io/2018/08/01/NLP%E2%80%94%E2%80%94word2vec/" target="_blank" rel="noopener">NLP——word2vec</a></p><p><br></p><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p><a href="https://sophia0130.github.io/2018/06/13/anaconda%EF%BC%8Cconda%EF%BC%8Cpip%E7%9A%84%E5%85%B3%E7%B3%BB/" target="_blank" rel="noopener">anaconda，conda，pip的关系</a></p><p><a href="https://sophia0130.github.io/2018/07/29/Ipython-%E4%B8%8E-Jupyter-Notebook/" target="_blank" rel="noopener">Ipython 与 Jupyter Notebook</a></p><p><a href="https://sophia0130.github.io/2018/06/11/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" target="_blank" rel="noopener">正则表达式</a></p><p><a href="https://sophia0130.github.io/2018/06/28/%E8%A7%A3%E5%86%B3pip%E5%AE%89%E8%A3%85%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">解决pip安装慢的问题</a></p><p><br></p><h2 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h2><p><a href="https://sophia0130.github.io/2018/08/05/TensorFlow-%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">TensorFlow 使用总结</a></p><p><a href="https://sophia0130.github.io/2018/08/05/Tensorboard-%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">Tensorboard 使用总结</a></p><p>TensorFlow代码实现（一）~（四）系列</p><p><br></p><h2 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h2><p>剑指offer（一）~？持续更</p><p><br></p><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p><a href="https://sophia0130.github.io/2018/07/14/%E7%A8%8B%E5%BA%8F%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84/" target="_blank" rel="noopener">《程序是怎样跑起来的》读书笔记</a></p><p><a href="https://sophia0130.github.io/2018/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%90%84%E7%A7%8D%E6%9D%BF%E5%AD%90/" target="_blank" rel="noopener">嵌入式与板子：MCU、ARM、DSP、FPGA、SOC</a></p><p><a href="https://sophia0130.github.io/2018/07/15/%E6%98%BE%E5%8D%A1/" target="_blank" rel="noopener">显卡</a></p><p><a href="https://sophia0130.github.io/2018/07/26/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" target="_blank" rel="noopener">进程和线程</a></p><p><br></p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><a href="https://sophia0130.github.io/2018/08/22/%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%81%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%81IDE/" target="_blank" rel="noopener">编译器、IDE、编辑器种类整理</a></p><p><a href="https://sophia0130.github.io/2018/05/04/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/" target="_blank" rel="noopener">编译器和解释器</a></p><p><a href="https://sophia0130.github.io/2018/05/04/make%E5%92%8CCMake/" target="_blank" rel="noopener">make和cmake</a></p><p><br></p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p><a href="https://sophia0130.github.io/2018/05/14/XML%E3%80%81YAML%E3%80%81JSON/" target="_blank" rel="noopener">序列化数据格式 ：xml、yaml、json</a></p><p><a href="https://sophia0130.github.io/2018/05/18/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E4%BA%91-%E7%89%B9%E5%88%AB%E7%AE%80%E9%99%8B%E7%9A%84%E8%AE%A4%E8%AF%86/" target="_blank" rel="noopener">虚拟机和云</a></p><p><a href="https://sophia0130.github.io/2018/05/04/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%90%86%E8%A7%A3/" target="_blank" rel="noopener">网络基础知识</a></p><p><br></p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p><a href="https://sophia0130.github.io/2018/06/01/Git-%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">Git学习笔记</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;检索目录列表&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>opencv（六）——图像坐标系和宽高</title>
    <link href="http://yoursite.com/2018/08/15/opencv%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E5%9D%90%E6%A0%87%E7%B3%BB%E5%92%8C%E5%AE%BD%E9%AB%98/"/>
    <id>http://yoursite.com/2018/08/15/opencv（六）——图像坐标系和宽高/</id>
    <published>2018-08-15T01:52:32.000Z</published>
    <updated>2018-08-15T01:52:54.391Z</updated>
    
    <content type="html"><![CDATA[<p>PS：为啥写这篇博，因为我傻啊 ~ 每次写程序遇到图像  <strong>坐标系-宽高-行列</strong>，就开始抓狂                        哎呀到底是(i，j)还是(j，i)，这篇博写的很详细啦 ~</p><p><a href="https://blog.csdn.net/oqqenvy12/article/details/71933651" target="_blank" rel="noopener">https://blog.csdn.net/oqqenvy12/article/details/71933651</a></p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PS：为啥写这篇博，因为我傻啊 ~ 每次写程序遇到图像  &lt;strong&gt;坐标系-宽高-行列&lt;/strong&gt;，就开始抓狂                        哎呀到底是(i，j)还是(j，i)，这篇博写的很详细啦 ~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https:
      
    
    </summary>
    
    
      <category term="opencv" scheme="http://yoursite.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>opencv（五）——图像读取</title>
    <link href="http://yoursite.com/2018/08/15/opencv%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E5%9B%BE%E5%83%8F%E8%AF%BB%E5%8F%96/"/>
    <id>http://yoursite.com/2018/08/15/opencv（五）——图像读取/</id>
    <published>2018-08-15T01:47:54.000Z</published>
    <updated>2018-08-15T01:51:30.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扫描、读取图像的四种方法"><a href="#扫描、读取图像的四种方法" class="headerlink" title="扫描、读取图像的四种方法"></a>扫描、读取图像的四种方法</h2><p>1.C operator [] 指针</p><p>2.iterator 迭代法 用迭代器遍历 [推荐使用]</p><p>3.on-the-fly address generation  .at()函数</p><p>4.LUT function [推荐使用]</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扫描图像的四种方法的比较</span></span><br><span class="line"><span class="comment">//输入的三个参数  imageName.jpg  divideWith  intValueToReduce [G](可省略)</span></span><br><span class="line"><span class="comment">//项目属性需要更改：项目属性 -&gt; 配置属性 -&gt; C/C++ -&gt; 代码生成 -&gt; 运行库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/utility.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgcodecs.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span></span><br><span class="line">&lt;&lt; <span class="string">"\n--------------------------------------------------------------------------"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"This program shows how to scan image objects in OpenCV (cv::Mat)."</span></span><br><span class="line">&lt;&lt; <span class="string">" we take an input image and divide the native color palette (255) with the input. "</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"Shows C operator[] method, iterators and at function for on-the-fly item address calculation."</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"./输入三个参数 &lt;imageNameToUse&gt; &lt;divideWith&gt; &lt;G&gt;(可省略)"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"if you add a G parameter the image is processed in gray scale"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="string">"--------------------------------------------------------------------------"</span> &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Mat&amp; <span class="title">ScanImageAndReduceC</span><span class="params">(Mat&amp; I, <span class="keyword">const</span> uchar* table)</span></span>;</span><br><span class="line"><span class="function">Mat&amp; <span class="title">ScanImageAndReduceIterator</span><span class="params">(Mat&amp; I, <span class="keyword">const</span> uchar* table)</span></span>;</span><br><span class="line"><span class="function">Mat&amp; <span class="title">ScanImageAndReduceRandomAccess</span><span class="params">(Mat&amp; I, <span class="keyword">const</span> uchar * table)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">help();</span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Not enough parameters"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mat I, J;</span><br><span class="line"><span class="keyword">if</span> (argc == <span class="number">4</span> &amp;&amp; !<span class="built_in">strcmp</span>(argv[<span class="number">3</span>], <span class="string">"G"</span>))</span><br><span class="line">I = imread(argv[<span class="number">1</span>], IMREAD_GRAYSCALE);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">I = imread(argv[<span class="number">1</span>], IMREAD_COLOR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (I.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"The image"</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="string">" could not be loaded."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用命令行参数argv[2]给出的整数进行颜色缩减</span></span><br><span class="line"><span class="keyword">int</span> divideWith = <span class="number">0</span>; <span class="comment">// convert our input string to number - C++ style</span></span><br><span class="line"><span class="built_in">stringstream</span> s;</span><br><span class="line">s &lt;&lt; argv[<span class="number">2</span>];</span><br><span class="line">s &gt;&gt; divideWith;</span><br><span class="line"><span class="keyword">if</span> (!s || !divideWith)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Invalid number entered for dividing. "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找表</span></span><br><span class="line">uchar table[<span class="number">256</span>]; <span class="comment">//查找表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">table[i] = (uchar)(divideWith * (i / divideWith));</span><br><span class="line"><span class="comment">//divideWith=10时，0到9取为0，10到19取为10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时间-单位毫秒</span></span><br><span class="line"><span class="comment">// getTickCount() 返回CPU自某个事件以来走过的时钟周期数</span></span><br><span class="line"><span class="comment">// getTickFrequency()  返回CPU一秒钟所走的时钟周期数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> times = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">double</span> t;</span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line">t = (<span class="keyword">double</span>)getTickCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cv::Mat clone_i = I.clone();</span><br><span class="line">J = ScanImageAndReduceC(clone_i, table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t = <span class="number">1000</span> * ((<span class="keyword">double</span>)getTickCount() - t) / getTickFrequency();</span><br><span class="line">t /= times;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Time of reducing with the C operator [] (averaged for "</span></span><br><span class="line">&lt;&lt; times &lt;&lt; <span class="string">" runs): "</span> &lt;&lt; t &lt;&lt; <span class="string">" milliseconds."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line">t = (<span class="keyword">double</span>)getTickCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cv::Mat clone_i = I.clone();</span><br><span class="line">J = ScanImageAndReduceIterator(clone_i, table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t = <span class="number">1000</span> * ((<span class="keyword">double</span>)getTickCount() - t) / getTickFrequency();</span><br><span class="line">t /= times;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Time of reducing with the iterator (averaged for "</span></span><br><span class="line">&lt;&lt; times &lt;&lt; <span class="string">" runs): "</span> &lt;&lt; t &lt;&lt; <span class="string">" milliseconds."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//方法3</span></span><br><span class="line">t = (<span class="keyword">double</span>)getTickCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cv::Mat clone_i = I.clone();</span><br><span class="line">ScanImageAndReduceRandomAccess(clone_i, table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t = <span class="number">1000</span> * ((<span class="keyword">double</span>)getTickCount() - t) / getTickFrequency();</span><br><span class="line">t /= times;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Time of reducing with the on-the-fly address generation - at function (averaged for "</span></span><br><span class="line">&lt;&lt; times &lt;&lt; <span class="string">" runs): "</span> &lt;&lt; t &lt;&lt; <span class="string">" milliseconds."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//方法3</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//方法4</span></span><br><span class="line"><span class="comment">//最被推荐的用于实现批量图像元素查找和更该操作图像方法，在图像处理中，对于一个给定的值，将其替换成其他的值是一个很常见的操作</span></span><br><span class="line"><span class="function">Mat <span class="title">lookUpTable</span><span class="params">(<span class="number">1</span>, <span class="number">256</span>, CV_8U)</span></span>;</span><br><span class="line">uchar* p = lookUpTable.ptr();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">p[i] = table[i]; <span class="comment">//table数组的值赋给lookUpTable Mat</span></span><br><span class="line"><span class="comment">//! [table-init]</span></span><br><span class="line"></span><br><span class="line">t = (<span class="keyword">double</span>)getTickCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; ++i)</span><br><span class="line"><span class="comment">//! [table-use]</span></span><br><span class="line">LUT(I, lookUpTable, J);</span><br><span class="line"><span class="comment">//! [table-use]</span></span><br><span class="line"></span><br><span class="line">t = <span class="number">1000</span> * ((<span class="keyword">double</span>)getTickCount() - t) / getTickFrequency();</span><br><span class="line">t /= times;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Time of reducing with the LUT function (averaged for "</span></span><br><span class="line">&lt;&lt; times &lt;&lt; <span class="string">" runs): "</span> &lt;&lt; t &lt;&lt; <span class="string">" milliseconds."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="comment">//方法4</span></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! [scan-c] c语言风格，用指针</span></span><br><span class="line"><span class="function">Mat&amp; <span class="title">ScanImageAndReduceC</span><span class="params">(Mat&amp; I, <span class="keyword">const</span> uchar* <span class="keyword">const</span> table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// accept only char type matrices</span></span><br><span class="line">CV_Assert(I.depth() == CV_8U); <span class="comment">//CV_Assert()若括号中的表达式值为false，则返回一个错误信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> channels = I.channels();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nRows = I.rows;</span><br><span class="line"><span class="keyword">int</span> nCols = I.cols * channels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (I.isContinuous()) <span class="comment">//判断图像在内存中是否连续存储</span></span><br><span class="line">&#123;</span><br><span class="line">nCols *= nRows;   <span class="comment">//若图像连续存储将图像作为一维数组</span></span><br><span class="line">nRows = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//若图像连续存储，则可以将图像的数据看成是一个一维数组</span></span><br><span class="line"><span class="comment">//p（uchar*）就是指向图像数据的第一个字节的，因此可以用data指针访问图像的数据,从而加速Mat图像的访问速度</span></span><br><span class="line"><span class="comment">//一般经过裁剪的Mat图像，都不再连续了</span></span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">uchar* p;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nRows; ++i)</span><br><span class="line">&#123;</span><br><span class="line">p = I.ptr&lt;uchar&gt;(i);</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nCols; ++j)</span><br><span class="line">&#123;</span><br><span class="line">p[j] = table[p[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> I;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//! [scan-c]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代法</span></span><br><span class="line"><span class="comment">//! [scan-iterator] 获得图像矩阵的begin和end</span></span><br><span class="line"><span class="function">Mat&amp; <span class="title">ScanImageAndReduceIterator</span><span class="params">(Mat&amp; I, <span class="keyword">const</span> uchar* <span class="keyword">const</span> table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// accept only char type matrices</span></span><br><span class="line">CV_Assert(I.depth() == CV_8U);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> channels = I.channels();</span><br><span class="line"><span class="keyword">switch</span> (channels)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line">  MatIterator_&lt;uchar&gt; it, end;</span><br><span class="line">  <span class="keyword">for</span> (it = I.begin&lt;uchar&gt;(), end = I.end&lt;uchar&gt;(); it != end; ++it)</span><br><span class="line">  *it = table[*it];</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">&#123;</span><br><span class="line">  MatIterator_&lt;Vec3b&gt; it, end;</span><br><span class="line">  <span class="keyword">for</span> (it = I.begin&lt;Vec3b&gt;(), end = I.end&lt;Vec3b&gt;(); it != end; ++it)</span><br><span class="line">  &#123;</span><br><span class="line">  (*it)[<span class="number">0</span>] = table[(*it)[<span class="number">0</span>]];</span><br><span class="line">  (*it)[<span class="number">1</span>] = table[(*it)[<span class="number">1</span>]];</span><br><span class="line">  (*it)[<span class="number">2</span>] = table[(*it)[<span class="number">2</span>]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> I;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//! [scan-iterator]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// On-the-fly 地址计算</span></span><br><span class="line"><span class="comment">//! [scan-random] 这个方法并不推荐被用来进行图像扫描，需要知道元素的所在行数与列数还有数据类型</span></span><br><span class="line"><span class="function">Mat&amp; <span class="title">ScanImageAndReduceRandomAccess</span><span class="params">(Mat&amp; I, <span class="keyword">const</span> uchar* <span class="keyword">const</span> table)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// accept only char type matrices</span></span><br><span class="line">CV_Assert(I.depth() == CV_8U);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> channels = I.channels();</span><br><span class="line"><span class="keyword">switch</span> (channels)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; I.rows; ++i)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; I.cols; ++j)</span><br><span class="line">  I.at&lt;uchar&gt;(i, j) = table[I.at&lt;uchar&gt;(i, j)];</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">&#123;</span><br><span class="line">  Mat_&lt;Vec3b&gt; _I = I;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; I.rows; ++i)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; I.cols; ++j)</span><br><span class="line">  &#123;</span><br><span class="line">  _I(i, j)[<span class="number">0</span>] = table[_I(i, j)[<span class="number">0</span>]];</span><br><span class="line">  _I(i, j)[<span class="number">1</span>] = table[_I(i, j)[<span class="number">1</span>]];</span><br><span class="line">  _I(i, j)[<span class="number">2</span>] = table[_I(i, j)[<span class="number">2</span>]];</span><br><span class="line">  &#125;</span><br><span class="line">  I = _I;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> I;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果比较"><a href="#结果比较" class="headerlink" title="结果比较"></a>结果比较</h2><p>不同的图片几种方法得到的执行时间差很大：                                        </p><ol><li><strong>尽量使用 OpenCV 内置函数</strong>，调用LUT 函数可以获得最快的速度，这是因为OpenCV库可以通过英特尔线程架构启用多线程。                                                    </li><li>指针法也很快，但是前提是<strong>指针连续</strong>。                                        </li><li>.at()函数方法并不推荐被用来进行图像扫描。</li></ol><p><br></p><h2 id="程序解读"><a href="#程序解读" class="headerlink" title="程序解读"></a>程序解读</h2><h3 id="1-计算运算时间的方法"><a href="#1-计算运算时间的方法" class="headerlink" title="1.计算运算时间的方法"></a>1.计算运算时间的方法</h3><p>getTickCount() 返回CPU自某个事件以来走过的时钟周期数<br>getTickFrequency()  返回CPU一秒钟所走的时钟周期数</p><p><br></p><h3 id="2-查找表缩短颜色空间"><a href="#2-查找表缩短颜色空间" class="headerlink" title="2.查找表缩短颜色空间"></a>2.查找表缩短颜色空间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uchar table[<span class="number">256</span>]; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">       table[i] = divideWith* (i/divideWith); <span class="comment">//当divideWith=10时，0到9取为0，10到19取为10</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;扫描、读取图像的四种方法&quot;&gt;&lt;a href=&quot;#扫描、读取图像的四种方法&quot; class=&quot;headerlink&quot; title=&quot;扫描、读取图像的四种方法&quot;&gt;&lt;/a&gt;扫描、读取图像的四种方法&lt;/h2&gt;&lt;p&gt;1.C operator [] 指针&lt;/p&gt;
&lt;p&gt;2.iterator 迭代法 用迭代器遍历 [推荐使用]&lt;/p&gt;
&lt;p&gt;3.on-the-fly address generation  .at()函数&lt;/p&gt;
&lt;p&gt;4.LUT function [推荐使用]&lt;/p&gt;
    
    </summary>
    
    
      <category term="opencv" scheme="http://yoursite.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>opencv（四）——AdaBoost</title>
    <link href="http://yoursite.com/2018/08/14/opencv%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94AdaBoost/"/>
    <id>http://yoursite.com/2018/08/14/opencv（四）——AdaBoost/</id>
    <published>2018-08-14T13:18:27.000Z</published>
    <updated>2018-08-19T06:31:24.659Z</updated>
    
    <content type="html"><![CDATA[<p>PS：本来还想用Adaboost做多分类，弃了~</p><a id="more"></a><h2 id="一、Haar、LBP"><a href="#一、Haar、LBP" class="headerlink" title="一、Haar、LBP"></a>一、Haar、LBP</h2><ol><li>HAAR特征是浮点数计算，LBP特征是整数计算；</li><li>LBP训练需要的样本数量比HAAR大 </li><li>LBP的速度一般比HAAR快 </li><li>同样的样本HAAR训练出来的检测结果要比LBP准确</li><li>扩大LBP的样本数据可达到HAAR的训练效果</li></ol><p><br></p><h2 id="二、级联分类器"><a href="#二、级联分类器" class="headerlink" title="二、级联分类器"></a>二、级联分类器</h2><p><a href="https://zhuanlan.zhihu.com/p/35058334" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35058334</a></p><ol><li>级联分类器结构：弱分类器线性组合成为强分类器，强分类器用决策树的形式级联</li><li>存储分类器的XML中的参数</li></ol><p><img src="http://p8ge6t5tt.bkt.clouddn.com/xml1.JPG" alt=""></p><p><br></p><h2 id="三、利用并查集合并窗口和丢弃零散分布的误检窗口"><a href="#三、利用并查集合并窗口和丢弃零散分布的误检窗口" class="headerlink" title="三、利用并查集合并窗口和丢弃零散分布的误检窗口"></a>三、利用并查集合并窗口和丢弃零散分布的误检窗口</h2><p><br></p><h2 id="四、AdaBoost-算法"><a href="#四、AdaBoost-算法" class="headerlink" title="四、AdaBoost 算法"></a>四、AdaBoost 算法</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>（1）准确率</p><ul><li>查准率 Precision</li><li>查全率 Recall，precision和recall都越高越好</li><li>命中率 hitRate，度量检测器对正样本的通过能力，越接近1越好  </li><li>虚警率 falseAlarm，度量检测器对负样本的通过能力，越接近0越好</li></ul><p>（2）positive sample会产生：</p><ul><li>TP(true positive)，即positive sample被检测器判定为目标</li><li>FN(false negative)，即positive samples被检测器判断为非目标</li></ul><p>（3）negative sample会产生：</p><ul><li>TN(true negative)，即negative sample被检测器判定为非目标</li><li>FP(false positive)，即negative sample被检测器判定为目标</li></ul><p><br></p><h3 id="2-AdaBoost-步骤"><a href="#2-AdaBoost-步骤" class="headerlink" title="2. AdaBoost 步骤"></a>2. AdaBoost 步骤</h3><ol><li>找TP和FP作为训练样本</li><li>计算每个Haar特征在当前权重下的Best split threshold+leftvalue+rightvalue，组成了一个个弱分类器</li><li>通过WSE寻找最优的弱分类器</li><li>更新权重</li><li>按照minHitRate估计stageThreshold</li><li>重复上述1-5步骤，直到falseAlarmRate到达要求，或弱分类器数量足够，停止循环，输出stage</li><li>进入下一个stage训练</li></ol><p><br></p><h2 id="五、opencv-提供的模型和工具"><a href="#五、opencv-提供的模型和工具" class="headerlink" title="五、opencv 提供的模型和工具"></a>五、opencv 提供的模型和工具</h2><p>应用放的位置  <strong>D:\program\opencv3.0.0\opencv\build\x64\vc12\bin</strong></p><p>1.opencv 自带的检测模型</p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/opencv%E8%87%AA%E5%B8%A6%E7%9A%84xml.JPG" alt="img"></p><p>2.opencv 自带的AdaBoost分类器</p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/opencvtrain.JPG" alt="img"></p><p>opencv_annotation         用来在一张大图中标定一个或多个需要检测的目标<br>opencv_createsamples   用来制作positive sample的vec<br>opencv_traincascade      用来训练得到需要的cascade.xml</p><p><br></p><h2 id="六、AdaBoost训练过程"><a href="#六、AdaBoost训练过程" class="headerlink" title="六、AdaBoost训练过程"></a>六、AdaBoost训练过程</h2><h3 id="阶段一：训练数据的准备"><a href="#阶段一：训练数据的准备" class="headerlink" title="阶段一：训练数据的准备"></a>阶段一：训练数据的准备</h3><h4 id="1-导出正负样本的文件列表"><a href="#1-导出正负样本的文件列表" class="headerlink" title="1. 导出正负样本的文件列表"></a>1. 导出正负样本的文件列表</h4><p>（1）注意：</p><ol><li><p>最好使用图片的<strong>绝对路径</strong>，不然最后训练可能找不到图片 Image reader can not be created from</p></li><li><p><strong>删除</strong>存放路径文件中的其它文件路径，只保留图片的路径</p></li><li><p>存放图片的路径的文件<strong>可以是 .txt 也可以是 .dat 文件</strong></p><p>txt扩展名的文件：存放ASCII码形式的文件</p><p>dat扩展名的文件：存放ASCII码，也可以是二进制（内存格式）形式的文件</p></li></ol><p>（2）用windows中的 <strong>dir</strong> 命令导出图片文件的列表</p><p><code>dir /b /s /o:n /a:a &gt; pos.dat</code>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/b   表示去除摘要信息，且顶格显示完整路径</span><br><span class="line"></span><br><span class="line">/s   表示枚举嵌套文件夹中的内容</span><br><span class="line"></span><br><span class="line">/o:n 表示根据文件名排序</span><br><span class="line"></span><br><span class="line">/a:a 表示只枚举文件而不枚举其他</span><br></pre></td></tr></table></figure><p>单独使用dir /b与dir /s 都不会显示完整路径，只有这两个组合才会显示完整路径</p><p><br></p><h4 id="2-制作正样本的vec文件"><a href="#2-制作正样本的vec文件" class="headerlink" title="2. 制作正样本的vec文件"></a>2. 制作正样本的vec文件</h4><h5 id="（1）生成正样本描述文件-（-dat-或-txt-）"><a href="#（1）生成正样本描述文件-（-dat-或-txt-）" class="headerlink" title="（1）生成正样本描述文件 （.dat 或 .txt ）"></a>（1）生成正样本描述文件 （.dat 或 .txt ）</h5><p><strong>情况一：文件不需要裁剪</strong></p><p>将第一步中生成文件用替换的方法</p><p>将<code>D:\热像仪手势识别\jzy\adaboost\ConsoleApplication2\pos_resize\pos_1.jpg</code></p><p>修改为 <code>D:\热像仪手势识别\jzy\adaboost\ConsoleApplication2\pos_resize\pos_1.jpg 1 0 0 20 20</code></p><p><strong>情况二：文件需要裁剪</strong></p><p>用 opencv_annotation 框选目标的位置，得到的文件形式和上面方法一样</p><h5 id="（2）生成-vec-文件"><a href="#（2）生成-vec-文件" class="headerlink" title="（2）生成 vec 文件"></a>（2）生成 vec 文件</h5><p>用 opencv_createsamples 生成 vec 文件</p><p><br></p><h3 id="阶段二：训练级联分类器"><a href="#阶段二：训练级联分类器" class="headerlink" title="阶段二：训练级联分类器"></a>阶段二：训练级联分类器</h3><p>用 opencv_traincascade 训练级联分类器</p><p><code>opencv_traincascade.exe -data cascade -vec pos_resize\pos.vec -bg neg\neg.dat -numPos 100 -numNeg 300 -numStages 10  -featureType LBP  -w 20 -h 20</code></p><p>注意 </p><ol><li><code>-data cascade</code> 是指需要提前创建一个文件cascade放测试结果</li><li>正样本的.vec文件，负样本的.txt 或 .dat文件 要用<strong>相对路径</strong></li></ol><p>cascade文件：</p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/traincascade3.JPG" alt=""></p><p>params：训练的参数，比如这里训练的分类器的级数是10</p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/traincascade1.JPG" alt=""></p><p>第十级的训练情况：</p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/traincascade2.JPG" alt=""></p><p><br></p><h3 id="阶段三：利用训练好的分类器进行检测"><a href="#阶段三：利用训练好的分类器进行检测" class="headerlink" title="阶段三：利用训练好的分类器进行检测"></a>阶段三：利用训练好的分类器进行检测</h3><p>PS：在使用opencv中ClassifierCascade类时，无法加载级联分类器，可能是因为 opencv3.0 版本不太稳定，将xml文件复制，使用相当路径 ，可能会好一点</p><p><br></p><p><strong>多尺度目标检测</strong></p><p><code>detectMultiScale (const Mat&amp; image, CV_OUT vector&amp; objects, double scaleFactor = 1.1, int minNeighbors = 3, int flags = 0, Size minSize = Size(), Size maxSize = Size())</code></p><ul><li><p>image—待检测图片，一般为<strong>灰度图像</strong>，加快检测速度</p></li><li><p>objects—检测结果的矩形框向量组，用来<strong>画出 bounding box</strong></p></li><li><p>scaleFactor—前后两次扫描中，搜索窗口的比例系数，默认为1.1，即每次搜索窗口依次扩大10%</p></li><li><p>minNeighbors—构成检测目标的相邻矩形的最小个数</p><p>​                             如果组成检测目标的小矩形的个数和小于 min_neighbors -1，就会被排除</p><p>​                             如果min_neighbors 为 0, 则函数不做任何操作就返回所有的被检候选矩形框</p></li><li><p>flags—使用默认值</p><p>​            使用CV_HAAR_DO_CANNY_PRUNING，使用Canny边缘检测来排除边缘过多或过少的区域</p></li><li><p>minSize和maxSize—限制得到的目标区域的范围。</p></li></ul><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：本来还想用Adaboost做多分类，弃了~&lt;/p&gt;
    
    </summary>
    
    
      <category term="opencv" scheme="http://yoursite.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>opencv（三）——绘图</title>
    <link href="http://yoursite.com/2018/08/14/opencv%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E7%BB%98%E5%9B%BE/"/>
    <id>http://yoursite.com/2018/08/14/opencv（三）——绘图/</id>
    <published>2018-08-14T13:15:51.000Z</published>
    <updated>2018-08-14T13:16:17.600Z</updated>
    
    <content type="html"><![CDATA[<p>PS：其实本来不想写这篇的，实在太简单了，但是当做个检索吧，以备不时之需~~</p><p><a href="https://blog.csdn.net/ubunfans/article/details/24421981" target="_blank" rel="noopener">https://blog.csdn.net/ubunfans/article/details/24421981</a></p><a id="more"></a><h3 id="Point"><a href="#Point" class="headerlink" title="Point"></a>Point</h3><h3 id="Scalar"><a href="#Scalar" class="headerlink" title="Scalar"></a>Scalar</h3><h3 id="Rectangle"><a href="#Rectangle" class="headerlink" title="Rectangle"></a>Rectangle</h3><h3 id="Line"><a href="#Line" class="headerlink" title="Line"></a>Line</h3><h3 id="Circle"><a href="#Circle" class="headerlink" title="Circle"></a>Circle</h3><h3 id="Ellipse"><a href="#Ellipse" class="headerlink" title="Ellipse"></a>Ellipse</h3><h3 id="PolyLine-多边形的绘制"><a href="#PolyLine-多边形的绘制" class="headerlink" title="PolyLine   多边形的绘制"></a>PolyLine   多边形的绘制</h3><h3 id="PutText-在窗口显示文本-但是只能显示英文，中文不支持"><a href="#PutText-在窗口显示文本-但是只能显示英文，中文不支持" class="headerlink" title="PutText     在窗口显示文本(但是只能显示英文，中文不支持)"></a>PutText     在窗口显示文本(但是<strong>只能显示英文</strong>，中文不支持)</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：其实本来不想写这篇的，实在太简单了，但是当做个检索吧，以备不时之需~~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/ubunfans/article/details/24421981&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/ubunfans/article/details/24421981&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="opencv" scheme="http://yoursite.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>opencv（二）——imgproc</title>
    <link href="http://yoursite.com/2018/08/14/opencv%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94imgproc/"/>
    <id>http://yoursite.com/2018/08/14/opencv（二）——imgproc/</id>
    <published>2018-08-14T12:49:42.000Z</published>
    <updated>2018-08-14T13:14:53.285Z</updated>
    
    <content type="html"><![CDATA[<p>PS：具体代码参考opencv /samples里的源码</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>平滑图像/模糊</li><li>腐蚀和膨胀</li><li>形态变化 ：开运算 、闭运算 、形态梯度、 顶帽 、黑帽</li><li>Hit-or-Miss 击中击不中</li><li>图像金字塔</li><li>二值化</li><li>线性滤波器</li><li>霍夫变换：着直线、找圆</li><li>重映射</li><li>仿射变换</li><li>直方图</li><li>模板匹配</li><li>轮廓查找</li><li>凸包</li><li>多边形拟合</li><li>矩</li></ol><a id="more"></a><p><br></p><h2 id="一、-平滑图像-模糊"><a href="#一、-平滑图像-模糊" class="headerlink" title="一、 平滑图像/模糊"></a>一、 平滑图像/模糊</h2><ol><li>模糊 cv :: blur                                                                            </li><li>高斯平滑 cv :: GaussianBlur                                                        </li><li>中值滤波 cv :: medianBlur                                                    </li><li>双边滤波 cv :: bilateralFilter</li></ol><p><br></p><h2 id="二、腐蚀和膨胀"><a href="#二、腐蚀和膨胀" class="headerlink" title="二、腐蚀和膨胀"></a>二、腐蚀和膨胀</h2><ol><li>腐蚀 cv::erode  输出像素的值是原图被掩膜所覆盖的所有像素中取<strong>最小像素</strong>                                                                                                                                            <img src="https://img.w3cschool.cn/attachments/image/20170901/1504236679969494.png" alt="腐蚀">        </li><li>膨胀 cv::dilate   输出像素的值是原图被掩膜所覆盖的所有像素中取<strong>最大像素</strong>                                                                                                    <img src="https://img.w3cschool.cn/attachments/image/20170901/1504236632842236.gif" alt="膨胀"></li></ol><p><br></p><h2 id="三、-形态变化"><a href="#三、-形态变化" class="headerlink" title="三、 形态变化"></a>三、 形态变化</h2><p>cv :: morphologyEx<br>开运算 、闭运算 、形态梯度、 顶帽 、黑帽</p><p><br></p><h2 id="四、-Hit-or-Miss-击中击不中"><a href="#四、-Hit-or-Miss-击中击不中" class="headerlink" title="四、 Hit-or-Miss 击中击不中"></a>四、 Hit-or-Miss 击中击不中</h2><p>cv :: morphologyEx 函数有一个参数 MORPH_HITMISS 实现击中击不中</p><p>PS：知乎上的大神说就是一个完全的<strong>模板匹配过程</strong>                                                                                                                                                        原理看这篇比较简单  <a href="https://blog.csdn.net/horseinch/article/details/50127955" target="_blank" rel="noopener">https://blog.csdn.net/horseinch/article/details/50127955</a>                                                        但是结合具体找钥匙的应用，一下子就明白啥叫击中击不中，猛推这篇博文，简直一语戳醒我~~                                            <strong>击中击不中变换是形态学中用来检测特定形状所处位置的一个基本工具</strong>                                                                                                                                                                        <a href="https://blog.csdn.net/jinshengtao/article/details/20707711" target="_blank" rel="noopener">https://blog.csdn.net/jinshengtao/article/details/20707711</a></p><p><br></p><h2 id="五、-图像金字塔"><a href="#五、-图像金字塔" class="headerlink" title="五、 图像金字塔"></a>五、 图像金字塔</h2><p>可以看浅墨大神写的 ~ ~ <a href="https://blog.csdn.net/poem_qianmo/article/details/26157633" target="_blank" rel="noopener">https://blog.csdn.net/poem_qianmo/article/details/26157633</a></p><p>图像金字塔是图像中多尺度表达的一种，是来源于同一张原始图的图像集合。                                                        越向上层级越大，图像越小，分辨率越低，金字塔<strong>底部是高分辨率图像</strong>，而<strong>顶部是低分辨率</strong>的近似。</p><h3 id="1-图像金字塔和采样"><a href="#1-图像金字塔和采样" class="headerlink" title="1. 图像金字塔和采样"></a>1. 图像金字塔和采样</h3><ul><li>高斯金字塔：用来向下采样，从低层向上(这句话一定要看下面这张图理解)</li><li>拉普拉斯金字塔： <strong>将拉普拉斯金字塔理解为高斯金字塔的逆形式</strong></li></ul><p>向上采样：pyrUp                                                                                                                                                                                        </p><p>向下采样：pyrDown                                                                    </p><p>PS：<strong>采样方向和金字塔方向相反</strong>(重要的事情不说三遍) 在这里卡了好久，<strong>金字塔的上下按照层级来，采样的上下按照尺寸来</strong>，直接上图吧，好理解~~</p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/pyramid.png" alt=""></p><p>  <strong>pryUp不是PryDown的逆操作</strong>。图像首先在每个维度上扩大为原来的两倍，新增的行（偶数行）以0填充，用指定的滤波器卷积，估计“丢失”像素的近似值。</p><p>  pryDown( )是一个会丢失信息的函数。为了恢复原来更高的分辨率的图像，要获得由降采样操作丢失的信息，这些数据就和拉普拉斯金字塔有关系。</p><h3 id="2-图像金字塔的作用"><a href="#2-图像金字塔的作用" class="headerlink" title="2. 图像金字塔的作用"></a>2. 图像金字塔的作用</h3><p>图像压缩</p><p>图像金字塔<strong>构建尺度空间</strong>，用于<strong>目标检测</strong></p><p>下面这篇博文提到了SIFT特征，没想到图像金字塔引出的尺寸空间这么有用~~</p><p><a href="https://blog.csdn.net/xiaowei_cqu/article/details/8069548" target="_blank" rel="noopener">https://blog.csdn.net/xiaowei_cqu/article/details/8069548</a></p><p><br></p><h2 id="六、阈值操作"><a href="#六、阈值操作" class="headerlink" title="六、阈值操作"></a>六、阈值操作</h2><ul><li><p>cv :: threshold</p></li><li><p>cv :: inRange</p><p>区别：两个函数都能实现二值化                                                                                                              </p><p>但是 <strong>inRange()可以同时针对多通道操作</strong>，使用起来非常方便</p><p><br></p></li></ul><h2 id="七、-线性滤波器"><a href="#七、-线性滤波器" class="headerlink" title="七、 线性滤波器"></a>七、 线性滤波器</h2><p>cv::filter2D</p><p><br></p><h2 id="八、设置边框"><a href="#八、设置边框" class="headerlink" title="八、设置边框"></a>八、设置边框</h2><p>cv::copyMakeBorder</p><p>除了字面上的添加边框外，还有一个实际用处，如果<strong>评估点位于图像的边缘，如何卷积图像</strong>？                                                                                                            大多数OpenCV功能是将给定的图像复制到另一个稍大的图像上，然后用上式自动填充边界</p><p><strong>随机数生成器RNG</strong>                                                                             uniform函数可以返回指定范围的随机数，gaussian函数返回一个高斯随机数，fill则用随机数填充矩阵                <a href="https://blog.csdn.net/zyttae/article/details/41719349" target="_blank" rel="noopener">https://blog.csdn.net/zyttae/article/details/41719349</a></p><p><br></p><h2 id="九、-霍夫变换"><a href="#九、-霍夫变换" class="headerlink" title="九、 霍夫变换"></a>九、 霍夫变换</h2><h3 id="1-Hough-Line变换-找直线"><a href="#1-Hough-Line变换-找直线" class="headerlink" title="1.Hough Line变换 找直线"></a>1.Hough Line变换 找直线</h3><p>cv::HoughLines</p><p>cv::HoughLinesP</p><h3 id="2-Hough-Circle变换-找圆-圆心和半径"><a href="#2-Hough-Circle变换-找圆-圆心和半径" class="headerlink" title="2.Hough Circle变换 找圆(圆心和半径)"></a>2.Hough Circle变换 找圆(圆心和半径)</h3><p>cv::HoughCircles</p><p><br></p><h2 id="十、重映射（Remapping）"><a href="#十、重映射（Remapping）" class="headerlink" title="十、重映射（Remapping）"></a>十、重映射（Remapping）</h2><p>cv::remap</p><p>重映射，重新映射，就是从图像中的一个位置获取像素并将它们定位在新图像中的另一位置的过程。为了完成映射过程，可能需要对非整数像素位置进行一些<strong>插值</strong>，因为在源图像和目的图像之间不一定存在一对一像素的对应关系。</p><p><a href="https://blog.csdn.net/poem_qianmo/article/details/30974513" target="_blank" rel="noopener">https://blog.csdn.net/poem_qianmo/article/details/30974513</a></p><p><br></p><h2 id="十一、仿射变换（Affine-Transformations）"><a href="#十一、仿射变换（Affine-Transformations）" class="headerlink" title="十一、仿射变换（Affine Transformations）"></a>十一、仿射变换（Affine Transformations）</h2><ol><li><p>实现仿射：                                                                                                                cv::warpAffine   可以实现平移(Translation)、缩放(Scale)、旋转(Rotation)</p></li><li><p>计算仿射矩阵的两种方法：                                                          cv::getRotationMatrix2D  根据三个系数<strong>center旋转中心 、angle旋转角度、 scale、缩放系数</strong>计算仿射矩阵                                                        </p><p>cv::getAffineTransform  根据三个点的映射计算仿射矩阵</p></li></ol><p>2 x 3的矩阵M来表示仿射变换        <img src="http://p8ge6t5tt.bkt.clouddn.com/affine.png" alt=""></p><p>再上浅墨大神的教程~~ <a href="https://blog.csdn.net/poem_qianmo/article/details/33320997" target="_blank" rel="noopener">https://blog.csdn.net/poem_qianmo/article/details/33320997</a></p><p><br></p><h2 id="十二、直方图"><a href="#十二、直方图" class="headerlink" title="十二、直方图"></a>十二、直方图</h2><h3 id="1-计算直方图"><a href="#1-计算直方图" class="headerlink" title="1.计算直方图"></a>1.计算直方图</h3><p>cv::split 将图像分割成对应的平面，将图像分解为R，G和B平面</p><p>cv::calcHist 来计算图像数组的直方图</p><p>cv::normalize 对数组进行归一化</p><h3 id="2-直方图均衡化"><a href="#2-直方图均衡化" class="headerlink" title="2.直方图均衡化"></a>2.直方图均衡化</h3><p>对图像中像素个数多的灰度级进行展宽，像素个数少的灰度进行压缩，从而提高了对比度和灰度色调的变化，使图像更加清晰)                                                                                                                                                cv::equalizeHis</p><h3 id="3-直方图比较"><a href="#3-直方图比较" class="headerlink" title="3.直方图比较"></a>3.直方图比较</h3><p>使用不同的指标来比较直方图，两个直方图相互匹配的程度，提供了四种比较方法                            cv::compareHist</p><h3 id="4-反向投影"><a href="#4-反向投影" class="headerlink" title="4.反向投影"></a>4.反向投影</h3><p><strong>反向投影图是指图像的某一位置上像素值用对应在直方图的所属于的bin上的值来代替该像素值</strong>，不想看文字，可以看下面这篇博文的数学描述                                                                                            <a href="https://blog.csdn.net/chenjiazhou12/article/details/22150421" target="_blank" rel="noopener">https://blog.csdn.net/chenjiazhou12/article/details/22150421</a>    </p><p>PS：开始觉得这个反向投影能有啥用啊，如果你和我一样，看看下面，反向投影在<strong>定位</strong>上可是很有用~~            反向投影用于在输入图像 (通常较大) 中<strong>查找特定的模板图像</strong> (通常较小) 最匹配的点或者区域最亮。                                    cv::calcBackProject </p><p><br></p><h2 id="十三、-模板匹配"><a href="#十三、-模板匹配" class="headerlink" title="十三、 模板匹配"></a>十三、 模板匹配</h2><p>通过滑动，从左到右，从上到下，在各个位置，比较模板和源图的匹配程度<br><strong>矩阵R用于存放metric</strong>，即匹配好坏程度的值 ，R中(x,y)存放对应位置的匹配度量</p><p>cv::matchTemplate() 用来搜索模板和输入图像之间的匹配</p><p>cv::minMaxLoc() 用来查找R矩阵，即匹配好坏程度中的最大值和最小值(以及位置)</p><p><br></p><h2 id="十四、轮廓查找"><a href="#十四、轮廓查找" class="headerlink" title="十四、轮廓查找"></a>十四、轮廓查找</h2><p>cv::findContours      查找轮廓 </p><p>cv::drawContours     画轮廓</p><p><br></p><h2 id="十五、凸包"><a href="#十五、凸包" class="headerlink" title="十五、凸包"></a>十五、凸包</h2><p>凸包又叫凸壳，凸包能包含点集中所有的点，如果在集合A内连接任意两个点的直线段都在A的内部，则称集合A是凸形的。字面意思，就是一个多边型，没有凹的地方。</p><p><a href="https://blog.csdn.net/keith_bb/article/details/70194073" target="_blank" rel="noopener">https://blog.csdn.net/keith_bb/article/details/70194073</a></p><p><br></p><h2 id="十六、-多边形拟合"><a href="#十六、-多边形拟合" class="headerlink" title="十六、 多边形拟合"></a>十六、 多边形拟合</h2><p>cv::approxPolyDP  对边缘轮廓进行多边形拟合                                    </p><p>对于拟合后的轮廓求包围盒</p><p><a href="http://www.cnblogs.com/mikewolf2002/p/3427079.html" target="_blank" rel="noopener">http://www.cnblogs.com/mikewolf2002/p/3427079.html</a></p><p><br></p><h2 id="十七、空间矩，中心矩，归一化中心矩，Hu矩"><a href="#十七、空间矩，中心矩，归一化中心矩，Hu矩" class="headerlink" title="十七、空间矩，中心矩，归一化中心矩，Hu矩"></a>十七、空间矩，中心矩，归一化中心矩，Hu矩</h2><p>PS：关于矩的概念，若不想深究，只看公式，可以看下面这篇~~</p><ul><li>中心矩：<strong>平移不变性</strong></li><li>归一化中心矩：<strong>平移不变性，比例不变性</strong></li><li>Hu矩：利用二阶和三阶中心矩构造<strong>七个不变矩</strong>，具有<strong>平移、缩放、旋转不变性</strong></li></ul><p><a href="https://blog.csdn.net/kuweicai/article/details/79027388" target="_blank" rel="noopener">https://blog.csdn.net/kuweicai/article/details/79027388</a></p><p>cv::moments 计算图像的中心矩                                                </p><p>cv::HuMoments  由中心矩计算Hu矩                                        </p><p>cv::contourArea 计算轮廓面积                                                </p><p>cv::arcLength  计算封闭轮廓或曲线长度</p><p><br></p><h2 id="十八、判断点在多边形内部还是外部"><a href="#十八、判断点在多边形内部还是外部" class="headerlink" title="十八、判断点在多边形内部还是外部"></a>十八、判断点在多边形内部还是外部</h2><p>cv::pointPolygonTest  返回值是图像中的该点到某轮廓的最短距离，通过返回值的正负，判断该点在这个轮廓里面还是外面</p><p><br></p><h2 id="使用形态学操作来提取水平和垂直线，加水印的方法"><a href="#使用形态学操作来提取水平和垂直线，加水印的方法" class="headerlink" title="使用形态学操作来提取水平和垂直线，加水印的方法"></a>使用形态学操作来提取水平和垂直线，加水印的方法</h2><p>(1) 形态学是一组图像处理操作，其基于预定义的也称为内核的结构元素来处理图像，两个最基本的形态操作是腐蚀和膨胀。                                                                                                获得水平线，根据结构元素<img src="https://img.w3cschool.cn/attachments/image/20170901/1504236903564726.png" alt="水平">先腐蚀得到水平线，再膨胀加粗</p><p>同理，获得竖直线，只不过结构元素需要改变<img src="https://img.w3cschool.cn/attachments/image/20170901/1504236942451433.png" alt="竖直">                                                        这种方法结构元素的大小和形状很关键，不然找直线还是用霍夫变换吧</p><p>​</p><p>(2) PS：这个程序里用到了 copyTo 加了个mask参数，查了一下，竟然是一种<strong>做水印的方法</strong>！！神奇~~                                                                                                                        src.copyTo(dst)     src.copyTo(dst, mask)                                                                                                            原理：<strong>src为水印图片，mask作为一个掩模板，mask在(i, j)其值为1，则把src.at(i, j)处的值直接赋给dst.at(i, j)                                        mask在(i, j)其值为0，dst.at(i, j)处保留其原始像素值</strong>                                                            (mask 可以由src 经过阈值化得到，mask为1的地方就是水印src需要加上去的地方，mask为0的地方，就是水印src，即原图dst不会被掩盖)                                                                                                                水印案例：可以参考下面这个博文~~                                                                                                                                                                                                                                <a href="http://www.cnblogs.com/xianglan/archive/2011/07/30/2122186.html" target="_blank" rel="noopener">http://www.cnblogs.com/xianglan/archive/2011/07/30/2122186.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：具体代码参考opencv /samples里的源码&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;平滑图像/模糊&lt;/li&gt;
&lt;li&gt;腐蚀和膨胀&lt;/li&gt;
&lt;li&gt;形态变化 ：开运算 、闭运算 、形态梯度、 顶帽 、黑帽&lt;/li&gt;
&lt;li&gt;Hit-or-Miss 击中击不中&lt;/li&gt;
&lt;li&gt;图像金字塔&lt;/li&gt;
&lt;li&gt;二值化&lt;/li&gt;
&lt;li&gt;线性滤波器&lt;/li&gt;
&lt;li&gt;霍夫变换：着直线、找圆&lt;/li&gt;
&lt;li&gt;重映射&lt;/li&gt;
&lt;li&gt;仿射变换&lt;/li&gt;
&lt;li&gt;直方图&lt;/li&gt;
&lt;li&gt;模板匹配&lt;/li&gt;
&lt;li&gt;轮廓查找&lt;/li&gt;
&lt;li&gt;凸包&lt;/li&gt;
&lt;li&gt;多边形拟合&lt;/li&gt;
&lt;li&gt;矩&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="opencv" scheme="http://yoursite.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>opencv（一）——HighGUI</title>
    <link href="http://yoursite.com/2018/08/14/opencv%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94HighGUI/"/>
    <id>http://yoursite.com/2018/08/14/opencv（一）——HighGUI/</id>
    <published>2018-08-14T12:46:25.000Z</published>
    <updated>2018-08-14T12:48:26.506Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HighGUI-模块"><a href="#HighGUI-模块" class="headerlink" title="HighGUI 模块"></a>HighGUI 模块</h2><p>PS：HighGUI 图形用户界面模块，包括图像和视频的读入显示、编码解码、图形交互界面接口</p><p>(啥意思？后来想想可能是指滑动条这种可以产生交互的函数)</p><p><strong>滑动条的使用</strong>                                                                                 1.创建窗口        namedWindow()                                                                                                                     2.创建滑动条    createTrackbar()                                                                        3.回掉函数        on_trackbar()  函数原型必须是 void XX(int,void*)  第一个为轨迹位置，第二个为用户数据，滑动条位置改变，调用回掉函数</p><p><br></p><p>PS：<strong>void* 表明该指针与一地址值有关，但不知道存储在此地址上的对象的类型</strong>                                              void*只支持有限的操作，<strong>向函数传递void<em>指针或者返回void\</em>指针，给另一个void*指针赋值</strong>                                                                 int i = 1   void *pi = &amp;i</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HighGUI-模块&quot;&gt;&lt;a href=&quot;#HighGUI-模块&quot; class=&quot;headerlink&quot; title=&quot;HighGUI 模块&quot;&gt;&lt;/a&gt;HighGUI 模块&lt;/h2&gt;&lt;p&gt;PS：HighGUI 图形用户界面模块，包括图像和视频的读入显示、编码解码、
      
    
    </summary>
    
    
      <category term="opencv" scheme="http://yoursite.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>cs231n笔记（十一）——生成式对抗网络</title>
    <link href="http://yoursite.com/2018/08/14/cs231n%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%94%9F%E6%88%90%E5%BC%8F%E5%AF%B9%E6%8A%97%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2018/08/14/cs231n笔记（十一）——生成式对抗网络/</id>
    <published>2018-08-14T05:57:10.000Z</published>
    <updated>2018-08-14T06:44:02.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li>生成式对抗网络（GAN）</li><li>条件GAN（CGAN）</li><li>变分自编码器（Variational Auto-Encoder，VAE）</li></ol><a id="more"></a><p><br></p><h1 id="生成式对抗网络（GAN）"><a href="#生成式对抗网络（GAN）" class="headerlink" title="生成式对抗网络（GAN）"></a>生成式对抗网络（GAN）</h1><h2 id="一、GAN的思想"><a href="#一、GAN的思想" class="headerlink" title="一、GAN的思想"></a>一、GAN的思想</h2><p>GAN的思想是一种二人零和博弈思想（two-player game），博弈双方的利益之和是一个常数。GAN中有两个博弈者，一个人名字是生成模型（G），另一个人名字是判别模型（D）。</p><p>二、两个网络</p><p><strong>生成网络</strong>：输入为随机数，输出为生成数据。即造样本，使得自己造样本尽可能强，判别网络没法判断是真样本还是假样本。</p><p><strong>判别网络</strong>：二分类器，来判断输入的样本是真是假。（就是输出值大于0.5还是小于0.5）</p><p><br></p><h2 id="二、图像生成模型举例说明"><a href="#二、图像生成模型举例说明" class="headerlink" title="二、图像生成模型举例说明"></a>二、图像生成模型举例说明</h2><p>图片生成模型和判别模型之间的博弈：生成模型生成一些图片—&gt; 判别模型学习区分生成的图片和真实图片—&gt;生成模型根据判别模型改进自己，生成新的图片…… </p><p>直至判别模型无法判断一张图片是生成的还是真实的而结束，此时生成模型就会成为一个完美的模型。</p><p><img src="https://static.leiphone.com/uploads/new/article/740_740/201706/59350f1a80282.jpg?imageMogr2/format/jpg/quality/90" alt="最简单易懂的GAN（生成对抗网络）教程：从理论到实践（附代码）"></p><p><br></p><h2 id="三、GAN与传统机器学习的区别"><a href="#三、GAN与传统机器学习的区别" class="headerlink" title="三、GAN与传统机器学习的区别"></a>三、GAN与传统机器学习的区别</h2><p><strong>GAN强大之处在于可以自动学习原始真实样本集的数据分布</strong></p><p>传统机器学习方法，一般都会定义一个模型让数据去学习。这些方法都在直接或者间接的告诉数据该怎么映射，只是不同的映射方法能力不一样。</p><p>假设我们知道原始数据属于高斯分布呀，只是不知道高斯分布的参数，这个时候我们定义高斯分布，然后利用数据去学习高斯分布的参数得到我们最终的模型。</p><p>再比如说定义一个分类器 SVM，然后强行让数据进行各种高维映射，最后可以变成一个简单的分布，SVM 也是给了一个模型，这个模型就是核映射（径向基函数等等），其实是核映射的参数的学习。</p><p>GAN，生成模型则是通过噪声生成一个完整的真实数据（比如人脸），然而最开始时，生成模型并不知道从随机噪声到人脸数据的分布规律</p><p><br></p><p><br></p><h1 id="条件GAN（CGAN）"><a href="#条件GAN（CGAN）" class="headerlink" title="条件GAN（CGAN）"></a>条件GAN（CGAN）</h1><p>针对 GAN <strong>不能生成具有特定属性的图片</strong>的问题，提出了CGAN</p><p>其核心在于将属性信息融入生成器和判别器中，属性可以是任何标签信息，例如图像的类别、人脸图像的面部表情等。</p><p><br></p><p><br></p><h1 id="变分自编码器"><a href="#变分自编码器" class="headerlink" title="变分自编码器"></a>变分自编码器</h1><h1 id="（Variational-Auto-Encoder，VAE）"><a href="#（Variational-Auto-Encoder，VAE）" class="headerlink" title="（Variational Auto-Encoder，VAE）"></a>（Variational Auto-Encoder，VAE）</h1><h2 id="一、自动编码器（Auto-Encoder）"><a href="#一、自动编码器（Auto-Encoder）" class="headerlink" title="一、自动编码器（Auto Encoder）"></a>一、自动编码器（Auto Encoder）</h2><p>最开始作为一种数据的压缩方法，现在主要应用有数据去噪，可视化降维，生成数据</p><p>编码器将数据分布的高级特征映射到数据的低级表征，低级表征叫作隐含向量（latent vector），解码器吸收数据的低级表征，然后输出同样数据的高级表征。X 作为编码器的输入，z 作为本隐含向量，X′作为解码器的输出。</p><p><br></p><p><strong>自动编码器与GAN相比：</strong></p><ul><li>GAN：生成图片使用的是随机高斯噪声，这意味着没法决定使用哪种随机噪声产生需要的特定图片</li><li>自动编码器：能够<strong>通过选择特定的噪声来生成想要生成的图片</strong>，相当于知道每种图片对应的噪声分布</li></ul><p><br></p><h2 id="二、变分自动编码器-Variational-Autoencoder"><a href="#二、变分自动编码器-Variational-Autoencoder" class="headerlink" title="二、变分自动编码器(Variational Autoencoder)"></a>二、变分自动编码器(Variational Autoencoder)</h2><p>变分编码器是自动编码器的升级版本，也由编码器和解码器构成</p><p><br></p><p><strong>变分自编码器与自动编码器的比较相比：</strong></p><ul><li>自动编码器：输入一张图片，然后将一张图片编码之后得到一个<strong>隐含向量</strong>，这比随机取一个随机噪声更好，因为这包含着原图片的信息，然后<strong>隐含向量解码得到与原图片对应的照片</strong>。缺点是不能任意生成图片，因为没有办法自己去构造隐藏向量，<strong>需要通过一张图片输入编码才知道隐含向量是什么</strong>。</li><li>变分自动编码器：只需要在编码过程给它增加一些限制，<strong>使生成的隐含向量能够粗略的遵循某分布</strong>，这样通过解码器就能够生成我们想要的图片，而不需要给它一张原始图片的编码。</li></ul><p><br></p><p><br></p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>将文本翻译成图像，使用自然语言的描述属性生成相应的图像。</p><p><img src="https://pic.36krcnd.com/201802/10074355/g1oyov9niu9gebz3.jpeg!1200" alt="生成对抗网络 GAN：让 AI 有创造力，机器学习十年来最激动人心的点子"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;生成式对抗网络（GAN）&lt;/li&gt;
&lt;li&gt;条件GAN（CGAN）&lt;/li&gt;
&lt;li&gt;变分自编码器（Variational Auto-Encoder，VAE）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="cs231n" scheme="http://yoursite.com/tags/cs231n/"/>
    
  </entry>
  
  <entry>
    <title>cs231n笔记（十）——反卷积与特征可视化</title>
    <link href="http://yoursite.com/2018/08/14/cs231n%E7%AC%94%E8%AE%B0%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%E2%80%94%E5%8F%8D%E5%8D%B7%E7%A7%AF%E4%B8%8E%E7%89%B9%E5%BE%81%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <id>http://yoursite.com/2018/08/14/cs231n笔记（十）——反卷积与特征可视化/</id>
    <published>2018-08-14T05:50:36.000Z</published>
    <updated>2018-08-14T05:56:26.231Z</updated>
    
    <content type="html"><![CDATA[<p>PS：纠结了一个晚上，但到底可视化的是什么 ，一开始觉得可视化的是学习到的参数，好吧，我傻了……</p><a id="more"></a><p><br></p><h2 id="一、可视化的特征"><a href="#一、可视化的特征" class="headerlink" title="一、可视化的特征"></a>一、可视化的特征</h2><p>正常卷积的过程  conv—ReLu—Pooling，而为了理解特定的 Pooling 值代表什么，先把其他Pooling 值设为0，利用 Deconvnet 把这个给定的激活值映射到初始像素层，得到的特征，即可视化想要的结果</p><p><br></p><h2 id="二、反卷积过程"><a href="#二、反卷积过程" class="headerlink" title="二、反卷积过程"></a>二、反卷积过程</h2><p>反卷积又被称为Transposed（转置）Convolution，其实卷积层的前向传播过程就是反卷积层的反向传播过程，卷积层的反向传播过程就是反卷积层的前向传播过程。</p><h3 id="1-Unpooling"><a href="#1-Unpooling" class="headerlink" title="1.Unpooling"></a>1.Unpooling</h3><p>由于pooling是不可逆的，所以unpooling只是正常pooling的一种近似</p><h3 id="2-Recitfication"><a href="#2-Recitfication" class="headerlink" title="2.Recitfication"></a>2.Recitfication</h3><p>通过ReLU函数变换unpooling特征</p><h3 id="3-Filtering"><a href="#3-Filtering" class="headerlink" title="3.Filtering"></a>3.Filtering</h3><p>利用卷积过程filter的转置（实际上就是水平和数值翻转filter）版本来计算卷积前的特征图；从而形成重构的特征。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：纠结了一个晚上，但到底可视化的是什么 ，一开始觉得可视化的是学习到的参数，好吧，我傻了……&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="cs231n" scheme="http://yoursite.com/tags/cs231n/"/>
    
  </entry>
  
  <entry>
    <title>cs231n笔记（九）——分类、检测、分割、跟踪</title>
    <link href="http://yoursite.com/2018/08/13/cs231n%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%E2%80%94%E5%88%86%E7%B1%BB%E3%80%81%E6%A3%80%E6%B5%8B%E3%80%81%E5%88%86%E5%89%B2%E3%80%81%E8%B7%9F%E8%B8%AA/"/>
    <id>http://yoursite.com/2018/08/13/cs231n笔记（九）——分类、检测、分割、跟踪/</id>
    <published>2018-08-13T09:57:35.000Z</published>
    <updated>2018-08-13T10:00:42.905Z</updated>
    
    <content type="html"><![CDATA[<p>PS：其实一直没有认真理解计算机视觉可以解决的问题，得把这些任务区分一些</p><a id="more"></a><p><br></p><ol><li><p>图像分类（Image Classification）</p><p>给定一张输入图像，判断该图像所属类别</p><p><br></p></li><li><p>目标定位（Object Localization）</p><p>在图像分类的基础上，确定目标具体在图像的什么位置，通常是以<strong>包围盒的(bounding box)</strong>形式</p><p><br></p></li><li><p>目标识别（Object recognition）</p><p><strong>只有目标和非目标两个类别</strong>，找到目标所在的矩形框</p><p>例如，人脸检测（人脸为目标、背景为非目标）、汽车检测（汽车为目标、背景为非目标） </p><p><br></p></li><li><p>目标检测（Object Detection）</p><p>检测图像中<strong>所有的目标</strong>，得到检测到的目标的矩形框，并对所有检测到的矩形框进行分类 </p><p><br></p><p><strong>多任务学习中，网络有两个输出分支：</strong></p><p>一个分支用于做图像分类，即全连接+softmax判断目标类别，和单纯图像分类区别在于这里还另外需要一个<strong>『“背景”』</strong>类</p><p>另一个分支用于判断目标位置，即完成回归任务输出四个数字标记包围盒位置，该分支输出结果<strong>只有在分类分支判断不为“背景”时才使用</strong></p><p><br></p></li><li><p>语义分割（Semantic Segmentation）</p><p>分割是目标检测更进阶的任务，目标检测只需要框出每个目标的包围盒，分割需要进一步判断图像中哪些像素属于哪个目标</p><p>对图片中的每一个像素点进行分类，相同的类别进行标注，但是<strong>同一物体的不同实例不需要单独分割</strong></p><p><br></p></li><li><p>实例分割(Instance Segmentation)</p><p>对图像中的每一个像素点进行分类，<strong>同种物体的不同实例也用不同的类标进行标注</strong></p><p><br></p></li><li><p>目标跟踪（Object Tracking）</p><p>跟踪是基于检测的,必须先定位目标,才能后续跟踪</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：其实一直没有认真理解计算机视觉可以解决的问题，得把这些任务区分一些&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="cs231n" scheme="http://yoursite.com/tags/cs231n/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式与各种板子</title>
    <link href="http://yoursite.com/2018/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%B8%8E%E5%90%84%E7%A7%8D%E6%9D%BF%E5%AD%90/"/>
    <id>http://yoursite.com/2018/08/05/嵌入式与各种板子/</id>
    <published>2018-08-05T09:19:51.000Z</published>
    <updated>2018-08-15T02:41:42.990Z</updated>
    
    <content type="html"><![CDATA[<p>PS：写完这个，我也搞不懂MCU、ARM、DSP、FPGA、SOC到底有什么区别，我真的放弃硬件了</p><a id="more"></a><h2 id="一、嵌入式"><a href="#一、嵌入式" class="headerlink" title="一、嵌入式"></a>一、嵌入式</h2><p>嵌入式：在硬件和软件上都只保留需要的部分，而将不需要的部分裁去。所以嵌入式系统一般都具有便携、低功耗、性能单一等特性。</p><p><br></p><h2 id="二、MCU、ARM、DSP、FPGA、SOC"><a href="#二、MCU、ARM、DSP、FPGA、SOC" class="headerlink" title="二、MCU、ARM、DSP、FPGA、SOC"></a>二、MCU、ARM、DSP、FPGA、SOC</h2><ul><li>MCU（单片机）</li><li><strong>ARM属于MCU</strong>，ARM其实应该叫<strong>ARM架构</strong>，ARM之所以在<strong>移动市场</strong>上得到极大的成功，其中最主要的原因便是它的低功耗</li><li>DSP（数字信号处理器）：单芯片成本较高，主要还是应用于对计算能力要求高的应用</li><li>FPGA（现场可编程逻辑阵列）：想要它有什么功能完全靠编程人员设计，所有过程都是硬件，包括VHDL和Verilog HDL程序设计也是硬件范畴</li><li>SOC（片上系统）</li></ul><p><br></p><h2 id="三、ZYNQ"><a href="#三、ZYNQ" class="headerlink" title="三、ZYNQ"></a>三、ZYNQ</h2><p>ZYNQ：Xilinx推出的行业第一个可扩展处理平台ZYNQ系列</p><p>旨在为视频监视、汽车驾驶员辅助以及工厂自动化等高端嵌入式应用提供所需的处理与计算性能水平。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：写完这个，我也搞不懂MCU、ARM、DSP、FPGA、SOC到底有什么区别，我真的放弃硬件了&lt;/p&gt;
    
    </summary>
    
    
      <category term="硬件" scheme="http://yoursite.com/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
</feed>
