<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>绿小蕤</title>
  <icon>https://www.gravatar.com/avatar/e4d7a8bd1cb84fb3b4123916b4ea2f6b</icon>
  <subtitle>好逸恶劳,贪生怕死</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-06T06:43:36.419Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>绿小蕤</name>
    <email>528036346@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>喵的简历</title>
    <link href="http://yoursite.com/2019/01/06/%E5%96%B5%E7%9A%84%E7%AE%80%E5%8E%86/"/>
    <id>http://yoursite.com/2019/01/06/喵的简历/</id>
    <published>2019-01-06T06:27:02.000Z</published>
    <updated>2019-01-06T06:43:36.419Z</updated>
    
    <content type="html"><![CDATA[<p>想做一只猫，开心时温柔，难过时睡觉</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想做一只猫，开心时温柔，难过时睡觉&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="简介" scheme="http://yoursite.com/tags/%E7%AE%80%E4%BB%8B/"/>
    
  </entry>
  
  <entry>
    <title>caffe（六）——可视化网络工具Netscope</title>
    <link href="http://yoursite.com/2019/01/04/caffe%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E5%8F%AF%E8%A7%86%E5%8C%96%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7Netscope/"/>
    <id>http://yoursite.com/2019/01/04/caffe（六）——可视化网络工具Netscope/</id>
    <published>2019-01-04T01:55:46.000Z</published>
    <updated>2019-01-04T01:59:17.944Z</updated>
    
    <content type="html"><![CDATA[<p>无疑之中发现的，caffe在线可视化网络结构工具，有一些常用的网络，也可以将网络结构文件 net.prototxt 放到editor里</p><p><a href="http://ethereon.github.io/netscope/quickstart.html" target="_blank" rel="noopener">http://ethereon.github.io/netscope/quickstart.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;无疑之中发现的，caffe在线可视化网络结构工具，有一些常用的网络，也可以将网络结构文件 net.prototxt 放到editor里&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://ethereon.github.io/netscope/quickstart.html&quot; t
      
    
    </summary>
    
    
      <category term="caffe" scheme="http://yoursite.com/tags/caffe/"/>
    
  </entry>
  
  <entry>
    <title>caffe（五）——windows下输出log日志和画出accuracy和loss曲线</title>
    <link href="http://yoursite.com/2019/01/03/caffe%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94windows%E4%B8%8B%E8%BE%93%E5%87%BAlog%E6%97%A5%E5%BF%97%E5%92%8C%E7%94%BB%E5%87%BAaccuracy%E5%92%8Closs%E6%9B%B2%E7%BA%BF/"/>
    <id>http://yoursite.com/2019/01/03/caffe（五）——windows下输出log日志和画出accuracy和loss曲线/</id>
    <published>2019-01-03T03:12:19.000Z</published>
    <updated>2019-01-03T03:25:12.881Z</updated>
    
    <content type="html"><![CDATA[<p>这里注意运行的python版本，我下的caffe对应的是python2.7</p><p>参考：<a href="https://www.zhihu.com/question/49521165/answer/127675889" target="_blank" rel="noopener">https://www.zhihu.com/question/49521165/answer/127675889</a></p><a id="more"></a><p><br></p><h2 id="1-生成日志"><a href="#1-生成日志" class="headerlink" title="1.生成日志"></a>1.生成日志</h2><p><code>caffe.exe train --solver=solver.prototxt --weights=model.caffemodel &gt;train.log 2&gt;&amp;1</code></p><h3 id="2-画图"><a href="#2-画图" class="headerlink" title="2.画图"></a>2.画图</h3><p>(1)将 caffe-master\tools\extra\ 文件夹下的 parse_log.py、extract_seconds.py 、plot_training_log.py 还有 train.log 放到同一文件夹下</p><p>(2)修改 “plot_training_log.py” 文件</p><ul><li><p>get_log_parsing_script()</p></li><li><p>create_field_index()</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">field_index = &#123;train_key:&#123;&apos;Iters&apos;:0, &apos;Seconds&apos;:1, train_key + &apos; learning rate&apos;:2,</span><br><span class="line">                              train_key + &apos; loss&apos;:3&#125;,</span><br><span class="line">                   test_key:&#123;&apos;Iters&apos;:0, &apos;Seconds&apos;:1, test_key + &apos; learning rate&apos;:2,</span><br><span class="line">                   test_key + &apos; accuracy&apos;:3, test_key + &apos; loss&apos;:4&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>load_data()</li></ul><p><br></p><p>(3)<code>python parse_log.py train.log ./</code> 在当前目录下生成 .train、.test 文件</p><p>注意：之前很奇怪，不生成.train .test文件，后来发现是solver.prototxt中 display 参数的问题，应该是通过这个隔几次记录 accuracy、loss 值</p><p>(4)画图</p><p><code>python plot_training_log.py 0 accuracy.png train.log</code></p><p><code>python plot_training_log.py ６ lr.png train.log</code></p><p><code>python plot_training_log.py 8 loss.png train.log</code></p><p>数字参数对应的输出图的类型与plot_training_log.py中修改的create_field_index()有关</p><p><br></p><p>Supported chart types<br>0: Test accuracy  vs. Iters<br>1: Test accuracy  vs. Seconds<br>2: Test learning rate  vs. Iters<br>3: Test learning rate  vs. Seconds<br>4: Test loss  vs. Iters<br>5: Test loss  vs. Seconds<br>6: Train learning rate  vs. Iters<br>7: Train learning rate  vs. Seconds<br>8: Train loss  vs. Iters<br>9: Train loss  vs. Seconds</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里注意运行的python版本，我下的caffe对应的是python2.7&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://www.zhihu.com/question/49521165/answer/127675889&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/49521165/answer/127675889&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="caffe" scheme="http://yoursite.com/tags/caffe/"/>
    
  </entry>
  
  <entry>
    <title>caffe（四）——finetune</title>
    <link href="http://yoursite.com/2019/01/03/caffe%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94finetune/"/>
    <id>http://yoursite.com/2019/01/03/caffe（四）——finetune/</id>
    <published>2019-01-03T03:10:03.000Z</published>
    <updated>2019-01-03T03:15:15.266Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>training from scratch：从新训练一个网络，所有参数都被随机初始化</p></li><li><p>fine-tuning：是对某个模型，在训练好的参数的基础上，进行微调</p></li></ul><a id="more"></a><p><br></p><h2 id="一、步骤"><a href="#一、步骤" class="headerlink" title="一、步骤"></a>一、步骤</h2><p>参考：<a href="https://www.cnblogs.com/louyihang-loves-baiyan/p/5038758.html" target="_blank" rel="noopener">https://www.cnblogs.com/louyihang-loves-baiyan/p/5038758.html</a></p><h3 id="1-训练数据和测试数据"><a href="#1-训练数据和测试数据" class="headerlink" title="1.训练数据和测试数据"></a>1.训练数据和测试数据</h3><p>(1)准备训练集、测试集的txt，图像路径之后一个空格跟着类别的ID，<strong>ID必须从0开始，要连续</strong></p><p><strong>数据集要打乱，不然很可能不收敛</strong></p><p>(2)使用convert_imageset工具</p><p>-gray:是否以灰度图的方式打开图片，默认为false</p><p>-shuffle:是否随机打乱图片顺序，默认为false</p><p>-backend:需要转换成的db文件格式，可选为leveldb或lmdb,默认为lmdb</p><p>-resize_width/resize_height:改变图片的大小，默认为0，不改变</p><p>-check_size:检查所有的数据是否有相同的尺寸，默认为false,不检查</p><p>-encoded:是否将原图片编码放入最终的数据中，默认为false</p><p>-encode_type:与前一个参数对应，将图片编码为哪一个格式：‘png’,’jpg’…</p><p><br></p><h3 id="2-数据集的均值文件"><a href="#2-数据集的均值文件" class="headerlink" title="2.数据集的均值文件"></a>2.数据集的均值文件</h3><p>使用compute_image_mean工具</p><h3 id="3-修改网络最后一层"><a href="#3-修改网络最后一层" class="headerlink" title="3.修改网络最后一层"></a>3.修改网络最后一层</h3><h3 id="4-调整Solver的配置参数"><a href="#4-调整Solver的配置参数" class="headerlink" title="4.调整Solver的配置参数"></a>4.调整Solver的配置参数</h3><p>通常学习速率、步长、迭代次数都要适当减少，最后一层的学习率加快</p><p>lr_mult是学习率系数，最终学习率为 base_lr*lr_mult，如果有两个 lr_mult, 则第一个表示权值的学习率，第二个表示偏置项的学习率，一般偏置项的学习率是权值学习率的两倍</p><h3 id="5-启动训练，加载pretrained模型的参数"><a href="#5-启动训练，加载pretrained模型的参数" class="headerlink" title="5.启动训练，加载pretrained模型的参数"></a>5.启动训练，加载pretrained模型的参数</h3><p>使用caffe train工具</p><p><br></p><h2 id="二、调参技巧"><a href="#二、调参技巧" class="headerlink" title="二、调参技巧"></a>二、调参技巧</h2><p>PS：这部分持续更新，现在真的不是很会</p><p><a href="https://blog.csdn.net/u010402786/article/details/70141261" target="_blank" rel="noopener">https://blog.csdn.net/u010402786/article/details/70141261</a></p><p>增大最后一层的lr_mult，将weight和bias的学习速率加快10倍，让非微调层学习更快</p><p>将其它层的lr_mult设置为0，来完全阻止最后一层以外的所有层的微调</p><p>出现不收敛的问题，将lr设的小一点，一般从0.01开始，如果出现loss=nan就不断往小调整</p><p>可以把accuracy和loss的曲线画出来，方便设定stepsize，一般在accuracy和loss都趋于平缓的时候就可以减小lr</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;training from scratch：从新训练一个网络，所有参数都被随机初始化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;fine-tuning：是对某个模型，在训练好的参数的基础上，进行微调&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="caffe" scheme="http://yoursite.com/tags/caffe/"/>
    
  </entry>
  
  <entry>
    <title>caffe（三）——模型和数据集</title>
    <link href="http://yoursite.com/2019/01/02/caffe%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>http://yoursite.com/2019/01/02/caffe（三）——模型和数据集/</id>
    <published>2019-01-02T08:56:59.000Z</published>
    <updated>2019-01-02T08:58:31.784Z</updated>
    
    <content type="html"><![CDATA[<p>数据集和模型的下载</p><p><a href="http://dl.caffe.berkeleyvision.org" target="_blank" rel="noopener">http://dl.caffe.berkeleyvision.org</a></p><a id="more"></a><p><br></p><h2 id="Model-Zoo"><a href="#Model-Zoo" class="headerlink" title="Model Zoo"></a>Model Zoo</h2><p>训练好的模型pretrained</p><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>不是完整的数据集，而是mean.binaryproto、synset之类的文件</p><h3 id="1-ILSVRC和ImageNet数据集"><a href="#1-ILSVRC和ImageNet数据集" class="headerlink" title="1.ILSVRC和ImageNet数据集"></a>1.ILSVRC和ImageNet数据集</h3><p>ImageNet Large Scale Visual Recognition Challenge (ILSVRC) 即 ImageNet大规模视觉识别挑战赛，基于ImageNet图像数据库</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据集和模型的下载&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dl.caffe.berkeleyvision.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://dl.caffe.berkeleyvision.org&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="caffe" scheme="http://yoursite.com/tags/caffe/"/>
    
  </entry>
  
  <entry>
    <title>图神经网络</title>
    <link href="http://yoursite.com/2019/01/02/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2019/01/02/图神经网络/</id>
    <published>2019-01-02T07:29:22.000Z</published>
    <updated>2019-01-02T07:31:59.523Z</updated>
    
    <content type="html"><![CDATA[<p>今天看新闻，有关阿里达摩院发布2019年十大科技趋势，有一条，感觉很有意思。<br>原文是这样说的，单纯的深度学习已经成熟，而结合了深度学习的图神经网络将端到端学习与归纳推理相结合，有望解决深度学习无法处理的关系推理、可解释性等一系列问题。<br>开始不是很明白图神经网络是什么意思，所以稍微看了一下，做了个归纳。</p><p>新闻链接：<a href="https://mp.weixin.qq.com/s/Zt1mI-TMdJYxMKwJ4nSRUQ?client=tim&amp;ADUIN=528036346&amp;ADSESSION=1546410913&amp;ADTAG=CLIENT.QQ.5597_.0&amp;ADPUBNO=26878" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Zt1mI-TMdJYxMKwJ4nSRUQ?client=tim&amp;ADUIN=528036346&amp;ADSESSION=1546410913&amp;ADTAG=CLIENT.QQ.5597_.0&amp;ADPUBNO=26878</a></p><a id="more"></a><p><br></p><p>下面是关于图卷积神经网络的理解，参考的是下面这篇知乎:<br><a href="https://zhuanlan.zhihu.com/p/37091549" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37091549</a></p><h2 id="1-图"><a href="#1-图" class="headerlink" title="1.图"></a>1.图</h2><p>卷积神经网络研究的对象还是限制在Euclidean domains的数据，比如图片是二维矩阵，比如语音是规则的一维序列。<br>但现实生活中有很多数据并不具备规则的空间结构，称为Non Euclidean data。</p><p>图为一种数据结构，图(graph)由顶点(vertex)和边(edge)组成，边具有权重(weights)</p><p>图有两个基本的特性：</p><ul><li><p>一是每个节点都有自己的特征信息</p></li><li><p>二是图谱中的每个节点还具有结构信息，即与其它节点的连接</p></li></ul><p><br></p><h2 id="2-图卷计算法"><a href="#2-图卷计算法" class="headerlink" title="2.图卷计算法"></a>2.图卷计算法</h2><p>PS：这部分真心没有明白怎么实现卷积，我只是对图结构有了个概念</p><ul><li>发射（send）每一个节点将自身的特征信息经过变换后发送给邻居节点</li><li>接收（receive）每个节点将邻居节点的特征信息聚集起来</li><li>变换（transform）把前面的信息聚集之后做非线性变换</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天看新闻，有关阿里达摩院发布2019年十大科技趋势，有一条，感觉很有意思。&lt;br&gt;原文是这样说的，单纯的深度学习已经成熟，而结合了深度学习的图神经网络将端到端学习与归纳推理相结合，有望解决深度学习无法处理的关系推理、可解释性等一系列问题。&lt;br&gt;开始不是很明白图神经网络是什么意思，所以稍微看了一下，做了个归纳。&lt;/p&gt;
&lt;p&gt;新闻链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/Zt1mI-TMdJYxMKwJ4nSRUQ?client=tim&amp;amp;ADUIN=528036346&amp;amp;ADSESSION=1546410913&amp;amp;ADTAG=CLIENT.QQ.5597_.0&amp;amp;ADPUBNO=26878&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/Zt1mI-TMdJYxMKwJ4nSRUQ?client=tim&amp;amp;ADUIN=528036346&amp;amp;ADSESSION=1546410913&amp;amp;ADTAG=CLIENT.QQ.5597_.0&amp;amp;ADPUBNO=26878&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Advanced Technology" scheme="http://yoursite.com/tags/Advanced-Technology/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>caffe（二）——训练和测试MNIST</title>
    <link href="http://yoursite.com/2018/12/27/caffe%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E8%AE%AD%E7%BB%83%E5%92%8C%E6%B5%8B%E8%AF%95MNIST/"/>
    <id>http://yoursite.com/2018/12/27/caffe（二）——训练和测试MNIST/</id>
    <published>2018-12-27T03:08:12.000Z</published>
    <updated>2018-12-28T13:30:54.440Z</updated>
    
    <content type="html"><![CDATA[<p>下面以MNIST为例，通过caffe来训练、测试、单张图片的分类</p><p><a href="https://blog.csdn.net/jieleiping/article/details/53134174" target="_blank" rel="noopener">https://blog.csdn.net/jieleiping/article/details/53134174</a></p><font color="#f58220">可执行文件的目录：caffe-master\Build\x64\Release</font><font color="#f58220">可执行文件对应的cpp所在目录：caffe-master\tools</font>   <a id="more"></a><p><br></p><h2 id="一、样本格式"><a href="#一、样本格式" class="headerlink" title="一、样本格式"></a>一、样本格式</h2><p><a href="https://blog.csdn.net/hjimce/article/details/49248231" target="_blank" rel="noopener">https://blog.csdn.net/hjimce/article/details/49248231</a></p><p>caffe支持的训练数据格式 lmdb、h5py、levelIDB </p><ul><li>lmdb数据格式常用于单标签数据，分类问题</li><li>h5py数据格式常用于多标签数据，回归问题</li></ul><p><br></p><h2 id="二、-sh和-bat"><a href="#二、-sh和-bat" class="headerlink" title="二、.sh和.bat"></a>二、.sh和.bat</h2><p>.sh和.bat都是批处理文件，一个是Linux下的一个是Windows下的</p><p>注意：路径问题</p><p><br></p><h2 id="三、训练"><a href="#三、训练" class="headerlink" title="三、训练"></a>三、训练</h2><h3 id="1-数据集格式的转换"><a href="#1-数据集格式的转换" class="headerlink" title="(1)数据集格式的转换"></a>(1)数据集格式的转换</h3><p>新建 convert_mnist.bat，调用 convert_mnist.exe 将MNIST数据集转换为lmdb格式</p><h3 id="2-计算图片数据的均值"><a href="#2-计算图片数据的均值" class="headerlink" title="(2)计算图片数据的均值"></a>(2)计算图片数据的均值</h3><p>新建 compute_img_mean.bat，调用 compute_image_mean.exe 生成均值文件 mean.binaryproto</p><p>图片减去均值再训练，会提高训练速度和精度，其实不是很明白这个均值的作用，师兄觉得是归一化</p><p>将其加再 mean_file 位置<br><a href="https://www.cnblogs.com/denny402/p/5083300.html" target="_blank" rel="noopener">https://www.cnblogs.com/denny402/p/5083300.html</a></p><h3 id="3-训练数据集"><a href="#3-训练数据集" class="headerlink" title="(3)训练数据集"></a>(3)训练数据集</h3><p>新建 train_mnist.bat，调用 caffe.exe train 训练，使用的是 net_solver.prototxt</p><p>关于 caffe.exe</p><p>可以输入的4个参数</p><pre><code>train           train or finetune a modeltest            score a modeldevice_query    show GPU diagnostic informationtime            benchmark model execution time</code></pre><p><br></p><h3 id="四、测试"><a href="#四、测试" class="headerlink" title="四、测试"></a>四、测试</h3><p>test_mnist.bat，调用 caffe.exe test 训练数据集，使用的是模型文件 net.prototxt 和权重文件 net_iter.caffemodel</p><p>PS：刚开始不明白这几个文件的作用，报了下面这个错，就是因为把 net.prototxt 和 net_solver.prototxt 的使用混淆了</p><p>message type caffe.netparameter has no field named net</p><p>解决方法：<a href="https://github.com/alexgkendall/caffe-segnet/issues/16" target="_blank" rel="noopener">https://github.com/alexgkendall/caffe-segnet/issues/16</a></p><p><font color="#f58220">注意：</font>  </p><ul><li>net.prototxt                      对应网络的结构  </li><li>net_solver.prototxt               如何训练网络</li></ul><p>注意prototxt文件中的路径与.bat文件放置的位置有关</p><p><br></p><h3 id="五、对单张图片做分类"><a href="#五、对单张图片做分类" class="headerlink" title="五、对单张图片做分类"></a>五、对单张图片做分类</h3><h4 id="1-标签文件"><a href="#1-标签文件" class="headerlink" title="(1)标签文件"></a>(1)标签文件</h4><p>新建标签文件 synset_words.txt，与分类结果相对应</p><h4 id="2-分类"><a href="#2-分类" class="headerlink" title="(2)分类"></a>(2)分类</h4><p>需要用到5个文件<br>net.prototxt<br>net_iter.caffemodel<br>mean.binaryproto<br>synset_words.txt<br>picture.bmp</p><h5 id="使用可执行文件"><a href="#使用可执行文件" class="headerlink" title="使用可执行文件"></a><1>使用可执行文件</1></h5><p>新建 classify_img.bat，调用 classification.exe 对自己的图片做分类</p><h5 id="调用C-接口"><a href="#调用C-接口" class="headerlink" title="调用C++接口"></a><2>调用C++接口</2></h5><p>调用 caffe-master\examples\classification 接口，可能会出现下面的错误</p><h5 id="1）"><a href="#1）" class="headerlink" title="1）"></a>1）</h5><p>error C2220: 警告被视为错误 - 没有生成“object”文件</p><p>将“警告视为错误”的选项改为“否”</p><p><a href="https://blog.csdn.net/bagboy_taobao_com/article/details/5613625" target="_blank" rel="noopener">https://blog.csdn.net/bagboy_taobao_com/article/details/5613625</a></p><h5 id="2）"><a href="#2）" class="headerlink" title="2）"></a>2）</h5><p>F0519 14:54:12.494139 14504 layer_factory.hpp:77] Check failed: registry.count(type) == 1 (0 vs. 1) Unknown layer type: Input (known types: Input )</p><p>网上的解决方法是，将需要用到的layer添加到头文件中<br>但是我觉得很奇怪，官方的解决方案里其它项目是通过引用的方式，与libcaffe链接，而我现在通过静态链接的方式链接，就会报错？？？</p><p><a href="https://www.cnblogs.com/love6tao/p/5847480.html" target="_blank" rel="noopener">https://www.cnblogs.com/love6tao/p/5847480.html</a></p><p>如果静态库里的某些方法没有任何地方调用，最终这些没有被调用到的方法或变量将会被丢弃掉，不会被链接到目标程序中，这样做大大减小生成二进制文件的体积</p><p>在微软的编译器中有的对于那些没有用到的变量和函数是不生效的，caffe中的这些层模板，其实都已经注册了，只不过，没有引用没办法生效</p><p>强制链接静态库的所有符号</p><p><a href="http://www.cnblogs.com/coderzh/p/LinkAllSymbols.html" target="_blank" rel="noopener">http://www.cnblogs.com/coderzh/p/LinkAllSymbols.html</a><br><a href="https://blog.csdn.net/LG1259156776/article/details/52542386" target="_blank" rel="noopener">https://blog.csdn.net/LG1259156776/article/details/52542386</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面以MNIST为例，通过caffe来训练、测试、单张图片的分类&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/jieleiping/article/details/53134174&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/jieleiping/article/details/53134174&lt;/a&gt;&lt;/p&gt;
&lt;font color=&quot;#f58220&quot;&gt;可执行文件的目录：caffe-master\Build\x64\Release&lt;/font&gt;

&lt;font color=&quot;#f58220&quot;&gt;可执行文件对应的cpp所在目录：caffe-master\tools&lt;/font&gt;
    
    </summary>
    
    
      <category term="caffe" scheme="http://yoursite.com/tags/caffe/"/>
    
  </entry>
  
  <entry>
    <title>caffe（一）——windows下环境配置</title>
    <link href="http://yoursite.com/2018/12/27/caffe%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94windows%E4%B8%8B%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/12/27/caffe（一）——windows下环境配置/</id>
    <published>2018-12-27T03:07:05.000Z</published>
    <updated>2018-12-28T07:20:19.237Z</updated>
    
    <content type="html"><![CDATA[<p>PS：心力憔悴，是不是windows下做开发都这么不友好，师兄说Linux下配caffe只要几行命令</p><p>PS：从12.26-12.28，总算林林总总的</p><a id="more"></a><h1 id="windows下caffe配置"><a href="#windows下caffe配置" class="headerlink" title="windows下caffe配置"></a>windows下caffe配置</h1><h2 id="一、libcaffe的编译"><a href="#一、libcaffe的编译" class="headerlink" title="一、libcaffe的编译"></a>一、libcaffe的编译</h2><p>libcaffe的编译，是为了生成caffe相关的库文件、可执行文件，可以在 caffe-master\Build\x64\Release 中查看</p><p>参考：<a href="https://blog.csdn.net/what_lei/article/details/77857117" target="_blank" rel="noopener">https://blog.csdn.net/what_lei/article/details/77857117</a></p><h3 id="1-修改属性文件"><a href="#1-修改属性文件" class="headerlink" title="1.修改属性文件"></a>1.修改属性文件</h3><p>将 caffe-master\windows 下的 CommonSettings.props.example 重命名为 CommonSettings.props，并且修改相关内容</p><p>本来想支持python接口，但是提供的支持VS2013版本的caffe只支持python2.7，我之前只装了python3.5，就懒得再装一遍python2.7，本来也只想用C++的API</p><p><br></p><h3 id="2-NuGet"><a href="#2-NuGet" class="headerlink" title="2.NuGet"></a>2.NuGet</h3><p>NuGet是.NET平台的包管理工具，类似于python的pip(.NET是个平台，像Java虚拟机一样的一个平台，为支持的语言提供运行时的环境和开发环境)</p><p>NuGet可以理解为将Package从工程中 <strong>分离</strong>，帮助管理Package，真的很好用！</p><p>NuGet会自动下载第三方库，在 caffe-master 的平级目录下生成 NugetPackages，后面再说这个插件，真的是强大啊</p><p>caffe依赖库：<a href="https://blog.csdn.net/hqh45/article/details/51675104" target="_blank" rel="noopener">https://blog.csdn.net/hqh45/article/details/51675104</a></p><p><br></p><h3 id="3-无法打开输入文件“libcaffe-lib”-解决方法"><a href="#3-无法打开输入文件“libcaffe-lib”-解决方法" class="headerlink" title="3.无法打开输入文件“libcaffe.lib” 解决方法"></a>3.无法打开输入文件“libcaffe.lib” 解决方法</h3><p><a href="https://blog.csdn.net/liyunlong111/article/details/70435143" target="_blank" rel="noopener">https://blog.csdn.net/liyunlong111/article/details/70435143</a></p><p><br></p><h2 id="二、caffe环境配置"><a href="#二、caffe环境配置" class="headerlink" title="二、caffe环境配置"></a>二、caffe环境配置</h2><p>自己新建一个解决方案，然后调用 libcaffe.lib，而不是在Caffe.sln解决方案里新建一个项目使用 开始以为新建项目的配置属性只要和 CommonSettings.props 一样就可以了，但是很奇怪的是，在这个属性文件里面没有关于 NugetPackages 第三方包相关路径的引用，这个地方卡了很久，后来看到 Caffe 的解决方案的每个项目下面都有 packages.config，这部分是和 NuGet </p><h3 id="方法一：CommonSettings-props-添加-NugetPackages-中的第三方库和与caffe相关的库"><a href="#方法一：CommonSettings-props-添加-NugetPackages-中的第三方库和与caffe相关的库" class="headerlink" title="方法一：CommonSettings.props 添加 NugetPackages 中的第三方库和与caffe相关的库"></a>方法一：CommonSettings.props 添加 NugetPackages 中的第三方库和与caffe相关的库</h3><p>算是最简单粗暴的方法，直接添加需要的头文件和库，我是参考了下面这个博主的，如果真的自己一个个去找，头文件和库文件，我怕是要疯了吧</p><p><a href="http://abumaster.com/2017/04/18/Caffe%E7%9A%84C-%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/" target="_blank" rel="noopener">http://abumaster.com/2017/04/18/Caffe%E7%9A%84C-%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/</a></p><h3 id="方法二：NuGet添加本地已下载的包，将其安装到现有的解决方案里"><a href="#方法二：NuGet添加本地已下载的包，将其安装到现有的解决方案里" class="headerlink" title="方法二：NuGet添加本地已下载的包，将其安装到现有的解决方案里"></a>方法二：NuGet添加本地已下载的包，将其安装到现有的解决方案里</h3><h4 id="1-引入第三方包"><a href="#1-引入第三方包" class="headerlink" title="1.引入第三方包"></a>1.引入第三方包</h4><p>工具——库程序包管理器——管理解决方案的NuGet程序包——设置(添加之前下载的 NugetPackages的路径)——安装所有的包</p><p>包引入后，会生成 packages.config 文件</p><h4 id="2-引入caffe相关的库"><a href="#2-引入caffe相关的库" class="headerlink" title="2.引入caffe相关的库"></a>2.引入caffe相关的库</h4><p>将之前windows下的 CommonSettings.props </p><p>(1)头文件目录<br>caffe-master\include<br>caffe-master\include\caffe\proto</p><p>(2)附加库目录<br>caffe-master\Build\x64\Release</p><p>(3)附加依赖项<br>libcaffe.lib</p><h4 id="3-解决了两天的报错"><a href="#3-解决了两天的报错" class="headerlink" title="3.解决了两天的报错"></a>3.解决了两天的报错</h4><p>这个地方卡了一天多，刚开始想不明白有关的报错是，没有将hdf5相关的库链接，但是我明明用NuGet将 NugetPackages\hdf5-v120-complete.1.8.15.2 安装进了解决方案    </p><p>解决方法一：又是简单粗暴的方法，将 hdf5-v120-complete.1.8.15.2 的头文件和库通过配置文件里引入，但是想不明白明明用NuGet安装了会报错，后面发现是NuGet的问题</p><p>解决方法二：这个真的是学到了，以前都不知道有这种操作，感叹一下NuGet功能强大</p><p>项目右键——生成依赖项——生成自定义——查找现有生成自定义项文件</p><p>然后发现没有hdf5这个选项，将自定义项文件 在NugetPackages\hdf5-v120-complete.1.8.15.2\build\native\hdf5-v120.targets 导入，激动人心的时刻到了，哈哈哈，再也不需要自己手动include，学到了学到了</p><p>而且还有一点就是，相应的dll在生成的时候，会自动导入可执行文件相应的目录下，后面发现，这也是targets里配置的</p><p>具体过程参考下面这篇博文：<a href="https://blog.csdn.net/junparadox/article/details/51086374" target="_blank" rel="noopener">https://blog.csdn.net/junparadox/article/details/51086374</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：心力憔悴，是不是windows下做开发都这么不友好，师兄说Linux下配caffe只要几行命令&lt;/p&gt;
&lt;p&gt;PS：从12.26-12.28，总算林林总总的&lt;/p&gt;
    
    </summary>
    
    
      <category term="caffe" scheme="http://yoursite.com/tags/caffe/"/>
    
  </entry>
  
  <entry>
    <title>Christmas Gift——pygame、pyinstaller</title>
    <link href="http://yoursite.com/2018/12/25/Christmas-Gift%E2%80%94%E2%80%94pygame%E3%80%81pyinstaller/"/>
    <id>http://yoursite.com/2018/12/25/Christmas-Gift——pygame、pyinstaller/</id>
    <published>2018-12-25T11:46:52.000Z</published>
    <updated>2019-01-05T06:46:50.761Z</updated>
    
    <content type="html"><![CDATA[<p>今天是圣诞节，然后玩了一个下午的pyinstaller，超累的，感觉还是自己太菜了，很多东西都不知道啊，还得多学习啊 ~</p><a id="more"></a><h2 id="一、pygame"><a href="#一、pygame" class="headerlink" title="一、pygame"></a>一、pygame</h2><p><a href="http://www.icode9.com/content-1-22888.html" target="_blank" rel="noopener">http://www.icode9.com/content-1-22888.html</a></p><p>PS：之前在公众号上看到使用pygame这个模块，实现下雪的效果，让我想到了飘雪花的水晶球<br>不知道圣诞节送段叔叔什么礼物，就觉得这个挺好看的，所以折腾了一下午，哈哈，虽然是个很简单的脚本，但是转换成可执行文件，真的有点费事，我还以为做不出来，只不过总算可以运行了，希望段叔叔能喜欢吧 ~</p><p>pygame是一个利用SDL库的写就的游戏库</p><p><br></p><h2 id="二、pyinstaller"><a href="#二、pyinstaller" class="headerlink" title="二、pyinstaller"></a>二、pyinstaller</h2><p>PS：每次卡住的不是代码，而是各种环境、配置，一个下午就一直卡着，一直报错啊，很奔溃啊<br>本来就是个学渣，又不想问段叔叔怎么解决各种warning，总算生成可执行文件</p><p>pyinstaller将.py文件打包为.exe </p><p>下面开始我的各种问题:</p><p>1.Warning一堆API的dll not found</p><p>然后就用了最简单粗暴的方法</p><p>将not found的dll从C:\Windows\System32\downlevel 复制到C:\Windows\System32或python的安装目录下</p><p>2.ImportError: No module named ‘setuptools._vendor’</p><p>开始用了各种方法，都不行，然后看了下面这篇博文，更新了一下setuptools的版本</p><p><a href="https://blog.csdn.net/qq_39360343/article/details/82772916" target="_blank" rel="noopener">https://blog.csdn.net/qq_39360343/article/details/82772916</a></p><p>3.还未解决的就是设置可执行文件的图标</p><p>不知道为什么在 <code>-i</code>后面加图标的路径，dist文件下就没有可执行文件生成，应该不是图片文件的大小的问题吧</p><p>最后放一下，这个超简单的圣诞节动态壁纸吧  </p><p><img src="https://github.com/Sophia0130/Blog-Album/blob/master/blog-video/video.gif?raw=true" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是圣诞节，然后玩了一个下午的pyinstaller，超累的，感觉还是自己太菜了，很多东西都不知道啊，还得多学习啊 ~&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>机器学习（五）——KNN</title>
    <link href="http://yoursite.com/2018/12/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94KNN/"/>
    <id>http://yoursite.com/2018/12/25/机器学习（五）——KNN/</id>
    <published>2018-12-25T06:32:22.000Z</published>
    <updated>2018-12-25T06:34:16.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>1.以所有已知类别的实例作为参照，选取参数K</p><p>2.计算已知实例与未知实例的距离</p><p>3.选择最近的K个实例</p><p>4.根据投票原则，将未知实例归为K个最近邻中多数的样本</p><a id="more"></a><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1.算法复杂度高，未知实例需要与所有已知实例比较</p><p>2.样本分布不均匀时，未知实例容易被归为实例数量过大的起主导作用的那一类</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法流程&quot;&gt;&lt;a href=&quot;#算法流程&quot; class=&quot;headerlink&quot; title=&quot;算法流程&quot;&gt;&lt;/a&gt;算法流程&lt;/h2&gt;&lt;p&gt;1.以所有已知类别的实例作为参照，选取参数K&lt;/p&gt;
&lt;p&gt;2.计算已知实例与未知实例的距离&lt;/p&gt;
&lt;p&gt;3.选择最近的K个实例&lt;/p&gt;
&lt;p&gt;4.根据投票原则，将未知实例归为K个最近邻中多数的样本&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习（四）——XGBoost</title>
    <link href="http://yoursite.com/2018/12/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94XGBoost/"/>
    <id>http://yoursite.com/2018/12/25/机器学习（四）——XGBoost/</id>
    <published>2018-12-25T01:09:43.000Z</published>
    <updated>2018-12-25T01:13:36.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h2><p>1.多个决策树的 <strong>集成</strong>               </p><p>2.一个树一个树向里增加，同时每加一个树，需要保证效果是提升的<br>当要增加树的时候，会将前面的树当成一个整体，构造的树，使得之前当成整体的目标函数减小</p><a id="more"></a><h2 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h2><p>两者具体的区别：<a href="https://blog.csdn.net/u013709270/article/details/72553282" target="_blank" rel="noopener">https://blog.csdn.net/u013709270/article/details/72553282</a></p><p>Bagging <strong>并行</strong>生成<br>Boosting 将弱分类器 <strong>提升</strong>为强分类器，<strong>串行</strong>生成</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;XGBoost&quot;&gt;&lt;a href=&quot;#XGBoost&quot; class=&quot;headerlink&quot; title=&quot;XGBoost&quot;&gt;&lt;/a&gt;XGBoost&lt;/h2&gt;&lt;p&gt;1.多个决策树的 &lt;strong&gt;集成&lt;/strong&gt;               &lt;/p&gt;
&lt;p&gt;2.一个树一个树向里增加，同时每加一个树，需要保证效果是提升的&lt;br&gt;当要增加树的时候，会将前面的树当成一个整体，构造的树，使得之前当成整体的目标函数减小&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习（三）——PCA</title>
    <link href="http://yoursite.com/2018/12/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94PCA/"/>
    <id>http://yoursite.com/2018/12/24/机器学习（三）——PCA/</id>
    <published>2018-12-24T09:28:20.000Z</published>
    <updated>2019-01-05T05:42:36.488Z</updated>
    
    <content type="html"><![CDATA[<p>PS：关于PCA数学推导，协方差矩阵、特征向量计算的那部分我就不放</p><a id="more"></a><h2 id="一、降维"><a href="#一、降维" class="headerlink" title="一、降维"></a>一、降维</h2><p>projection 高维到低维的 <strong>投影</strong><br>highly redundant features 可以减少多余的特征</p><p><br></p><h2 id="二、为什么需要降维"><a href="#二、为什么需要降维" class="headerlink" title="二、为什么需要降维"></a>二、为什么需要降维</h2><p>1.使用较少的计算机内存或磁盘空间（选择k，使得原数据的方差尽可能保留）<br>2.加快学习算法（选择k，使得原数据的方差尽可能保留）<br>3.可视化数据（选择k=2、3，将数据放在二维平面或三维空间展示）</p><p><br></p><h2 id="三、PCA"><a href="#三、PCA" class="headerlink" title="三、PCA"></a>三、PCA</h2><h3 id="1-PCA的理解"><a href="#1-PCA的理解" class="headerlink" title="1.PCA的理解"></a>1.PCA的理解</h3><p><strong>PCA就是找到一个低维的平面，把所有的数据都投射到该平面上时，使得投射误差 projection error 尽可能的小</strong></p><p>n维降到k维，就是在n维空间中，找一个低维空间，<strong>该低维空间可以用k个n维的向量来表示</strong>，把所有的数据都投射到该空间中，使得投射的误差 projection error 尽可能的小</p><h3 id="2-PCA需要计算"><a href="#2-PCA需要计算" class="headerlink" title="2.PCA需要计算"></a>2.PCA需要计算</h3><p>(1)用于降维的，k个n维的方向向量 U_redeuce<br>(2)数据在低维空间投影后的特征 Z</p><h3 id="3-PCA实现步骤"><a href="#3-PCA实现步骤" class="headerlink" title="3.PCA实现步骤"></a>3.PCA实现步骤</h3><p><img src="https://github.com/Sophia0130/Blog-Album/blob/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/PCA%E6%AD%A5%E9%AA%A4%E5%AE%9E%E7%8E%B0.jpg?raw=true" alt=""></p><h3 id="4-PCA数学推导"><a href="#4-PCA数学推导" class="headerlink" title="4.PCA数学推导"></a>4.PCA数学推导</h3><h3 id="5-PCA与线性回归的区别"><a href="#5-PCA与线性回归的区别" class="headerlink" title="5.PCA与线性回归的区别"></a>5.PCA与线性回归的区别</h3><p>[右图] PCA最小化的是 <strong>投射误差</strong>（projection Error），不做预测<br>[左图] 线性回归最小化的是 <strong>预测误差</strong>，即预测结果与实际标签的距离</p><p><img src="https://images2015.cnblogs.com/blog/788978/201605/788978-20160524003006303-547302950.png" alt=""></p><p><br></p><h2 id="四、主成分个数k的选择"><a href="#四、主成分个数k的选择" class="headerlink" title="四、主成分个数k的选择"></a>四、主成分个数k的选择</h2><p>PCA的目的：是减少投射的平均均方误差</p><p>PCA的ｋ选取是：投射的平均均方误差与训练集方差的比例尽可能小的情况下，选择尽可能小的k<br>（这个比例小于1%，意味着原本数据的 <strong>方差</strong>有99%都保留下来了）</p><p>选取步骤：<br>1.令k=1，然后进行主要成分分析，获得前k个特征向量 U_reduce 和计算原数据 X 投影后的数据 Z<br>2.计算投射的平均均方误差与训练集方差的比例，是否小于1%<br>（如果不满足，令k=2，如此类推，直到找到可以使得比例小于1%的最小k值）</p><p><img src="https://images2015.cnblogs.com/blog/788978/201605/788978-20160524003014225-1738231865.png" alt=""></p><p><br></p><h2 id="五、PCA不适合设防止过拟合"><a href="#五、PCA不适合设防止过拟合" class="headerlink" title="五、PCA不适合设防止过拟合"></a>五、PCA不适合设防止过拟合</h2><p>PCA并不是一个好的方法用来防止过拟合，防止过拟合，还是应该用正则化</p><p>原因：<br>1.PCA是无监督的，会 <strong>丢失与Y相关的信息</strong><br>PCA是 <strong>无监督</strong>的，只关注输入数据X之间的相关性，降低数据Ｘ的维度，而不考虑标签Y，会让与Y有关的信息被丢失<br>对于监督学习，则寻找的是X与Y之间的联系</p><p>2.PCA会 <strong>丢失方差小的特征</strong><br><strong>PCA的假设是方差越大信息量越多</strong>，但是方差小的特征并不代表表对于标签没有意义</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：关于PCA数学推导，协方差矩阵、特征向量计算的那部分我就不放&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习（二）——贝叶斯算法</title>
    <link href="http://yoursite.com/2018/12/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/12/24/机器学习（二）——贝叶斯算法/</id>
    <published>2018-12-24T09:21:17.000Z</published>
    <updated>2019-01-05T06:50:07.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正向概率、逆向概率"><a href="#正向概率、逆向概率" class="headerlink" title="正向概率、逆向概率"></a>正向概率、逆向概率</h2><p>根据表面现象，做出猜测</p><p><img src="https://github.com/Sophia0130/Blog-Album/blob/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%AD%A3%E5%90%91%E3%80%81%E9%80%86%E5%90%91%E6%A6%82%E7%8E%87.JPG?raw=true" alt=""></p><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>P(B|A) = P(A|B)*P(B) / P(A)</p><p><img src="https://raw.githubusercontent.com/Sophia0130/Blog-Album/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%8F%E7%90%86%E8%A7%A3.jpg" alt=""></p><a id="more"></a><h2 id="实例一：拼写纠正"><a href="#实例一：拼写纠正" class="headerlink" title="实例一：拼写纠正"></a>实例一：拼写纠正</h2><p>用户输入了一个不在字典的单词，猜测用户想输入的单词</p><p>P(猜测用户想输入的单词|用户实际输入的单词)</p><p>用户输入P(D)=“tha”，猜测用户想输入的可能是P(h1)=“the”、P(h2)=“than”……</p><p><br></p><h3 id="一、公式理解"><a href="#一、公式理解" class="headerlink" title="一、公式理解"></a>一、公式理解</h3><p>1.需要求出这些概率，将最大值作为预测的结果</p><p>P(h1|D)=P(猜测用户想输入的=“the”|用户实际输入的=“tha”)<br>P(h2|D)=P(猜测用户想输入的=“than”|用户实际输入的=“tha”)……</p><p>P(h|D)=P(D|h)*P(h)/P(D)</p><p>2.<strong>先验概率</strong></p><p>P(h1)=P(猜测用户想输入的=“the”)<br>P(h2)=P(猜测用户想输入的=“than”) ……<br>即“the”、“than”的词频为先验概率</p><p>3.在某个猜想下，实际的概率</p><p>P(D|h1)=P(用户实际输入的=“tha”|猜测用户想输入的=“the”)<br>P(D|h2 )=P(用户实际输入的=“tha”|猜测用户想输入的=“than”)……</p><p>把“the”写成“tha”的概率，有很多衡量指标，可能与键盘中a和e的远近有关</p><p><br></p><h3 id="二、模型比较理论"><a href="#二、模型比较理论" class="headerlink" title="二、模型比较理论"></a>二、模型比较理论</h3><p>我们希望找出P(h1|D)、P(h2|D)…….中最大的作为预测结果，P(h|D)与P(D|h)*P(h)成正比，那么P(D|h)越大、或者P(h)越大对应的预测越大，越是我们需要的模型</p><p>1.<strong>最大似然估计((maximum likelihood estimation, MLE)</strong></p><p>P(D|h)较大的模型较有优势</p><p>2.<strong>奥卡姆剃刀</strong></p><p>P(h)较大的模型较有优势，即在实际中什么情况越常见，则其优势是越大的</p><p><br></p><h2 id="实例二：垃圾邮件过滤"><a href="#实例二：垃圾邮件过滤" class="headerlink" title="实例二：垃圾邮件过滤"></a>实例二：垃圾邮件过滤</h2><p><img src="https://github.com/Sophia0130/Blog-Album/blob/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%9E%83%E5%9C%BE%E9%82%AE%E4%BB%B6.JPG?raw=true" alt=""></p><p>1.先验概率 P (h+)、P(h-)可以通过统计邮件库中垃圾邮件、正常邮件的比例来得到</p><p>2.P(D|h+)</p><p>将原始的条件概率通过以下几步化简</p><p>(1)P(D|h+)=P(d1,d2,d3…dn|h+)表示当这封邮件是垃圾邮件时，这封邮件中恰好出现D(d1,d2,d3…dn)中这N个单词的概率</p><p>(2)P(D|h+)=P(d1,d2,d3…dn|h+)=P(d1|h+)*P(d2|d1,h+)*P(d3|d1,d2,h<br>+)*…<br>对P(D|h+)条件概率可以展开为P(d1|h+)*P(d2|d1,h+)*P(d3|d1,d2,h<br>+)*…表示一封垃圾邮件第一个词为d1的概率，一封垃圾邮件第一个词为d1时第二个词为d2的概率，…</p><p>(3)<strong>朴素贝叶斯</strong><br>假设di与di-1互不影响，即 <strong>特征独立</strong><br>P(d1|h+)*P(d2|d1,h+)*P(d3|d1,d2,h<br>+)*…可以化简为P(d1|h+)*P(d2|h+)*P(d3|h<br>+)*…即只要统计垃圾邮件中d1、d2、d3的概率</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;正向概率、逆向概率&quot;&gt;&lt;a href=&quot;#正向概率、逆向概率&quot; class=&quot;headerlink&quot; title=&quot;正向概率、逆向概率&quot;&gt;&lt;/a&gt;正向概率、逆向概率&lt;/h2&gt;&lt;p&gt;根据表面现象，做出猜测&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/Sophia0130/Blog-Album/blob/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%AD%A3%E5%90%91%E3%80%81%E9%80%86%E5%90%91%E6%A6%82%E7%8E%87.JPG?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;公式&quot;&gt;&lt;a href=&quot;#公式&quot; class=&quot;headerlink&quot; title=&quot;公式&quot;&gt;&lt;/a&gt;公式&lt;/h2&gt;&lt;p&gt;P(B|A) = P(A|B)*P(B) / P(A)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Sophia0130/Blog-Album/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%85%AC%E5%BC%8F%E7%90%86%E8%A7%A3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习（一）——决策树、随机森林</title>
    <link href="http://yoursite.com/2018/12/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%86%B3%E7%AD%96%E6%A0%91%E3%80%81%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"/>
    <id>http://yoursite.com/2018/12/24/机器学习（一）——决策树、随机森林/</id>
    <published>2018-12-24T09:06:38.000Z</published>
    <updated>2019-01-05T06:49:04.044Z</updated>
    
    <content type="html"><![CDATA[<p>PS：决策树这部分我是看了B站上一个博主的教程和西瓜书，感觉这个博主就是按照西瓜书来教学，但是没有涉及太多概率的计算，所以还蛮好理解的   </p><p>根据贷款申请样本这个例子，从数学上去理解熵的意义<br><a id="more"></a></p><p>1.决策树既能解决分类问题又能解决回归问题</p><p>2.两个阶段<br>(1)训练，根据给定训练集 <strong>构造决策树</strong><br>(2)分类，根据决策树各节点的分类属性进行分类</p><p>3.决策树的结构<br><img src="https://github.com/Sophia0130/Blog-Album/blob/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%86%B3%E7%AD%96%E6%A0%91%E7%BB%93%E6%9E%84.JPG?raw=true" alt=""></p><p><br></p><h2 id="一、构建决策树的关键"><a href="#一、构建决策树的关键" class="headerlink" title="一、构建决策树的关键"></a>一、构建决策树的关键</h2><p>1.问题<br>构建决策树的关键在于如何选择 <strong>节点的划分属性</strong>来划分样本   </p><p>2.解决方法<br>选择 <font color="#f58220"><strong>最优划分属性</strong></font>，即根据该属性分类，得到的分类结果的标签尽可能一样，纯度高，分类精确度高</p><p>后面的计算基于该样本集</p><p><img src="https://github.com/Sophia0130/Blog-Album/blob/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AE%9E%E4%BE%8B.png?raw=true" alt=""></p><p><br></p><h2 id="二、熵"><a href="#二、熵" class="headerlink" title="二、熵"></a>二、熵</h2><h3 id="1-熵"><a href="#1-熵" class="headerlink" title="1.熵"></a>1.熵</h3><p>(1)自信息：事件的不确定性 ，即事件发生的概率越大，则其不确定性就越小</p><p>(2)信息熵：样本的平均信息量(即样本中包含多个事件)，即衡量样本集合的纯度，内部的混乱程度，不确定性  </p><p><img src="https://github.com/Sophia0130/Blog-Album/blob/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%86%B5.jpg?raw=true" alt=""></p><h3 id="2-决策树与熵"><a href="#2-决策树与熵" class="headerlink" title="2.决策树与熵"></a>2.决策树与熵</h3><p>构建决策树的关键在于如何选择节点的划分属性</p><p>希望该划分属性满足以下原则<br>(1)随着树深度的增加，节点的熵降低，这样分类的纯度提高<br>(2) <strong>熵降低的速度越快越好</strong>，这样就可以得到高度 <strong>最矮</strong>的决策树</p><p><br></p><h2 id="三、决策树算法"><a href="#三、决策树算法" class="headerlink" title="三、决策树算法"></a>三、决策树算法</h2><p>这三种算法都是为了提高分类结果的纯度，让分类更精确</p><h3 id="1-ID3"><a href="#1-ID3" class="headerlink" title="1.ID3"></a>1.ID3</h3><p>ID3决策树算法，使用 <font color="#f58220"><strong>信息增益</strong></font>作为最优属性的划分原则</p><p>某属性对样本划分后得到的熵，样本未经该属性划分得到的熵，两者之差为信息增益，信息增益越大，表示样本用该属性进行划分后，纯度得到提升的程度大</p><p><img src="https://github.com/Sophia0130/Blog-Album/blob/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ID3.jpg?raw=true" alt=""></p><h3 id="2-C4-5"><a href="#2-C4-5" class="headerlink" title="2.C4.5"></a>2.C4.5</h3><p>C4.5决策树算法，使用 <font color="#f58220"><strong>信息增益率</strong></font>作为最优属性的划分原则</p><p>C4.5是对ID3的改进，使用信息增益率代替信息增益</p><p>ID3是以信息增益为准则来进行节点属性的选择，该准则存在以下缺点：<br>对于某些特征，特征的属性很多，且每个属性对应的样本数很少，这样就会使得信息增益很大，但是这样的决策树不具有泛化能力</p><p><img src="https://github.com/Sophia0130/Blog-Album/blob/master/blog-img-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/C4.5.jpg?raw=true" alt=""></p><h3 id="3-CART"><a href="#3-CART" class="headerlink" title="3.CART"></a>3.CART</h3><p>CART决策树算法，使用<font color="#f58220"> <strong>基尼指数</strong></font>Gini(D)作为最优属性的划分原则</p><p>基尼指数Gini(D)反映了从数据集D中 <strong>随机抽取两个样本，其类别标记不一致的概率</strong>，因此基尼指数越小，数据集D的纯度越高</p><p><br></p><h2 id="四、剪枝处理"><a href="#四、剪枝处理" class="headerlink" title="四、剪枝处理"></a>四、剪枝处理</h2><p>若决策树高度太高，分支太多，最后可能将所有样本划分为一个，而出现 <strong>过拟合</strong>，所以要进行剪枝</p><h3 id="1-预剪枝"><a href="#1-预剪枝" class="headerlink" title="1.预剪枝"></a>1.预剪枝</h3><p>对每个节点在划分前进行估计，若不满足某些条件，则停止继续划分</p><h3 id="2-后剪枝"><a href="#2-后剪枝" class="headerlink" title="2.后剪枝"></a>2.后剪枝</h3><p>通过一个评价函数，计算某个节点剪枝前和剪枝后的评估分数，以此来确定是否有划分的必要性</p><p><br></p><h2 id="五、随机森林"><a href="#五、随机森林" class="headerlink" title="五、随机森林"></a>五、随机森林</h2><p>1.随机      </p><p>(1)<font color="#f58220"><strong>样本选择</strong></font>的随机性</p><ul><li>样本数量的随机性（可以避免取到异常点)</li><li>有放回的采样 <font color="#f58220"><strong>bootstraping</strong></font></li></ul><p>(2)font color=#f58220&gt; <strong>特征选择</strong>的随机性(可以避免取到异常特征)</p><p>2.森林</p><p>构建多个决策树做分类或回归任务 <font color="#f58220"><strong>bagging</strong></font></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：决策树这部分我是看了B站上一个博主的教程和西瓜书，感觉这个博主就是按照西瓜书来教学，但是没有涉及太多概率的计算，所以还蛮好理解的   &lt;/p&gt;
&lt;p&gt;根据贷款申请样本这个例子，从数学上去理解熵的意义&lt;br&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>编译和链接（四）——重定义</title>
    <link href="http://yoursite.com/2018/12/19/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E9%87%8D%E5%AE%9A%E4%B9%89/"/>
    <id>http://yoursite.com/2018/12/19/编译和链接（四）——重定义/</id>
    <published>2018-12-19T12:45:43.000Z</published>
    <updated>2018-12-19T12:47:07.559Z</updated>
    
    <content type="html"><![CDATA[<p>PS：整理重定义之后，我发现最大的问题是之前没有理解预处理、编译、链接，理解编译才是最关键的地方 ~<br><a id="more"></a></p><h2 id="一、头文件中声明或定义函数"><a href="#一、头文件中声明或定义函数" class="headerlink" title="一、头文件中声明或定义函数"></a>一、头文件中声明或定义函数</h2><ol><li>头文件中只声明函数，一个工程下的多个c文件，可以多次包含该头文件</li><li>头文件中定义了函数，一个工程下的多个c文件，就只能包含一次该头文件，不同c文件包含该头文件会出现重定义</li></ol><p><br></p><h2 id="二、预处理与编译"><a href="#二、预处理与编译" class="headerlink" title="二、预处理与编译"></a>二、预处理与编译</h2><p>预处理与编译：<a href="https://github.com/xuelangZF/CS_Offer/blob/master/C%2B%2B/Compiler.md" target="_blank" rel="noopener">https://github.com/xuelangZF/CS_Offer/blob/master/C%2B%2B/Compiler.md</a></p><h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1.预处理"></a>1.预处理</h3><p>预处理器是在程序源文件被编译之前根据预处理指令对程序源文件进行处理，预处理器指令以#号开头标识，末尾不包含分号<br>C/C++提供的预处理功能主要有文件包含、宏替换、条件编译等</p><p>（1）文件包含<br>当使用预处理指令#include引用头文件时，相当于将头文件中所有内容，复制到include处</p><p>（2）宏替换<br>宏替换只作代码字符序列的替换工作，不作任何语法的检查，也不作任何的中间计算<br>宏定义在源文件中必须单独另起一行，换行符是宏定义的结束标志，不需要分号等符号作分隔符<br><strong>续行</strong>是通过 \符号，然后再紧跟回车符号</p><p>（3）条件编译</p><h3 id="2-编译"><a href="#2-编译" class="headerlink" title="2.编译"></a>2.编译</h3><p><strong>编译是对源文件进行编译，而不是对头文件编译，对头文件的处理在预处理时就已完成</strong></p><p><br></p><h2 id="三、重定义与编译和链接"><a href="#三、重定义与编译和链接" class="headerlink" title="三、重定义与编译和链接"></a>三、重定义与编译和链接</h2><p>1.出现重定义的两个条件</p><ul><li><strong>函数定义</strong>放在头文件中</li><li>头文件 <strong>被多个c文件包含</strong></li></ul><p>2.重定义是对目标文件 <strong>链接</strong>时报的错误，与编译无关，只是由于编译两次函数的定义，而导致链接时重定义</p><p>3.<code>#pragma once</code> 或 <code>#ifndef...#define...#endif</code> ，由于头文件嵌套包含，防止同一个c文件里对同一个头文件二次包含、二次编译， <strong>但无法解决重定义</strong> </p><p><br></p><h2 id="四、重定义理解的例子"><a href="#四、重定义理解的例子" class="headerlink" title="四、重定义理解的例子"></a>四、重定义理解的例子</h2><h3 id="情况一：函数声明与函数定义分开，不会出现重定义问题"><a href="#情况一：函数声明与函数定义分开，不会出现重定义问题" class="headerlink" title="情况一：函数声明与函数定义分开，不会出现重定义问题"></a>情况一：函数声明与函数定义分开，不会出现重定义问题</h3><p>func()函数的定义放在func.c，声明放在func.h</p><p>main.c包含 func.h、func1.h、func2.h<br><code>#pragma once；</code>、 <code>#ifndef...#define...#endif</code> 解决重复包含 head.h 的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">================c文件================</span><br><span class="line">//main.c</span><br><span class="line">#include&quot;func1.h&quot;</span><br><span class="line">#include&quot;func2.h&quot;</span><br><span class="line">#include &quot;func.h&quot;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    func1();</span><br><span class="line">    func2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//func1.c</span><br><span class="line">#include &quot;func1.h&quot;</span><br><span class="line"></span><br><span class="line">void func1()</span><br><span class="line">&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//func2.c</span><br><span class="line">#include &quot;func2.h&quot;</span><br><span class="line"></span><br><span class="line">void func2()</span><br><span class="line">&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">================h文件================</span><br><span class="line">//func.h</span><br><span class="line">#ifndef HEAD_H_</span><br><span class="line">#define HEAD_H_</span><br><span class="line"></span><br><span class="line">void func();</span><br><span class="line"></span><br><span class="line"># endif</span><br><span class="line"></span><br><span class="line">//func1.h</span><br><span class="line">#define FUNC1_H_</span><br><span class="line">#ifdef FUNC1_H_</span><br><span class="line"></span><br><span class="line">#include &quot;func.h&quot;</span><br><span class="line"></span><br><span class="line">void func1();</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//func2.h</span><br><span class="line">#define FUNC2_H_</span><br><span class="line">#ifdef FUNC2_H_</span><br><span class="line"></span><br><span class="line">#include &quot;func.h&quot;</span><br><span class="line"></span><br><span class="line">void func2();</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><br></p><h3 id="情况二：函数函数定义放在头文件中，该头文件只在c文件中包含一次，不会出现重定义问题"><a href="#情况二：函数函数定义放在头文件中，该头文件只在c文件中包含一次，不会出现重定义问题" class="headerlink" title="情况二：函数函数定义放在头文件中，该头文件只在c文件中包含一次，不会出现重定义问题"></a>情况二：函数函数定义放在头文件中，该头文件只在c文件中包含一次，不会出现重定义问题</h3><p>func()函数的定义放在func.h</p><p>注意：func.h 只是在 func1.c 中被包含，只被编译了一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">================c文件================</span><br><span class="line">//main.c</span><br><span class="line">#include&quot;func1.h&quot;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    func1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//func1.c</span><br><span class="line">#include &quot;func1.h&quot;</span><br><span class="line">#include &quot;func.h&quot;</span><br><span class="line"></span><br><span class="line">void func1()</span><br><span class="line">&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">================h文件================</span><br><span class="line">//func.h</span><br><span class="line">#ifndef HEAD_H_</span><br><span class="line">#define HEAD_H_</span><br><span class="line"></span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># endif</span><br><span class="line"></span><br><span class="line">//func1.h</span><br><span class="line">#define FUNC1_H_</span><br><span class="line">#ifdef FUNC1_H_</span><br><span class="line"></span><br><span class="line">void func1();</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><br></p><h3 id="情况三：函数函数定义放在头文件中，该头文件在多个c文件中包含，会出现重定义问题"><a href="#情况三：函数函数定义放在头文件中，该头文件在多个c文件中包含，会出现重定义问题" class="headerlink" title="情况三：函数函数定义放在头文件中，该头文件在多个c文件中包含，会出现重定义问题"></a>情况三：函数函数定义放在头文件中，该头文件在多个c文件中包含，会出现重定义问题</h3><p>func()函数的定义放在func.h</p><p>注意：func.h 只是在 func1.h 中被包含，而不是 func1.c中被包含，但是 main.c 中包含了 func1.h，相当于也包含了 func.h</p><p>编译器编译的是c文件<br>编译main.c时由于包含 func1.h，由于 func1.h 中包含了 func.h,则编译了func()函数<br>编译func1.c时由于包含 func1.h，由于 func1.h 中包含了 func.h,则又编译了func()函数<br>编译结束后生成 main.o、func1.o，将两个目标文件链接时，由于存在两个func()函数的定义，就会报重定义的错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">================c文件================</span><br><span class="line">//main.c</span><br><span class="line">#include&quot;func1.h&quot;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    func1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//func1.c</span><br><span class="line">#include &quot;func1.h&quot;</span><br><span class="line"></span><br><span class="line">void func1()</span><br><span class="line">&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">================h文件================</span><br><span class="line">//func.h</span><br><span class="line">#ifndef HEAD_H_</span><br><span class="line">#define HEAD_H_</span><br><span class="line"></span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># endif</span><br><span class="line"></span><br><span class="line">//func1.h</span><br><span class="line">#define FUNC1_H_</span><br><span class="line">#ifdef FUNC1_H_</span><br><span class="line"></span><br><span class="line">#include &quot;func.h&quot;</span><br><span class="line"></span><br><span class="line">void func1();</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p><br></p><h2 id="五、重定义与类的内联函数"><a href="#五、重定义与类的内联函数" class="headerlink" title="五、重定义与类的内联函数"></a>五、重定义与类的内联函数</h2><p>类里面定义函数，就是默认内联，不会出现重定义的问题<br>内联函数是用代码膨胀代替函数调用，直接将函数下的代码复制在内联处，不是调用，需要找到一个函数的入口地址</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：整理重定义之后，我发现最大的问题是之前没有理解预处理、编译、链接，理解编译才是最关键的地方 ~&lt;br&gt;
    
    </summary>
    
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>编译和链接（三）——头文件与库</title>
    <link href="http://yoursite.com/2018/12/19/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8E%E5%BA%93/"/>
    <id>http://yoursite.com/2018/12/19/编译和链接（三）——头文件与库/</id>
    <published>2018-12-19T12:44:16.000Z</published>
    <updated>2018-12-19T12:44:44.718Z</updated>
    
    <content type="html"><![CDATA[<p>PS：之前觉得链接库之后一定要有头文件，是因为这个头文件提供了一个函数的入口地址，现在发现，完全理解错了</p><a id="more"></a><p>头文件和库没有什么关系<br>头文件包含在源文件中，是为了在编译时说明源文件中调用的函数存在，而真正链接时，源文件编译生成的目标文件.o与库文件链接，这才实现源文件调用库中的函数</p><p><br></p><h2 id="一、源文件调用源文件下的函数"><a href="#一、源文件调用源文件下的函数" class="headerlink" title="一、源文件调用源文件下的函数"></a>一、源文件调用源文件下的函数</h2><p>先不讨论库，先看一个c文件调用另一个c文件下定义的函数<br>main() 函数调用了 func() 函数，由于 main.c 文件中并没有定义该函数，所以需要有该函数的声明，表明存在该函数，不然编译的时候会报错，下面有两种方式声明该函数</p><h3 id="1-在头文件中声明该函数，源文件包含该头文件"><a href="#1-在头文件中声明该函数，源文件包含该头文件" class="headerlink" title="1.在头文件中声明该函数，源文件包含该头文件"></a>1.在头文件中声明该函数，源文件包含该头文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">===============c文件===============</span><br><span class="line">//main.c</span><br><span class="line">#include &quot;func.h&quot;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//func.c</span><br><span class="line"></span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">    int a=1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===============头文件===============</span><br><span class="line">//func.h</span><br><span class="line">void func();</span><br></pre></td></tr></table></figure><p><br></p><h3 id="2-在调用该函数的源文件声明该函数"><a href="#2-在调用该函数的源文件声明该函数" class="headerlink" title="2.在调用该函数的源文件声明该函数"></a>2.在调用该函数的源文件声明该函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">===============c文件===============</span><br><span class="line">//main.c</span><br><span class="line">void func();</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//func.c</span><br><span class="line"></span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">    int a=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="二、源文件调用库里的函数"><a href="#二、源文件调用库里的函数" class="headerlink" title="二、源文件调用库里的函数"></a>二、源文件调用库里的函数</h2><p>库函数可以理解为多个源文件编译后生成的目标文件的集合，其实和第一种情况一样<br>源文件包含库的头文件，相当于函数声明，即编译源文件时，表明该库函数存在，不会把报错<br>但链接的时候，还是编译后的源文件与库函数链接，实现函数的调用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：之前觉得链接库之后一定要有头文件，是因为这个头文件提供了一个函数的入口地址，现在发现，完全理解错了&lt;/p&gt;
    
    </summary>
    
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>编译和链接（二）——静态链接和动态链接</title>
    <link href="http://yoursite.com/2018/12/19/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2018/12/19/编译和链接（二）——静态链接和动态链接/</id>
    <published>2018-12-19T12:42:24.000Z</published>
    <updated>2019-01-05T05:42:30.861Z</updated>
    
    <content type="html"><![CDATA[<p>预处理（需要头文件）（.c） -&gt; 编译器将源码转换为汇编代码（.asm） -&gt; 汇编器将汇编代码转换为目标文件，即二进制文件 （.obj）-&gt; 链接器将目标文件和库链接（需要库文件）（.exe）-&gt;运行</p><p><img src="https://github.com/Sophia0130/Blog-Album/blob/master/blog-img-%E7%BC%96%E8%AF%91/%E8%BF%87%E7%A8%8B.jpg?raw=true" alt=""></p><a id="more"></a><p><br></p><h2 id="一、编译和链接"><a href="#一、编译和链接" class="headerlink" title="一、编译和链接"></a>一、编译和链接</h2><p>编译：只要有头文件中的声明就足够了，头文件只是告诉编译器，函数是如何去调用如何返回</p><p>链接：把已经编译好的.obj和现有的.lib文件进行链接，这时生成可执行文件</p><p><br></p><h2 id="二、头文件和库文件"><a href="#二、头文件和库文件" class="headerlink" title="二、头文件和库文件"></a>二、头文件和库文件</h2><p>头文件：提供声明，编译的时候需要</p><p>库文件：提供定义/实现，链接时将指定的目标文件抽取出</p><p><br></p><h2 id="三、库"><a href="#三、库" class="headerlink" title="三、库"></a>三、库</h2><h3 id="1-lib后缀的库有两种"><a href="#1-lib后缀的库有两种" class="headerlink" title="1. lib后缀的库有两种"></a>1. lib后缀的库有两种</h3><ol><li>静态链接库（.lib）：静态库是一个或者多个obj文件的打包，包含了实际执行代码</li><li>动态链接库的导入库（.lib）：属于动态链接库的附加依赖项，只包含了确保程序找到对应函数的一些基本索引信息</li></ol><p><br></p><h3 id="2-dll后缀的库"><a href="#2-dll后缀的库" class="headerlink" title="2. dll后缀的库"></a>2. dll后缀的库</h3><p>动态链接库（.dll）：是具体的实现，程序运行时动态调用</p><p><br></p><p> n</p><h2 id="四、静态链接"><a href="#四、静态链接" class="headerlink" title="四、静态链接"></a>四、静态链接</h2><h3 id="1-用到的库"><a href="#1-用到的库" class="headerlink" title="1. 用到的库"></a>1. 用到的库</h3><p>静态链接库：（.lib为后缀）是一个或者多个obj文件的打包 ，<strong>『 链接时使用』</strong></p><h3 id="2-静态链接"><a href="#2-静态链接" class="headerlink" title="2. 静态链接"></a>2. 静态链接</h3><p><strong>把.lib文件中用到的函数代码直接链接进可执行文件</strong>，程序运行的时候不再需要其它的库文件</p><h3 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h3><p>程序在运行时与其它库函数无关，用户安装时就不需要再挂动态库，移植方便</p><h3 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4. 缺点"></a>4. 缺点</h3><p>所有相关的目标文件和函数库被链接合成一个可执行文件，当多个程序都调用相同函数时，内存中就会存在这个函数的多个拷贝，浪费空间和资源</p><p><br></p><h2 id="五、动态链接"><a href="#五、动态链接" class="headerlink" title="五、动态链接"></a>五、动态链接</h2><h3 id="1-用到的库-1"><a href="#1-用到的库-1" class="headerlink" title="1. 用到的库"></a>1. 用到的库</h3><ul><li>动态链接库的导入库： （.lib为后缀）属于动态链接库的附加依赖项，一般是一些索引信息，告诉链接器调用的函数在哪个dll中，函数执行代码在dll中的什么位置，<strong>『 链接时使用』</strong></li><li>动态链接库：（.dll为后缀）具体的实现，<strong>『 程序运行时使用』</strong></li></ul><h3 id="2-动态链接"><a href="#2-动态链接" class="headerlink" title="2. 动态链接"></a>2. 动态链接</h3><p>调用的函数代码并没有被拷贝到可执行文件中，仅仅在其中加入了所调用函数的索引信息，只有当应用程序被装入内存开始运行时，在Windows的管理下，才在应用程序与相应的dll之间建立链接关系。</p><h3 id="3-优点-1"><a href="#3-优点-1" class="headerlink" title="3. 优点"></a>3. 优点</h3><p>这样当一个或多个应用程序运行时，才将程序代码和被调用的函数代码链接起来，从而节省了内存资源</p><h3 id="4-缺点-1"><a href="#4-缺点-1" class="headerlink" title="4. 缺点"></a>4. 缺点</h3><p>dll 和 lib 文件必须随应用程序一起发行，否则应用程序将会产生错误</p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;预处理（需要头文件）（.c） -&amp;gt; 编译器将源码转换为汇编代码（.asm） -&amp;gt; 汇编器将汇编代码转换为目标文件，即二进制文件 （.obj）-&amp;gt; 链接器将目标文件和库链接（需要库文件）（.exe）-&amp;gt;运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/Sophia0130/Blog-Album/blob/master/blog-img-%E7%BC%96%E8%AF%91/%E8%BF%87%E7%A8%8B.jpg?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>编译和链接（一）——预处理、编译、链接</title>
    <link href="http://yoursite.com/2018/12/19/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E9%A2%84%E5%A4%84%E7%90%86%E3%80%81%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2018/12/19/编译和链接（一）——预处理、编译、链接/</id>
    <published>2018-12-19T12:19:02.000Z</published>
    <updated>2019-01-05T05:41:49.307Z</updated>
    
    <content type="html"><![CDATA[<p>PS：这个博主连载了四篇关于编译、链接的博文，思路很清晰，推荐看原文，我只是用自己的话做了个总结</p><p><a href="https://segmentfault.com/a/1190000016433947" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016433947</a></p><p><img src="https://github.com/Sophia0130/Blog-Album/blob/master/blog-img-%E7%BC%96%E8%AF%91/%E8%BF%87%E7%A8%8B.jpg?raw=true" alt=""></p><font color="#f58220"><strong>注意：编译包括了使用编译器生成汇编代码，和使用汇编器生成目标文件两部分</strong></font><p>1.编译：将一个源文件转为目标文件<br>2.链接：将多个目标文件之间产生关联</p><a id="more"></a><h2 id="一、预处理"><a href="#一、预处理" class="headerlink" title="一、预处理"></a>一、预处理</h2><p>预处理不对源代码进行解析，主要是 <strong>文本替换</strong>，即展开的过程</p><p>1.文件包含<br>2.宏定义<br>3.条件编译</p><h2 id="一、编译与目标文件"><a href="#一、编译与目标文件" class="headerlink" title="一、编译与目标文件"></a>一、编译与目标文件</h2><h3 id="1-编译"><a href="#1-编译" class="headerlink" title="1.编译"></a>1.编译</h3><p>编译的任务就是将汇编或高级计算机语言源程序转换成目标文件，即机器可以执行的机器指令</p><p>源文件被编译后生成的目标文件可以简单的理解为两部分：</p><p>代码段：源文件中定义的所有函数翻译成机器指令，存放在目标文件的代码部分<br>数据段：源文件中定义的全局变量，存放在目标文件的数据部分<br>（注意：局部变量是函数私有的，所以被放在了代码段中，作为机器指令的操作数）</p><p>在遇到外部定义的全局变量或者函数时 <font color="#f58220"><strong>只要能在当前文件找到其声明</strong></font>，编译器就认为编译正确<br>而寻找使用变量定义的这项任务就被留给了链接器，链接器的其中一项任务就是要确定所使用的变量要有其唯一的定义<br><br></p><h3 id="2-符号表-Symbol-table"><a href="#2-符号表-Symbol-table" class="headerlink" title="2.符号表(Symbol table)"></a>2.符号表(Symbol table)</h3><p>在编译过程中每次遇到一个全局变量或者函数名就会在符号表中添加一项，最终编译器会统计出一张符号表</p><p>符号表中保存的信息有两部分：</p><ul><li>目标文件中引用的全局变量以及函数，仅仅只是声明，未定义</li><li>目标文件中定义的全局变量以及函数</li></ul><p>符号表想表达的两件事：</p><ul><li>我能提供给其它文件使用的符号</li><li>我需要其它文件提供给我使用的符号</li></ul><p>符号表被放在目标文件中<br><br></p><h3 id="3-目标文件"><a href="#3-目标文件" class="headerlink" title="3.目标文件"></a>3.目标文件</h3><p>当前代码中引用，定义在其它源文件中的变量、函数，编译无法确定其内存地址，只有在进行链接时才能够确定这类变量、函数的内存地址</p><p>因此在目标文件中对于这些变量、函数的引用，对应的机器指令可能是:<br><code>call 0x000000</code></p><p>即编译器将不能确定的地址都这设置为空(0x000000)，同时编译器还会生成一条记录，告诉链接器在进行链接时要修正这条指令中的内存地址</p><ul><li>使用外部定义的函数，这个记录就放在了目标文件的.rel.text段中</li><li>使用外部定义的全局变量，则该记录放在了目标文件的.rel.data段中</li></ul><p>即链接器需要在链接过程中根据.rel.data以及.rel.text来填好编译器留下的空白位置(0x000000)</p><p>目标文件的内容如下图：<br><img src="https://image-static.segmentfault.com/340/576/3405765965-5b9f3fc6b5f70" alt=""></p><p><br></p><h2 id="二、链接器"><a href="#二、链接器" class="headerlink" title="二、链接器"></a>二、链接器</h2><h3 id="1-符号表决"><a href="#1-符号表决" class="headerlink" title="1.符号表决"></a>1.符号表决</h3><p>根据编译后得到的目标文件中的符号表，链接器根据所有目表文件进行符号决议，即 <font color="#f58220"><strong>确保所有目标文件中的符号引用都有唯一的定义</strong></font></p><p>1.对于当前目标文件，查找其符号表，并将已定义的符号并添加到已定义符号集合D中<br>2.对于当前目标文件，查找其符号表，将每一个当前目标文件引用的符号与已定义符号集合D进行对比，如果该符号不在集合D中则将其添加到未定义符合集合U中<br>3.当所有文件都扫描完成后，如果 <strong>未定义符号集合U不为空</strong>，则说明当前输入的目标文件集合中有未定义错误，链接器报错，整个编译过程终止<br><br></p><h3 id="2-重定位"><a href="#2-重定位" class="headerlink" title="2.重定位"></a>2.重定位</h3><p>PS：以下关于重定义的分析， <font color="#f58220"><strong>仅限于静态链接</strong></font>，该情况下，代码和数据都合并到可执行文件中，因此需要确定代码和数据的最终位置</p><p>编译时，无法确定，定义在其它源文件中的变量、函数的内存地址<br>链接时，才能确定可执行文件中代码和数据运行时的内存地址</p><p>确定程序运行时地址的过程就是重定位，重定位分为两步：</p><p>1.链接时，需要对所有目标文件的数据段和代码段的内存地址进行修正，编译得到的目标文件得到的只是相对地址<br>2.链接器扫描所有的.rel.text以及.rel.data段并找到相应记录的最终内存地址，并将机器指令中的<code>0x000000</code>修正为最终内存地址</p><p>PS：最后那个博主提出了一个问题，如果运行两次可执行文件，会不会出现内存内存占用的问题，而两个程序之间产生影响</p><p>回答肯定是不会的，从 <strong>操作系统</strong>层面来解释，从<font color="#f58220"><strong>虚拟内存里面看到的内存地址是一样的</strong></font>，但是物理地址不可能一样</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：这个博主连载了四篇关于编译、链接的博文，思路很清晰，推荐看原文，我只是用自己的话做了个总结&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000016433947&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000016433947&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/Sophia0130/Blog-Album/blob/master/blog-img-%E7%BC%96%E8%AF%91/%E8%BF%87%E7%A8%8B.jpg?raw=true&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;font color=&quot;#f58220&quot;&gt;&lt;strong&gt;注意：编译包括了使用编译器生成汇编代码，和使用汇编器生成目标文件两部分&lt;/strong&gt;&lt;/font&gt;

&lt;p&gt;1.编译：将一个源文件转为目标文件&lt;br&gt;2.链接：将多个目标文件之间产生关联&lt;/p&gt;
    
    </summary>
    
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux（六）——进程调度</title>
    <link href="http://yoursite.com/2018/12/17/Linux%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    <id>http://yoursite.com/2018/12/17/Linux（六）——进程调度/</id>
    <published>2018-12-17T08:34:34.000Z</published>
    <updated>2018-12-17T08:44:52.829Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：</p><p><a href="https://blog.csdn.net/qq_32811489/article/details/70768264" target="_blank" rel="noopener">https://blog.csdn.net/qq_32811489/article/details/70768264</a></p><a id="more"></a><h2 id="linux内核的三种调度方法"><a href="#linux内核的三种调度方法" class="headerlink" title="linux内核的三种调度方法"></a>linux内核的三种调度方法</h2><p>1.SCHED_OTHER<br>分时调度策略</p><p>2.SCHED_FIFO 实时调度策略，先到先服务，一旦占用cpu则一直运行，直到有更高优先级任务到达或自己放弃 </p><p>3.SCHED_RR<br>实时调度策略，时间片轮转，当进程的时间片用完，系统将重新分配时间片，并置于就绪队列尾，保证了所有具有相同优先级的RR任务的 <strong>调度公平</strong></p><p>实时进程：得到优先调用，实时进程根据 <strong>实时优先级</strong>决定调度权值<br>分时进程：曾经使用cpu最少的进程将会得到优先调度</p><p><br></p><h2 id="既有分时调度，又有时间片轮转调度和先进先出调度"><a href="#既有分时调度，又有时间片轮转调度和先进先出调度" class="headerlink" title="既有分时调度，又有时间片轮转调度和先进先出调度"></a>既有分时调度，又有时间片轮转调度和先进先出调度</h2><p>1.当实时进程准备就绪，如果当前cpu正运行非实时进程，则 <strong>实时进程立即抢占非实时进程</strong></p><p>2.RR进程和FIFO进程都采用实时优先级做为调度的权值</p><p>3.对于FIFO，如果两个进程的优先级一样，则这两个优级一样的进程具体执行哪一个是由其在队列中的位置决定的，这样导致一些不公正性</p><p>4.对于RR，两个优先级一样的任务可以循环执行，保证了公平</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_32811489/article/details/70768264&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_32811489/article/details/70768264&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Debug、Release版本下 多线程问题</title>
    <link href="http://yoursite.com/2018/11/28/Debug%E3%80%81Release%E7%89%88%E6%9C%AC%E4%B8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/11/28/Debug、Release版本下-多线程问题/</id>
    <published>2018-11-28T09:16:44.000Z</published>
    <updated>2018-11-29T06:21:57.693Z</updated>
    
    <content type="html"><![CDATA[<p>PS：今天做项目的时候，开多线程测试，遇到了一个奇怪的问题，到现在都没有办法解释～<br><a id="more"></a>      </p><p>多线程在Debug版本下的cout部分会正常输出   </p><p>多线程在Release版本下的cout部分似乎受到了阻塞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//开了四个线程</span><br><span class="line">while(times&lt;4) &#123;&#125;;  //保证4个线程运行完进行cout</span><br><span class="line">//其它代码</span><br><span class="line">//cout部分</span><br></pre></td></tr></table></figure><p>Release版本的代码改为以下形式，while里加cout，所有cout部分就都能正常输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//开了四个线程</span><br><span class="line">while(tims&lt;4) &#123;cout&lt;&lt;&quot;&quot;;&#125;       //保证4个线程运行完进行cout</span><br><span class="line">//其它代码</span><br><span class="line">//cout部分</span><br></pre></td></tr></table></figure><p><br><br>很服气，到底cout、while、Release是什么关系</p><hr><p>更新问题：</p><p>哇，真的超级崇拜我家Uncle D，晚上他试了几次，就找到问题所在，其实是 <strong>Release优化</strong>的问题 </p><p>（1）首先，这个和cout无关，之前觉得是cout多线程缓存区刷新的问题，后来发现不论将后面的代码改为printf还是文件输出都没有反应</p><p>（2）其次，这个问题和Release优化相关，将VS项目属性里C/C++下的优化改为禁用，while后面部分就能正常执行</p><p>（3）接着，解释为什么while后面的代码不执行，因为编译器觉得当前线程中times只加1次，所以times不能加到4，while是个死循环，所以while后的代码不执行</p><p>（4）最后，解释为什么在while的循环体内使用cin、cout、printf这些输入输出流，就能跨过while，因为输入输出能够 <strong>触发中断</strong>，这个时候while循环就不会被优化掉</p><p>最后的最后，他说是我程序写的有问题，因为我将times定义为全局，在每个线程结束处进行times++，编译器会觉得times加不到4，用 for和 <code>pthread_join()</code> 等待线程结束，不用while去等待所有线程结束</p><p>怎么办，现在越来越崇拜Uncle D了，无法自拔的痴迷 ~<br>现在发展到，他在旁边报代码，我来写的地步了，这样不好，我得自己思考 ~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：今天做项目的时候，开多线程测试，遇到了一个奇怪的问题，到现在都没有办法解释～&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
