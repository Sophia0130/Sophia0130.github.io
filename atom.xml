<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>绿小蕤</title>
  <icon>https://www.gravatar.com/avatar/e4d7a8bd1cb84fb3b4123916b4ea2f6b</icon>
  <subtitle>好逸恶劳,贪生怕死</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-09T11:41:46.736Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>绿小蕤</name>
    <email>528036346@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习笔记(1)-逻辑回归初步</title>
    <link href="http://yoursite.com/2018/05/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E5%88%9D%E6%AD%A5/"/>
    <id>http://yoursite.com/2018/05/09/机器学习笔记-1-逻辑回归初步/</id>
    <published>2018-05-09T11:29:59.000Z</published>
    <updated>2018-05-09T11:41:46.736Z</updated>
    
    <content type="html"><![CDATA[<p>PS：跟着大神上手机器学习，下面这篇就是大神的博客，膜拜~~ 还有本小白白的笔记                                                                                                            <a href="https://blog.csdn.net/han_xiaoyang/article/details/49123419" target="_blank" rel="noopener">https://blog.csdn.net/han_xiaoyang/article/details/49123419</a></p><p><img src="http://p8gl5au4w.bkt.clouddn.com/10001.jpg" alt=""></p><a id="more"></a><p><img src="http://p8gl5au4w.bkt.clouddn.com/10002.jpg" alt=""></p><p><img src="http://p8gl5au4w.bkt.clouddn.com/10002.jpg" alt=""></p><p><img src="http://p8gl5au4w.bkt.clouddn.com/10003.jpg" alt=""></p><p><img src="http://p8gl5au4w.bkt.clouddn.com/10004.jpg" alt=""></p><p><img src="http://p8gl5au4w.bkt.clouddn.com/10005.jpg" alt=""></p><p><img src="http://p8gl5au4w.bkt.clouddn.com/10006.jpg" alt=""></p><p><img src="http://p8gl5au4w.bkt.clouddn.com/10007.jpg" alt=""></p><p><img src="http://p8gl5au4w.bkt.clouddn.com/10008.jpg" alt=""></p><p><img src="http://p8gl5au4w.bkt.clouddn.com/10009.jpg" alt=""></p><p><img src="http://p8gl5au4w.bkt.clouddn.com/10010.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：跟着大神上手机器学习，下面这篇就是大神的博客，膜拜~~ 还有本小白白的笔记                                                                                                            &lt;a href=&quot;https://blog.csdn.net/han_xiaoyang/article/details/49123419&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/han_xiaoyang/article/details/49123419&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p8gl5au4w.bkt.clouddn.com/10001.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>python入门编程</title>
    <link href="http://yoursite.com/2018/05/09/python%E5%85%A5%E9%97%A8%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/05/09/python入门编程/</id>
    <published>2018-05-09T09:19:06.000Z</published>
    <updated>2018-05-09T09:20:28.162Z</updated>
    
    <content type="html"><![CDATA[<p>PS：结合下面这篇博客的第一个代码，写写关于python的入门编程理解</p><p><a href="https://blog.csdn.net/han_xiaoyang/article/details/49123419" target="_blank" rel="noopener">https://blog.csdn.net/han_xiaoyang/article/details/49123419</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#data1.py</span></span><br><span class="line"><span class="comment">#用到包里的函数</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> loadtxt, where  </span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> scatter, show, legend, xlabel, ylabel  </span><br><span class="line"></span><br><span class="line"><span class="comment">#load the dataset  </span></span><br><span class="line">data = loadtxt(<span class="string">'D:/机器学习/逻辑回归/data1.txt'</span>, delimiter=<span class="string">','</span>)  </span><br><span class="line">  </span><br><span class="line">X = data[:, <span class="number">0</span>:<span class="number">2</span>]  </span><br><span class="line">y = data[:, <span class="number">2</span>]  </span><br><span class="line">  </span><br><span class="line">pos = where(y == <span class="number">1</span>)  </span><br><span class="line">neg = where(y == <span class="number">0</span>)  </span><br><span class="line">scatter(X[pos, <span class="number">0</span>], X[pos, <span class="number">1</span>], marker=<span class="string">'o'</span>, c=<span class="string">'b'</span>)  </span><br><span class="line">scatter(X[neg, <span class="number">0</span>], X[neg, <span class="number">1</span>], marker=<span class="string">'x'</span>, c=<span class="string">'r'</span>)  </span><br><span class="line">xlabel(<span class="string">'Feature1/Exam 1 score'</span>)  </span><br><span class="line">ylabel(<span class="string">'Feature2/Exam 2 score'</span>)  </span><br><span class="line">legend([<span class="string">'Fail'</span>, <span class="string">'Pass'</span>])  </span><br><span class="line">show()</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="用python-shell运行data1-py"><a href="#用python-shell运行data1-py" class="headerlink" title="用python shell运行data1.py"></a>用python shell运行data1.py</h2><p>1.打开python shell — new file 新建一个.py 文件并保存                                                                                                                                                                                                                                            2.run — run model 然后python shell 会出现相应的结果                                                                                                                                                                                                                        PS：嫌弃我讲的太敷衍可以参考这片百度知道哪~~~                                                                                                                                            <a href="https://zhidao.baidu.com/question/1958691628398602620.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/1958691628398602620.html</a></p><h2 id="使用pip工具安装包"><a href="#使用pip工具安装包" class="headerlink" title="使用pip工具安装包"></a>使用pip工具安装包</h2><p>pip是python的一个非常好用的包管理工具，可以很方便地安装和管理各种三方库                                                                                                                                具体可以参考下面这篇博客~~                                                                                                                                                                                                                                                    <a href="https://blog.csdn.net/zhangxinyu11021130/article/details/50987631" target="_blank" rel="noopener">https://blog.csdn.net/zhangxinyu11021130/article/details/50987631</a></p><p>注意事项：                                                                                                                                                                                            1.要设置系统变量                                                                                                                                                                                                                                                     2.要下载相应版本的包 我的是python3.5.2 64位</p><p><img src="http://p8ge6t5tt.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%2817%29.png" alt="data1结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PS：结合下面这篇博客的第一个代码，写写关于python的入门编程理解&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/han_xiaoyang/article/details/49123419&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/han_xiaoyang/article/details/49123419&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#data1.py&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#用到包里的函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; loadtxt, where  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; pylab &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; scatter, show, legend, xlabel, ylabel  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#load the dataset  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;data = loadtxt(&lt;span class=&quot;string&quot;&gt;&#39;D:/机器学习/逻辑回归/data1.txt&#39;&lt;/span&gt;, delimiter=&lt;span class=&quot;string&quot;&gt;&#39;,&#39;&lt;/span&gt;)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X = data[:, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y = data[:, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pos = where(y == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;neg = where(y == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scatter(X[pos, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], X[pos, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], marker=&lt;span class=&quot;string&quot;&gt;&#39;o&#39;&lt;/span&gt;, c=&lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;scatter(X[neg, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], X[neg, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;], marker=&lt;span class=&quot;string&quot;&gt;&#39;x&#39;&lt;/span&gt;, c=&lt;span class=&quot;string&quot;&gt;&#39;r&#39;&lt;/span&gt;)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;xlabel(&lt;span class=&quot;string&quot;&gt;&#39;Feature1/Exam 1 score&#39;&lt;/span&gt;)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ylabel(&lt;span class=&quot;string&quot;&gt;&#39;Feature2/Exam 2 score&#39;&lt;/span&gt;)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;legend([&lt;span class=&quot;string&quot;&gt;&#39;Fail&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Pass&#39;&lt;/span&gt;])  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;show()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>opencv tutorial_code(一)</title>
    <link href="http://yoursite.com/2018/05/09/opencv-tutorial-code-%E4%B8%80/"/>
    <id>http://yoursite.com/2018/05/09/opencv-tutorial-code-一/</id>
    <published>2018-05-09T03:40:45.000Z</published>
    <updated>2018-05-09T05:56:28.657Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/opencv/opencv/tree/3.4/samples/cpp/tutorial_code" target="_blank" rel="noopener">https://github.com/opencv/opencv/tree/3.4/samples/cpp/tutorial_code</a></p><h2 id="opencv-samples-cpp-tutorial-code"><a href="#opencv-samples-cpp-tutorial-code" class="headerlink" title="opencv/samples/cpp/tutorial_code"></a>opencv/samples/cpp/tutorial_code</h2><h3 id="1-HighGUI"><a href="#1-HighGUI" class="headerlink" title="1.HighGUI"></a>1.HighGUI</h3><p>PS：HighGUI 图形用户界面模块，包括图像和视频的读入显示、编码解码、图形交互界面接口(啥意思？后来想想可能是指滑动条这种可以产生交互的函数)</p><p>(1) AddingImagesTrackbar.cpp 说明：创建滑动条将两张图片线性叠加</p><p>(2) BasicLinearTransformsTrackbar.cpp 说明：创建两个滑动条(对比度、亮度)对图片做线性变化</p><p><strong>滑动条的使用</strong>                                                                                 1.创建窗口       namedWindow()                                                                                                                     2.创建滑动条   createTrackbar()                                                                        3.回掉函数       on_trackbar()  函数原型必须是 void XX(int,void*)  第一个为轨迹位置，第二个为用户数据        滑动条位置改变，调用回掉函数</p><p>PS：<strong>void* 表明该指针与一地址值有关，但不知道存储在此地址上的对象的类型</strong>                                              void*只支持有限的操作，<strong>向函数传递void<em>指针或者返回void\</em>指针，给另一个void*指针赋值</strong>                                                                 int i = 1   void *pi = &amp;i</p><a id="more"></a><h2 id="opencv-samples-cpp-Histograms-Matching"><a href="#opencv-samples-cpp-Histograms-Matching" class="headerlink" title="opencv/samples/cpp/Histograms_Matching"></a>opencv/samples/cpp/Histograms_Matching</h2><h3 id="2-Histograms-Matching"><a href="#2-Histograms-Matching" class="headerlink" title="2.Histograms_Matching"></a>2.Histograms_Matching</h3><p>(1) EqualizeHist_Demo.cpp                                                                                                                              说明：<strong>直方图均衡化</strong>(对图像中像素个数多的灰度级进行展宽，像素个数少的灰度进行压缩，从而提高了对比度和灰度色调的变化，使图像更加清晰)                                                                                                                                                   使用函数：equalizeHist()</p><p>(2)MatchTemplate_Demo.cpp  说明：用滑动条实现<strong>模板匹配</strong>的六种方法  使用函数：matchTemplate()                                                                可以改进：可以<strong>改变模板的大小</strong>进行匹配，找出最佳匹配尺寸和最佳匹配位置                                                                </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief Sample code to use the function MatchTemplate 用滑动条实现模板匹配的六种方法</span></span><br><span class="line"><span class="comment">* https://docs.opencv.org/3.2.0/de/da9/tutorial_template_matching.html</span></span><br><span class="line"><span class="comment">* 测试结果方法2特别不准</span></span><br><span class="line"><span class="comment">** 可以改进的地方，可以改变模板的大小进行匹配，找出最佳匹配尺寸和最佳匹配位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgcodecs.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgproc.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">img    输入的图片</span></span><br><span class="line"><span class="comment">templ  待匹配的模板</span></span><br><span class="line"><span class="comment">mask   有两种模板匹配的方法需要用到掩膜，掩膜和模板大小相同，掩膜和模板对应的值相乘</span></span><br><span class="line"><span class="comment">result R 存放metric的矩阵，即匹配好坏程度的值 R矩阵的大小：result_rows = img.rows - templ.rows + 1、result_rows = img.rows - templ.rows + 1;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">bool</span> use_mask;</span><br><span class="line">Mat img; Mat templ; Mat mask; Mat result;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* image_window = <span class="string">"Source Image"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* result_window = <span class="string">"Result window"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> match_method;  <span class="comment">//模板匹配的方法</span></span><br><span class="line"><span class="keyword">int</span> max_Trackbar = <span class="number">5</span>;  <span class="comment">//选择模板匹配的方法有6种</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatchingMethod</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Not enough parameters"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">img = imread(argv[<span class="number">1</span>], IMREAD_COLOR);  <span class="comment">//原图</span></span><br><span class="line">templ = imread(argv[<span class="number">2</span>], IMREAD_COLOR);  <span class="comment">//待匹配的模板</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc &gt; <span class="number">3</span>) </span><br><span class="line">&#123;</span><br><span class="line">use_mask = <span class="literal">true</span>;</span><br><span class="line">mask = imread(argv[<span class="number">3</span>], IMREAD_COLOR);  <span class="comment">//掩膜</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (img.empty() || templ.empty() || (use_mask &amp;&amp; mask.empty()))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Can't read one of the images"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">namedWindow(image_window, WINDOW_AUTOSIZE);</span><br><span class="line">namedWindow(result_window, WINDOW_AUTOSIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* trackbar_label = <span class="string">"Method: \n 0: SQDIFF \n 1: SQDIFF_NORMED \n 2: CCORR \n 3: CCORR_NORMED \n 4: COEFF \n 5: COEFF_NORMED"</span>;</span><br><span class="line">createTrackbar(trackbar_label, image_window, &amp;match_method, max_Trackbar, MatchingMethod);</span><br><span class="line"><span class="comment">//! [create_trackbar]</span></span><br><span class="line"></span><br><span class="line">MatchingMethod(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @function MatchingMethod 滑动条回掉函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatchingMethod</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Mat img_display;</span><br><span class="line">img.copyTo(img_display);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result_cols = img.cols - templ.cols + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> result_rows = img.rows - templ.rows + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">result.create(result_rows, result_cols, CV_32FC1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Do the Matching and Normalize匹配和归一化</span></span><br><span class="line"><span class="keyword">bool</span> method_accepts_mask = (TM_SQDIFF == match_method || match_method == TM_CCORR_NORMED); <span class="comment">//需要掩膜的匹配方法</span></span><br><span class="line"><span class="keyword">if</span> (use_mask &amp;&amp; method_accepts_mask)</span><br><span class="line">&#123;</span><br><span class="line">matchTemplate(img, templ, result, match_method, mask);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">matchTemplate(img, templ, result, match_method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">normalize(result, result, <span class="number">0</span>, <span class="number">1</span>, NORM_MINMAX, <span class="number">-1</span>, Mat()); <span class="comment">//矩阵的归一化//图片单通道值  [0-255]的unsigned char类型，将其转化到[0,1]，方便计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//localizing the best match with minMaxLoc 定位最匹配的位置</span></span><br><span class="line"><span class="keyword">double</span> minVal; <span class="keyword">double</span> maxVal; <span class="comment">//确定R 中的最大和最小值 </span></span><br><span class="line">Point minLoc; Point maxLoc; <span class="comment">//确定最大和最小值的位置</span></span><br><span class="line">Point matchLoc; <span class="comment">//最佳匹配的点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//确定结果矩阵 R 的最大值和最小值的位置</span></span><br><span class="line">minMaxLoc(result, &amp;minVal, &amp;maxVal, &amp;minLoc, &amp;maxLoc, Mat());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// For SQDIFF and SQDIFF_NORMED, the best matches are lower values. For all the other methods, the higher the better</span></span><br><span class="line"><span class="comment">// 对于匹配方法 SQDIFF 和 SQDIFF_NORMED, 越小的数值代表更高的匹配结果，而对于其他方法, 数值越大匹配越好</span></span><br><span class="line"><span class="keyword">if</span> (match_method == TM_SQDIFF || match_method == TM_SQDIFF_NORMED)</span><br><span class="line">&#123;</span><br><span class="line">matchLoc = minLoc; <span class="comment">//数值越小对应的点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">matchLoc = maxLoc; <span class="comment">//数值越大对应的点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rectangle(img_display, matchLoc, Point(matchLoc.x + templ.cols, matchLoc.y + templ.rows), Scalar::all(<span class="number">0</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>); <span class="comment">//原图显示框出来的结果</span></span><br><span class="line">rectangle(result, matchLoc, Point(matchLoc.x + templ.cols, matchLoc.y + templ.rows), Scalar::all(<span class="number">0</span>), <span class="number">2</span>, <span class="number">8</span>, <span class="number">0</span>);  <span class="comment">//R 矩阵</span></span><br><span class="line"></span><br><span class="line">imshow(image_window, img_display);</span><br><span class="line">imshow(result_window, result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void matchTemplate(InputArray image,InputArray templ,OutputArray result,int method )</span></span><br><span class="line"><span class="comment">第一个参数是源图像，第二个参数是模板图像，第三个参数是匹配的结果图像，第四个参数是用于指定比较的方法</span></span><br><span class="line"><span class="comment">TM_SQDIFF：该方法使用平方差进行匹配，因此最佳的匹配结果在结果为0处，值越大匹配结果越差</span></span><br><span class="line"><span class="comment">TM_SQDIFF_NORMED：该方法使用归一化的平方差进行匹配，最佳匹配也在结果为0处</span></span><br><span class="line"><span class="comment">TM_CCORR：相关性匹配方法，该方法使用源图像与模板图像的卷积结果进行匹配，因此，最佳匹配位置在值最大处，值越小匹配结果越差</span></span><br><span class="line"><span class="comment">TM_CCORR_NORMED：归一化的相关性匹配方法，与相关性匹配方法类似，最佳匹配位置也是在值最大处</span></span><br><span class="line"><span class="comment">TM_CCOEFF：相关性系数匹配方法，该方法使用源图像与其均值的差、模板与其均值的差二者之间的相关性进行匹配，最佳匹配结果在值等于1处，最差匹配结果在值等于-1处，值等于0直接表示二者不相关</span></span><br><span class="line"><span class="comment">TM_CCOEFF_NORMED：归一化的相关性系数匹配方法，正值表示匹配的结果较好，负值则表示匹配的效果较差，也是值越大，匹配效果也好</span></span><br><span class="line"><span class="comment">"Method: \n 0: SQDIFF \n 1: SQDIFF_NORMED \n 2: CCORR \n 3: CCORR_NORMED \n 4: COEFF \n 5: COEFF_NORMED";</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>(3)calcBackProject_Demo1.cpp 说明：计算直方图，根据直方图做出反向投影，画出直方图                                 使用函数： calcHist()    calcBackProject()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief Sample code for backproject function usage</span></span><br><span class="line"><span class="comment"> https://blog.csdn.net/qq_18343569/article/details/48028065</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgproc.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgcodecs.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">src 输入原图</span></span><br><span class="line"><span class="comment">hsv 颜色空间空间，能够非常直观的表达色彩的明暗，色调，以及鲜艳程度</span></span><br><span class="line"><span class="comment">    缺点是不能直接把颜色值传达给显示器，在转换过程中消耗系统资源</span></span><br><span class="line"><span class="comment">hue 从hsv中拆分出来的通道hue</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Mat src; Mat hsv; Mat hue;</span><br><span class="line"><span class="keyword">int</span> bins = <span class="number">25</span>; <span class="comment">//[0,255]总共256 个值, 我们可以将这个范围分割成子区域(称作 bins)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hist_and_Backproj</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">src = imread(argv[<span class="number">1</span>], IMREAD_COLOR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (src.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Usage: ./calcBackProject_Demo1 &lt;path_to_image&gt;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Transform it to HSV</span></span><br><span class="line">cvtColor(src, hsv, COLOR_BGR2HSV);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Use only the Hue value</span></span><br><span class="line">hue.create(hsv.size(), hsv.depth());</span><br><span class="line"><span class="keyword">int</span> ch[] = &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">mixChannels(&amp;hsv, <span class="number">1</span>, &amp;hue, <span class="number">1</span>, ch, <span class="number">1</span>); <span class="comment">//通道拆分，复制给输出矩阵//得到HSV图像的0通道(Hue)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create Trackbar to enter the number of bins</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* window_image = <span class="string">"Source image"</span>;</span><br><span class="line">namedWindow(window_image, WINDOW_AUTOSIZE);</span><br><span class="line">createTrackbar(<span class="string">"* Hue  bins: "</span>, window_image, &amp;bins, <span class="number">180</span>, Hist_and_Backproj);</span><br><span class="line">Hist_and_Backproj(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">imshow(window_image, src);</span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @function Hist_and_Backproj</span></span><br><span class="line"><span class="comment">* @brief Callback to Trackbar</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hist_and_Backproj</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MatND hist; <span class="comment">//Mat特指2维矩阵，MatND是多维矩阵</span></span><br><span class="line"><span class="keyword">int</span> histSize = MAX(bins, <span class="number">2</span>);  <span class="comment">//直方图竖条的个数，将[0-255]划分成的子区域个数，该个数必须大于1</span></span><br><span class="line"><span class="keyword">float</span> hue_range[] = &#123; <span class="number">0</span>, <span class="number">180</span> &#125;; <span class="comment">//需要统计的直方图的范围</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span>* ranges = &#123; hue_range &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Get the Histogram and normalize it 得到hue的直方图</span></span><br><span class="line">calcHist(&amp;hue, <span class="number">1</span>, <span class="number">0</span>, Mat(), hist, <span class="number">1</span>, &amp;histSize, &amp;ranges, <span class="literal">true</span>, <span class="literal">false</span>);<span class="comment">//计算直方图，结果放在hist</span></span><br><span class="line">normalize(hist, hist, <span class="number">0</span>, <span class="number">255</span>, NORM_MINMAX, <span class="number">-1</span>, Mat()); <span class="comment">//归一化到[0,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Get Backprojection 得到hue的反向投影</span></span><br><span class="line">MatND backproj; <span class="comment">//储存原图像hue的反向投影</span></span><br><span class="line">calcBackProject(&amp;hue, <span class="number">1</span>, <span class="number">0</span>, hist, backproj, &amp;ranges, <span class="number">1</span>, <span class="literal">true</span>); <span class="comment">//反向投影//根据hist直方图寻找符合该直方图的特征</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Draw the backproj</span></span><br><span class="line">imshow(<span class="string">"BackProj"</span>, backproj);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Draw the histogram 画直方图</span></span><br><span class="line"><span class="keyword">int</span> w = <span class="number">400</span>; <span class="keyword">int</span> h = <span class="number">400</span>; <span class="comment">//w宽 h高</span></span><br><span class="line"><span class="keyword">int</span> bin_w = cvRound((<span class="keyword">double</span>)w / histSize); <span class="comment">//每个bin的宽度</span></span><br><span class="line">Mat histImg = Mat::zeros(w, h, CV_8UC3); <span class="comment">//400*400</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bins; i++)</span><br><span class="line">&#123;</span><br><span class="line">rectangle(histImg, Point(i*bin_w, h), Point((i + <span class="number">1</span>)*bin_w, h - cvRound(hist.at&lt;<span class="keyword">float</span>&gt;(i)*h / <span class="number">255.0</span>)), Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">-1</span>);</span><br><span class="line">&#125; <span class="comment">//固定w轴上的两个点画高</span></span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"Histogram"</span>, histImg);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">mixChannels主要就是把输入的矩阵（或矩阵数组）的某些通道拆分复制给对应的输出矩阵（或矩阵数组）的某些通道中，其中的对应关系就由fromTo参数制定</span></span><br><span class="line"><span class="comment">void  mixChannels (const Mat*  src , int  nsrc , Mat*  dst , int  ndst , const int*  fromTo , size_t  npairs );</span></span><br><span class="line"><span class="comment">src–　输入矩阵，可以为一个也可以为多个，但是矩阵必须有相同的大小和深度</span></span><br><span class="line"><span class="comment">nsrcs– 输入矩阵的个数</span></span><br><span class="line"><span class="comment">dst– 输出矩阵，可以为一个也可以为多个，但是所有的矩阵必须事先分配空间（如用create），大小和深度须与输入矩阵等同</span></span><br><span class="line"><span class="comment">ndsts– 输出矩阵的个数</span></span><br><span class="line"><span class="comment">------------------------------------</span></span><br><span class="line"><span class="comment">fromTo –设置输入矩阵的通道对应输出矩阵的通道，规则如下：首先用数字标记输入矩阵的各个通道</span></span><br><span class="line"><span class="comment">第一个输入矩阵的通道标记范围为：0 ~ src[0].channels()-1，第二个输入矩阵的通道标记范围为：src[0].channels() ~ src[0].channels()+src[1].channels()-1,以此类推</span></span><br><span class="line"><span class="comment">其次输出矩阵也用同样的规则标记，第一个输出矩阵的通道标记范围为：0 ~ dst[0].channels()-1，第二个输入矩阵的通道标记范围为：dst[0].channels()~ dst[0].channels()+dst[1].channels()-1,以此类推</span></span><br><span class="line"><span class="comment">最后，数组fromTo的第一个元素即fromTo[0]应该填入输入矩阵的某个通道标记，而fromTo的第二个元素即fromTo[1]应该填入输出矩阵的某个通道标记，函数就会把输入矩阵的fromTo[0]通道里面的数据复制给输出矩阵的fromTo[1]通道，总之一个输入矩阵的通道标记后面必须跟着输出矩阵的通道标记。</span></span><br><span class="line"><span class="comment">------------------------------------</span></span><br><span class="line"><span class="comment">npairs–即参数fromTo中的有几组输入输出通道关系，其实就是参数fromTo的数组元素个数除以2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void calcHist(const Mat* arrays, int narrays, const int* channels, InputArray mask, SparseMat&amp; hist, int dims, const int* histSize, const float** ranges, bool uniform=true, bool accumulate=false )</span></span><br><span class="line"><span class="comment">arrays 输入的图像的指针，可以是多幅图像，所有的图像必须有同样的深度（CV_8U or CV_32F），同时一副图像可以有多个channels</span></span><br><span class="line"><span class="comment">narrays 输入的图像的个数</span></span><br><span class="line"><span class="comment">------------------------------------</span></span><br><span class="line"><span class="comment">channels 用来计算直方图的channes的数组</span></span><br><span class="line"><span class="comment">比如输入是2张图像，第一副图像有0，1，2共三个channels，第二幅图像只有0一个channel，那么输入就一共有4个channels</span></span><br><span class="line"><span class="comment">如果int channels[3] = &#123;3, 2, 0&#125;，那么就表示是使用第二副图像的第一个通道和第一副图像的第2和第0个通道来计算直方图</span></span><br><span class="line"><span class="comment">------------------------------------</span></span><br><span class="line"><span class="comment">mask 掩码如果mask不为空，那么它必须是一个8位（CV_8U）的数组，并且它的大小的和arrays[i]的大小相同，值为1的点将用来计算直方图。</span></span><br><span class="line"><span class="comment">hist 计算出来的直方图</span></span><br><span class="line"><span class="comment">dims 计算出来的直方图的维数</span></span><br><span class="line"><span class="comment">histSize 在每一维上直方图的个数。简单把直方图看作一个一个的竖条的话，就是每一维上竖条的个数</span></span><br><span class="line"><span class="comment">------------------------------------</span></span><br><span class="line"><span class="comment">ranges 用来进行统计的范围</span></span><br><span class="line"><span class="comment">float rang1[] = &#123;0, 20&#125;;</span></span><br><span class="line"><span class="comment">float rang2[] = &#123;30, 40&#125;;</span></span><br><span class="line"><span class="comment">const float *rangs[] = &#123;rang1, rang2&#125;;那么就是对0，20和30，40范围的值进行统计</span></span><br><span class="line"><span class="comment">------------------------------------</span></span><br><span class="line"><span class="comment">uniform 每一个竖条的宽度是否相等</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>(4) calcBackProject_Demo2.cpp  说明：calcHist函数使用了mask掩膜                                                                                                                                                                                     PS：看了一上午程序，累死了demo2实在不行看了~~</p><p>(5) compareHist_Demo.cpp  说明：来计算两个直方图相似度 使用函数：compareHist()</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/opencv/opencv/tree/3.4/samples/cpp/tutorial_code&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/opencv/opencv/tree/3.4/samples/cpp/tutorial_code&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;opencv-samples-cpp-tutorial-code&quot;&gt;&lt;a href=&quot;#opencv-samples-cpp-tutorial-code&quot; class=&quot;headerlink&quot; title=&quot;opencv/samples/cpp/tutorial_code&quot;&gt;&lt;/a&gt;opencv/samples/cpp/tutorial_code&lt;/h2&gt;&lt;h3 id=&quot;1-HighGUI&quot;&gt;&lt;a href=&quot;#1-HighGUI&quot; class=&quot;headerlink&quot; title=&quot;1.HighGUI&quot;&gt;&lt;/a&gt;1.HighGUI&lt;/h3&gt;&lt;p&gt;PS：HighGUI 图形用户界面模块，包括图像和视频的读入显示、编码解码、图形交互界面接口(啥意思？后来想想可能是指滑动条这种可以产生交互的函数)&lt;/p&gt;
&lt;p&gt;(1) AddingImagesTrackbar.cpp 说明：创建滑动条将两张图片线性叠加&lt;/p&gt;
&lt;p&gt;(2) BasicLinearTransformsTrackbar.cpp 说明：创建两个滑动条(对比度、亮度)对图片做线性变化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;滑动条的使用&lt;/strong&gt;                                                                                 1.创建窗口       namedWindow()                                                                                                                     2.创建滑动条   createTrackbar()                                                                        3.回掉函数       on_trackbar()  函数原型必须是 void XX(int,void*)  第一个为轨迹位置，第二个为用户数据        滑动条位置改变，调用回掉函数&lt;/p&gt;
&lt;p&gt;PS：&lt;strong&gt;void* 表明该指针与一地址值有关，但不知道存储在此地址上的对象的类型&lt;/strong&gt;                                              void*只支持有限的操作，&lt;strong&gt;向函数传递void&lt;em&gt;指针或者返回void\&lt;/em&gt;指针，给另一个void*指针赋值&lt;/strong&gt;                                                                 int i = 1   void *pi = &amp;amp;i&lt;/p&gt;
    
    </summary>
    
    
      <category term="opencv" scheme="http://yoursite.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>CommandLineParse类</title>
    <link href="http://yoursite.com/2018/05/08/CommandLineParse%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/05/08/CommandLineParse类/</id>
    <published>2018-05-08T08:53:09.000Z</published>
    <updated>2018-05-08T08:57:14.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CommandLineParse类-命令行解析类"><a href="#CommandLineParse类-命令行解析类" class="headerlink" title="CommandLineParse类(命令行解析类)"></a>CommandLineParse类(命令行解析类)</h2><p>PS：看例程的时候特别不理解这个类是啥意思，可以看下面这个</p><p><a href="https://blog.csdn.net/jkhere/article/details/8674019" target="_blank" rel="noopener">https://blog.csdn.net/jkhere/article/details/8674019</a></p><p>但是我个人觉得用我自己写的程序更好理解 keys，这种简单明了的比较适合我们小白~~</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgcodecs.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/imgproc.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* keys =</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"&#123;input |C:/Users/king/Pictures/Saved Pictures/1.jpg| string |input image&#125;"</span></span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">//分别表示简称，文件来源，文件值和帮助语句</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Mat src, dst;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* source_window = <span class="string">"Source image"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* equalized_window = <span class="string">"Equalized Image"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load image</span></span><br><span class="line"><span class="function">CommandLineParser <span class="title">parser</span><span class="params">(argc, argv, keys)</span></span>;</span><br><span class="line">src = imread(parser.get&lt;String&gt;(<span class="string">"input"</span>), IMREAD_COLOR);</span><br><span class="line"><span class="keyword">if</span> (src.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Could not open or find the image!\n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cvtColor(src, src, COLOR_BGR2GRAY);</span><br><span class="line">equalizeHist(src, dst);</span><br><span class="line"></span><br><span class="line">namedWindow(source_window, WINDOW_AUTOSIZE);</span><br><span class="line">namedWindow(equalized_window, WINDOW_AUTOSIZE);</span><br><span class="line"></span><br><span class="line">imshow(source_window, src);</span><br><span class="line">imshow(equalized_window, dst);</span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.这个类的作用</p><p>以前没这个类时，如果要运行带参数的.exe，必须在命令行中输入文件路径以及各种参数，一不小心就输错了，很不方便。<br>现在有了这个类，只需要<strong>改keys</strong>里面的内容就可以了，并且运行时可以<strong>直接在vs下用F5，不需要cmd命令行带参运行</strong>。</p><p>2.keys</p><p>keys中间的内容分成4断，用”|”分隔开，分别表示简称，文件来源，文件值和帮助语句                PS：文件的值我不是很理解，如果类型是bool，那就有值0或，如果是类型是图像，它的值可以<strong>省略</strong>，我这边文件的值用了string，也运行成功了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CommandLineParse类-命令行解析类&quot;&gt;&lt;a href=&quot;#CommandLineParse类-命令行解析类&quot; class=&quot;headerlink&quot; title=&quot;CommandLineParse类(命令行解析类)&quot;&gt;&lt;/a&gt;CommandLineParse类(命令行解析类)&lt;/h2&gt;&lt;p&gt;PS：看例程的时候特别不理解这个类是啥意思，可以看下面这个&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/jkhere/article/details/8674019&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/jkhere/article/details/8674019&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是我个人觉得用我自己写的程序更好理解 keys，这种简单明了的比较适合我们小白~~&lt;/p&gt;
    
    </summary>
    
    
      <category term="opencv" scheme="http://yoursite.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>argc和argv</title>
    <link href="http://yoursite.com/2018/05/08/argc%E5%92%8Cargv/"/>
    <id>http://yoursite.com/2018/05/08/argc和argv/</id>
    <published>2018-05-08T07:00:22.000Z</published>
    <updated>2018-05-08T11:57:39.773Z</updated>
    
    <content type="html"><![CDATA[<p>int main(int argc, char **argv)和int main(int argc, char *arg[])的区别</p><h3 id="1-字符和指针"><a href="#1-字符和指针" class="headerlink" title="1. 字符和指针"></a>1. 字符和指针</h3><p>1.char *a: 一级指针，a数据地址，*a指针指向的数据<br>printf(“%c”,*a)输出一个字符，printf(“%s”,a)输出字符串<br>举个栗子：<br>char *p1,*p2<br>char str[]=”study” 字符数组，内容可变<br>p1=str<br>p2=”hard” 字符串，字符串以字符数组存储，以’\0’结束,内容不可变</p><p>2.char **a: 二级指针，指向char *a[]<br>printf(“%c”,**a)输出一个字符，printf(“%s”,*a)输出字符串<br>举个栗子：<br>char **w<br>char *week={“Moday”,”Tuesday”,”Thursday”}<br>w=week</p><p>3.char *a[]: a是一个数组，数组的元素是字符串地址，地址包含的值是字符型数据<br>printf(“%c”,*a[i])输出一个字符，printf(“%s”,a[i]))输出字符串<br>举个栗子：<br>char *a[]={“study”,”hard”}</p><a id="more"></a><h3 id="2-argc-和-argv"><a href="#2-argc-和-argv" class="headerlink" title="2. argc 和 argv"></a>2. argc 和 argv</h3><p>argc是命令行总的参数个数  <strong>argc 至少是1</strong>                                                                                argv[]是argc个参数  <strong>其中第0个参数是程序的全名</strong> 后面的参数是命令行用户输入的参数</p><h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3. 区别"></a>3. 区别</h3><p>(int argc,char *argv[])  argv指向字符串的指针数组<br>(int argc,char **argv)   argv指向char *，即argv存的是指向字符串的指针数组的地址</p><h3 id="4-VS中如何使用argv"><a href="#4-VS中如何使用argv" class="headerlink" title="4. VS中如何使用argv"></a>4. VS中如何使用argv</h3><p>命令参数里输入参数，试一下下面这个简单例程就理解了</p><p><a href="https://blog.csdn.net/ly763124994/article/details/13627971" target="_blank" rel="noopener">https://blog.csdn.net/ly763124994/article/details/13627971</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;int main(int argc, char **argv)和int main(int argc, char *arg[])的区别&lt;/p&gt;
&lt;h3 id=&quot;1-字符和指针&quot;&gt;&lt;a href=&quot;#1-字符和指针&quot; class=&quot;headerlink&quot; title=&quot;1. 字符和指针&quot;&gt;&lt;/a&gt;1. 字符和指针&lt;/h3&gt;&lt;p&gt;1.char *a: 一级指针，a数据地址，*a指针指向的数据&lt;br&gt;printf(“%c”,*a)输出一个字符，printf(“%s”,a)输出字符串&lt;br&gt;举个栗子：&lt;br&gt;char *p1,*p2&lt;br&gt;char str[]=”study” 字符数组，内容可变&lt;br&gt;p1=str&lt;br&gt;p2=”hard” 字符串，字符串以字符数组存储，以’\0’结束,内容不可变&lt;/p&gt;
&lt;p&gt;2.char **a: 二级指针，指向char *a[]&lt;br&gt;printf(“%c”,**a)输出一个字符，printf(“%s”,*a)输出字符串&lt;br&gt;举个栗子：&lt;br&gt;char **w&lt;br&gt;char *week={“Moday”,”Tuesday”,”Thursday”}&lt;br&gt;w=week&lt;/p&gt;
&lt;p&gt;3.char *a[]: a是一个数组，数组的元素是字符串地址，地址包含的值是字符型数据&lt;br&gt;printf(“%c”,*a[i])输出一个字符，printf(“%s”,a[i]))输出字符串&lt;br&gt;举个栗子：&lt;br&gt;char *a[]={“study”,”hard”}&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo主题的优化</title>
    <link href="http://yoursite.com/2018/05/08/Hexo%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/05/08/Hexo主题的优化/</id>
    <published>2018-05-08T06:53:54.000Z</published>
    <updated>2018-05-08T07:11:58.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主题优化"><a href="#主题优化" class="headerlink" title="主题优化"></a>主题优化</h1><p>不知道从哪几个方面来优化的可以参考以下案例~~</p><p><a href="http://blog.magicwang.tech/post/Hexo-Yilia-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">http://blog.magicwang.tech/post/Hexo-Yilia-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</a></p><p><a href="http://www.yfshare.vip/categories/Hexo/" target="_blank" rel="noopener">http://www.yfshare.vip/categories/Hexo/</a></p><a id="more"></a><h2 id="1-添加文章阅读统计-网页设计"><a href="#1-添加文章阅读统计-网页设计" class="headerlink" title="1. 添加文章阅读统计-网页设计"></a>1. 添加文章阅读统计-网页设计</h2><p>添加文章阅读统计，文章阅读统计使用不蒜子：一行脚本+一行标签</p><p>PS：对网页设计真的是一窍不通，完全看别人写的东西，凭感觉改，很简单几行就搞定</p><p>文章阅读统计使用不蒜子：一行脚本+一行标签</p><p><a href="http://www.janszeng.top/2017/08/30/hexo_yilia_count/#0x02-" target="_blank" rel="noopener">http://www.janszeng.top/2017/08/30/hexo_yilia_count/#0x02-</a></p><p>PS：以下是对网页设计最基础的理解</p><p><strong>1.HTML：负责网页的结构，又称语义层</strong></p><p>(1) HTML 是用来描述网页的一种语言 ，<strong>超文本标记语言</strong>(Hyper Text Markup Language)</p><ul><li>HTML 不是一种编程语言，而是一种<strong>标记语言</strong>(markup language)</li></ul><ul><li>HTML 使用标记标签来描述网页</li></ul><p>(2) HTML 标记标签(HTML tag)</p><ul><li><p>HTML 标签是由<em>尖括号</em> 包围的关键词，标签通常是<em>成对</em> 出现的</p><p>举个栗子： <b> 和 </b>标签对中的第一个标签是<em>开始标签</em>，第二个标签是<em>结束标签</em>                                    开始和结束标签也被称为<em>开放标签</em>和<em>闭合标签</em></p></li></ul><p>(3) HTML 文档 / 网页</p><ul><li>HTML 文档也被称为<strong>网页</strong></li></ul><ul><li>包含 HTML 标签和纯文本</li></ul><p>Web 浏览器的作用是读取 HTML 文档，并以网页的形式显示出它们。浏览器不会显示 HTML 标签，而是使用标签来解释页面的内容。</p><p><strong>2.CSS ：负责网页的样式，又称视觉层</strong></p><p>级联样式表、风格样式表，它是用来进行网页风格设计的。CSS不仅可以很好的控制网页外观效果，而且还能扩充精确指定网页元素位置。</p><p><strong>3.JavaScript ：负责网页的逻辑和交互，又称逻辑层或交互层</strong></p><ul><li>JavaScript是一种可以被浏览器解析的解释型脚本语言，为了让页面动起来。</li></ul><ul><li>脚本语言是为了缩短传统的“编写、编译、链接、运行”过程而创建的，目的就是希望能让程序员快速完成程序的编写工作，不需要编译过程，就直接可以执行。</li></ul><p>HTML是肉身、CSS就是皮相、Javascript 就是灵魂</p><h2 id="2-RSS"><a href="#2-RSS" class="headerlink" title="2.RSS"></a>2.RSS</h2><p>PS：研究了很久到底啥是RSS，我选择放弃，当它是一种订阅功能吧~(超沮丧的)</p><p><a href="http://hanhailong.com/2015/10/08/Hexo%E2%80%94%E6%AD%A3%E7%A1%AE%E6%B7%BB%E5%8A%A0RSS%E8%AE%A2%E9%98%85/" target="_blank" rel="noopener">http://hanhailong.com/2015/10/08/Hexo%E2%80%94%E6%AD%A3%E7%A1%AE%E6%B7%BB%E5%8A%A0RSS%E8%AE%A2%E9%98%85/</a></p><h2 id="3-添加版权"><a href="#3-添加版权" class="headerlink" title="3.添加版权"></a>3.添加版权</h2><p>找到的，最简单的一种方法，适合我这种小白</p><p><a href="http://wellliu.com/2016/11/18/%E5%9C%A8hexo%E5%8D%9A%E5%AE%A2foot%E4%BD%8D%E7%BD%AE%E5%A4%84%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E8%AF%B4%E6%98%8E/" target="_blank" rel="noopener">http://wellliu.com/2016/11/18/%E5%9C%A8hexo%E5%8D%9A%E5%AE%A2foot%E4%BD%8D%E7%BD%AE%E5%A4%84%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83%E8%AF%B4%E6%98%8E/</a></p><h2 id="4-添加评论"><a href="#4-添加评论" class="headerlink" title="4.添加评论"></a>4.添加评论</h2><p><strong>第三方社会化评论系统</strong>  ：部署插件或添加两行代码即可使用。第三方网站为自己的网站搭建起一个强大的社会化评论系统，可将评论一键同步到微博与社区（目前支持10个社交媒体），同时将评论的回复与跟帖同步至使用的网站上。但是……</p><p>多说、优言要关闭了，哎……</p><p>畅言还要有备案号，又pass，哎……</p><p>国外的 Disqus 要翻墙评论，哎……</p><p>我选择不开评论<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**************************</span><br><span class="line"></span><br><span class="line">5.相册</span><br><span class="line"></span><br><span class="line">看了两天还做不出来</span><br></pre></td></tr></table></figure></p><p>图床一般是指储存图片的服务器，同时允许你把图片对外连接的网上空间。有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。</p><p><a href="https://www.jianshu.com/p/a9f309aaa0e0" target="_blank" rel="noopener">https://www.jianshu.com/p/a9f309aaa0e0</a></p><p>相册功能 我一定要做出来！</p><p>GitHub 或者 七牛</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;主题优化&quot;&gt;&lt;a href=&quot;#主题优化&quot; class=&quot;headerlink&quot; title=&quot;主题优化&quot;&gt;&lt;/a&gt;主题优化&lt;/h1&gt;&lt;p&gt;不知道从哪几个方面来优化的可以参考以下案例~~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.magicwang.tech/post/Hexo-Yilia-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.magicwang.tech/post/Hexo-Yilia-%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.yfshare.vip/categories/Hexo/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.yfshare.vip/categories/Hexo/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>ImageWatch</title>
    <link href="http://yoursite.com/2018/05/07/ImageWatch/"/>
    <id>http://yoursite.com/2018/05/07/ImageWatch/</id>
    <published>2018-05-07T13:23:47.000Z</published>
    <updated>2018-05-07T13:29:06.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ImageWatch"><a href="#ImageWatch" class="headerlink" title="ImageWatch"></a>ImageWatch</h2><p>PS：师兄告诉我的一个调试小工具，哈哈哈~很满意</p><p>Image Watch是一个VS插件，能够让你在调试一个OpenCV程序的时候，看到内存中的图像，<strong>不能在Release版本下调试</strong>，是显示不出图像的。</p><p>mage Watch左上角有两个单选按钮Locals和Watch，分别对应两种模式 ：<br>Locals模式显示当前栈中所有的与变量，Watch模式显示用户手动添加的变量</p><p><a href="https://blog.csdn.net/chaipp0607/article/details/71155601" target="_blank" rel="noopener">https://blog.csdn.net/chaipp0607/article/details/71155601</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ImageWatch&quot;&gt;&lt;a href=&quot;#ImageWatch&quot; class=&quot;headerlink&quot; title=&quot;ImageWatch&quot;&gt;&lt;/a&gt;ImageWatch&lt;/h2&gt;&lt;p&gt;PS：师兄告诉我的一个调试小工具，哈哈哈~很满意&lt;/p&gt;
&lt;p&gt;Image 
      
    
    </summary>
    
    
      <category term="opencv" scheme="http://yoursite.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>天池比赛入门</title>
    <link href="http://yoursite.com/2018/05/07/%E5%A4%A9%E6%B1%A0%E6%AF%94%E8%B5%9B%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/05/07/天池比赛入门/</id>
    <published>2018-05-07T01:59:32.000Z</published>
    <updated>2018-05-07T02:03:44.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="天池、Kaggle、DataCastle"><a href="#天池、Kaggle、DataCastle" class="headerlink" title="天池、Kaggle、DataCastle"></a>天池、Kaggle、DataCastle</h2><p>天池、Kaggle、DataCastle这几个大数据+机器学习的大赛平台初步了解。</p><p><a href="https://www.zhihu.com/question/41450532/answer/91372849" target="_blank" rel="noopener">https://www.zhihu.com/question/41450532/answer/91372849</a></p><p>加油！！！我一定可以做出来的！！！</p><hr><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>大神总结的机器学习是什么，简单而又醍醐灌顶：机器学习最大的特点，或者说它的发展方向，就是<strong>不要有人工干预</strong>，自己学习。通过迭代，降低自己的loss（error），提升自己的accuracy 。你只要告诉它学习的方向，剩下的就是开着它跑，给它时间，让它自己学完就好了。(满脸迷妹崇拜大神~)</p><p>PS：实际上，机器大量时间花在数据处理上，小部分时间花在模型，模型都是现有的，具体做的就是，如何选择模型，如何调节参数。</p><a id="more"></a><h2 id="机器学习应用流程"><a href="#机器学习应用流程" class="headerlink" title="机器学习应用流程"></a>机器学习应用流程</h2><p>机器学习常用算法 </p><p>常用工具</p><p>建模与问题解决流程</p><p>(1) 数据处理</p><p>(2) 特征工程</p><p>(3) 模型选择</p><p>(4) 寻找最佳超参数 ：交叉验证</p><p>(5) 模型分析与模型融合</p><h2 id="机器学习算法"><a href="#机器学习算法" class="headerlink" title="机器学习算法"></a>机器学习算法</h2><p>1.算法分类</p><p><img src="http://7xo0y8.com1.z0.glb.clouddn.com/ml_conceptml_algorithms.png" alt="算法分类">2.算法选择路径图scikit-learn algorithm cheat-sheet</p><p><img src="https://img-blog.csdn.net/20160930051801241?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="算法选择路径图"></p><p>classification 分类</p><p>regression连续值预测 回归</p><p>clustering 聚类(不同于分类，是无监督的，也就是寻找关联规则)</p><p>dimensionality reduction  降维 特征非常多</p><h2 id="机器学习开源项目"><a href="#机器学习开源项目" class="headerlink" title="机器学习开源项目"></a>机器学习开源项目</h2><p>就把它看做是一项工具，现成的库，里面的函数实现特定功能，直接拿来用即可。</p><p>下面是网上一位大神做的总结，内容很全，值得参考。</p><p><a href="https://yq.aliyun.com/articles/30794" target="_blank" rel="noopener">https://yq.aliyun.com/articles/30794</a></p><p><a href="https://yq.aliyun.com/articles/30796?spm=a2c4e.11153940.blogcont30794.29.40072508tHSzWa" target="_blank" rel="noopener">https://yq.aliyun.com/articles/30796?spm=a2c4e.11153940.blogcont30794.29.40072508tHSzWa</a></p><p>PS：一些经常看到的项目，反正我没用过。</p><p>1.TensorFlow                                                                            TensorFlow 是谷歌发布的第二代机器学习系统，是一个利用数据流图（Data Flow Graphs）进行数值计算的开源软件库。                                                                                                                                                                 主要用在<strong>深度神经网络</strong>方面。</p><p>2.Scikit-Learn                                                                                Scikit-Learn 是用于机器学习的Python 模块，建立在NumPy、SciPy 和 matplotlib基础上，<strong>非常全</strong>的库。            基本功能主要被分为六个部分：<strong>分类、回归、聚类、数据降维、模型选择、数据预处理</strong>。</p><p>3.Caffe                                                                                            Caffe 是做深度学习的框架。                                                                                                                                  目前Caffe应用实践主要有数据整理、设计网络结构、训练结果、基于现有训练模型，使用Caffe直接识别。</p><p>4.Keras                                                                                                Keras 是极其精简并高度模块化的神经网络库，在TensorFlow 或 Theano 上都能够运行，是一个高度模块化的神经网络库，支持GPU和CPU运算。同时支持卷积网络和递归网络，以及两者之间的组合。</p><p>5.MXNet                                                                                                                        MXNet 是一个兼具效率和灵活性的<strong>深度学习框架</strong>。它允许使用者将符号编程和命令式编程相结合，以追求效率和生产力的最大化。该库轻量且便携带，并且可扩展到多个GPU和多台主机上。</p><p>6.XGBoost                                                                                                            XGBoot 是设计为高效、灵活、可移植的优化分布式梯度 Boosting库。它实现了 Gradient Boosting 框架下的机器学习算法。XGBoost通过提供并行树Boosting（也被称为GBDT、GBM），以一种快速且准确的方式解决了许多数据科学问题。</p><p><strong>Boosting 提升或叫增强</strong>，是一个机器学习技术，可以用于<strong>回归</strong>和<strong>分类</strong>问题，它每一步产生一个<strong>弱预测模型</strong>(如决策树)，并<strong>加权累加</strong>到总模型中。提升的理论意义，如果一个问题存在弱分类器，则 可以通过提升的办法得到强分类器。</p><p>如果每一步的弱预测模型生成都是依据损失函数的<strong>梯度方向</strong>，则称之为梯度提升(Gradient boosting)。        </p><p>7.gensim                                                                                     用于NLP<strong>自然语言处理</strong>Natural Language Processing</p><p>8.Numpy                                                                                                                            用于科学计算 </p><p>9.Matplotlib                                                                                                              Matplotlib 是一个非常强大的 Python 画图工具，可视化数据</p><p>10.pandas                                                                                     数据清洗 数据预处理</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;天池、Kaggle、DataCastle&quot;&gt;&lt;a href=&quot;#天池、Kaggle、DataCastle&quot; class=&quot;headerlink&quot; title=&quot;天池、Kaggle、DataCastle&quot;&gt;&lt;/a&gt;天池、Kaggle、DataCastle&lt;/h2&gt;&lt;p&gt;天池、Kaggle、DataCastle这几个大数据+机器学习的大赛平台初步了解。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/41450532/answer/91372849&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/41450532/answer/91372849&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;加油！！！我一定可以做出来的！！！&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;机器学习&quot;&gt;&lt;a href=&quot;#机器学习&quot; class=&quot;headerlink&quot; title=&quot;机器学习&quot;&gt;&lt;/a&gt;机器学习&lt;/h2&gt;&lt;p&gt;大神总结的机器学习是什么，简单而又醍醐灌顶：机器学习最大的特点，或者说它的发展方向，就是&lt;strong&gt;不要有人工干预&lt;/strong&gt;，自己学习。通过迭代，降低自己的loss（error），提升自己的accuracy 。你只要告诉它学习的方向，剩下的就是开着它跑，给它时间，让它自己学完就好了。(满脸迷妹崇拜大神~)&lt;/p&gt;
&lt;p&gt;PS：实际上，机器大量时间花在数据处理上，小部分时间花在模型，模型都是现有的，具体做的就是，如何选择模型，如何调节参数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>编译器和解释器</title>
    <link href="http://yoursite.com/2018/05/04/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    <id>http://yoursite.com/2018/05/04/编译器和解释器/</id>
    <published>2018-05-04T12:42:04.000Z</published>
    <updated>2018-05-04T12:46:12.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编译器、解释器"><a href="#编译器、解释器" class="headerlink" title="编译器、解释器"></a>编译器、解释器</h2><p>1.编译器：将源程序编译成机器语言，保存成二进制文件，运行速度快</p><p>2.解释器：执程序时一条条解释成机器语言，运行速度慢</p><h2 id="编译型语言、解释型语言"><a href="#编译型语言、解释型语言" class="headerlink" title="编译型语言、解释型语言"></a>编译型语言、解释型语言</h2><p>1.编译型语言：不能独立运行，使用了库函数，需要链接，最后输出可执行代码 (C、C++)</p><p>缺点：编译成特定平台的机器码，无法将可执行文件移植到其它平台，可以移植也需要采用该平台的编译器重新编译</p><a id="more"></a><p>2.解释型语言：生成中间代码，同于机器码，再解释成可执行的机器码 (java、python)</p><p>优点：跨平台容易，只需要特定平台的解释器</p><p>缺点：牺牲了程序的执行效率，才方便移植</p><p>举个栗子：Java能够一次编译，导出运行Java编译成Java字节码，Java虚拟机 (JVM) 将字节码解释成具体平台上的机器指令来执行</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编译器、解释器&quot;&gt;&lt;a href=&quot;#编译器、解释器&quot; class=&quot;headerlink&quot; title=&quot;编译器、解释器&quot;&gt;&lt;/a&gt;编译器、解释器&lt;/h2&gt;&lt;p&gt;1.编译器：将源程序编译成机器语言，保存成二进制文件，运行速度快&lt;/p&gt;
&lt;p&gt;2.解释器：执程序时一条条解释成机器语言，运行速度慢&lt;/p&gt;
&lt;h2 id=&quot;编译型语言、解释型语言&quot;&gt;&lt;a href=&quot;#编译型语言、解释型语言&quot; class=&quot;headerlink&quot; title=&quot;编译型语言、解释型语言&quot;&gt;&lt;/a&gt;编译型语言、解释型语言&lt;/h2&gt;&lt;p&gt;1.编译型语言：不能独立运行，使用了库函数，需要链接，最后输出可执行代码 (C、C++)&lt;/p&gt;
&lt;p&gt;缺点：编译成特定平台的机器码，无法将可执行文件移植到其它平台，可以移植也需要采用该平台的编译器重新编译&lt;/p&gt;
    
    </summary>
    
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>make和CMake</title>
    <link href="http://yoursite.com/2018/05/04/make%E5%92%8CCMake/"/>
    <id>http://yoursite.com/2018/05/04/make和CMake/</id>
    <published>2018-05-04T12:24:18.000Z</published>
    <updated>2018-05-04T12:45:49.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="makefile-和-make"><a href="#makefile-和-make" class="headerlink" title="makefile 和 make"></a>makefile 和 make</h2><p>1.makefile 文件</p><p>一个工程中有很多源文件，makefile定义了整个工程的编译规则，哪些文件先编译，哪些文件后编译，哪些文件重新编译。malefile是<strong>自动化编译</strong>，一旦写好，只需一个make，整个工程自动编译。</p><p>windows平台下，VS开发环境自动生成makefile文件</p><p>Linux平台下，Qt Creator自动生成了类似makeile的 .pro文件</p><a id="more"></a><p>2.编译器和 make</p><p>编译器是编译一个文件</p><p>make是编译多个源文件的工具，解释makefile中的指令，看作是编译器的调度器</p><h2 id="CmakeList-txt-和-CMake"><a href="#CmakeList-txt-和-CMake" class="headerlink" title="CmakeList.txt 和 CMake"></a>CmakeList.txt 和 CMake</h2><p>CMake是种跨平台编译工具，Cmake 将 CMakeList.txt 转化为make 需要的 makefile 文件，用make编译</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;makefile-和-make&quot;&gt;&lt;a href=&quot;#makefile-和-make&quot; class=&quot;headerlink&quot; title=&quot;makefile 和 make&quot;&gt;&lt;/a&gt;makefile 和 make&lt;/h2&gt;&lt;p&gt;1.makefile 文件&lt;/p&gt;
&lt;p&gt;一个工程中有很多源文件，makefile定义了整个工程的编译规则，哪些文件先编译，哪些文件后编译，哪些文件重新编译。malefile是&lt;strong&gt;自动化编译&lt;/strong&gt;，一旦写好，只需一个make，整个工程自动编译。&lt;/p&gt;
&lt;p&gt;windows平台下，VS开发环境自动生成makefile文件&lt;/p&gt;
&lt;p&gt;Linux平台下，Qt Creator自动生成了类似makeile的 .pro文件&lt;/p&gt;
    
    </summary>
    
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>GitHub+Hexo 搭建自己的博客</title>
    <link href="http://yoursite.com/2018/05/04/GitHub-Hexo-%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/05/04/GitHub-Hexo-搭建自己的博客/</id>
    <published>2018-05-04T09:24:31.000Z</published>
    <updated>2018-05-08T06:54:24.922Z</updated>
    
    <content type="html"><![CDATA[<font color="gray" size="2">PS：参考网上各种大神的博客，作为一个小白，我真的东拼西凑，半懂不懂搭出来了自己的博客页面，所以看到这篇博文的你，一定要有信心~</font><h2 id="搭建过程和遇到的问题"><a href="#搭建过程和遇到的问题" class="headerlink" title="搭建过程和遇到的问题"></a>搭建过程和遇到的问题</h2><p>自己搭的时候参考了好几篇，大神太多啦，推荐看这位的就够了</p><p><a href="https://www.cnblogs.com/jackyroc/p/7681938.html" target="_blank" rel="noopener">https://www.cnblogs.com/jackyroc/p/7681938.html</a></p><p>下面罗列一下几个遇到的问题：</p><p>1.Node.js安装及环境配置之Windows，这位写得很详细啦~</p><p><a href="https://www.cnblogs.com/zhouyu2017/p/6485265.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhouyu2017/p/6485265.html</a></p><p>2.配置SSH Key到GitHub，在这个地方卡了好久，好多博文这里一笔带过写了，推荐下面这位啦~</p><p><a href="https://blog.csdn.net/gulingfengze/article/details/69665223" target="_blank" rel="noopener">https://blog.csdn.net/gulingfengze/article/details/69665223</a></p><a id="more"></a><p>3._config.yml配置，我用记事本打开中文出现乱码，用代码编辑器就好了，我下了个sublime</p><p>4.部署HEXO时出现ERROR Deployer not found : github</p><p><a href="https://blog.csdn.net/crow1108/article/details/50445671" target="_blank" rel="noopener">https://blog.csdn.net/crow1108/article/details/50445671</a></p><p>5.新手特别需要的Markdown语法 与 Hexo常用指令，其实网上很多，下面这个罗列的是很常用的</p><p><a href="http://www.mamicode.com/info-detail-1275803.html" target="_blank" rel="noopener">http://www.mamicode.com/info-detail-1275803.html</a></p><h2 id="发表新文章的总结"><a href="#发表新文章的总结" class="headerlink" title="发表新文章的总结"></a>发表新文章的总结</h2><p>GitHub+Hexo 搭建博客</p><p>1.进入Hexo放在的文件 右键-Git Bash</p><p>2.发布文章的步骤<br>  1).hexo new 创建文章<br>  2).Markdown语法编辑文章<br>  3).部署<br>  hexo clean #清除缓存 网页正常情况下可以忽略此条命令<br>  hexo generate #生成<br>  hexo server #启动服务预览，非必要，可本地浏览网页<br>  hexo deploy #部署发布</p><p>~~最后，强推一把我的博客 <a href="https://sophia0130.github.io/" target="_blank" rel="noopener">https://sophia0130.github.io/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;PS：参考网上各种大神的博客，作为一个小白，我真的东拼西凑，半懂不懂搭出来了自己的博客页面，所以看到这篇博文的你，一定要有信心~&lt;/font&gt;

&lt;h2 id=&quot;搭建过程和遇到的问题&quot;&gt;&lt;a href=&quot;#搭建过程和遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;搭建过程和遇到的问题&quot;&gt;&lt;/a&gt;搭建过程和遇到的问题&lt;/h2&gt;&lt;p&gt;自己搭的时候参考了好几篇，大神太多啦，推荐看这位的就够了&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jackyroc/p/7681938.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/jackyroc/p/7681938.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面罗列一下几个遇到的问题：&lt;/p&gt;
&lt;p&gt;1.Node.js安装及环境配置之Windows，这位写得很详细啦~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhouyu2017/p/6485265.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/zhouyu2017/p/6485265.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.配置SSH Key到GitHub，在这个地方卡了好久，好多博文这里一笔带过写了，推荐下面这位啦~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/gulingfengze/article/details/69665223&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/gulingfengze/article/details/69665223&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>网络基础知识理解</title>
    <link href="http://yoursite.com/2018/05/04/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/05/04/网络基础知识理解/</id>
    <published>2018-05-04T06:56:18.000Z</published>
    <updated>2018-05-07T05:23:02.788Z</updated>
    
    <content type="html"><![CDATA[<font color="gray" size="2">PS：写这片博客的起因是，我只是想知道为什么用GitHub搭建自己的博客，自己不需要买域名，之前从来没有接触过网络方面的知识，看了很多大神的博客，复制粘贴成自己的理解。</font><h2 id="外网IP和内网IP"><a href="#外网IP和内网IP" class="headerlink" title="外网IP和内网IP"></a>外网IP和内网IP</h2><p>IP可以不严谨的分为外网IP和内网IP(局域网)。 </p><font color="gray" size="2">PS：这样分好像是不对的，我也不理解，网上的大神说入门级的小白可以先这样理解。</font><p>1.外网IP：即因特网IP，其IP地址具有全球唯一性。但是全世界的IP地址数量是有限资源，日益增加的上网用户人数使得有限的IP地址资源紧张。为此，网络服务商采用了动态分配的办法，在用户上网的时侯分配一个IP，当不上网时，之前用的ip又很可能分配给别的上网用户。这样大大提高了IP的利用效率。<br>2.内网IP：相当于电脑在局域网里面的地址标识，一般是通过DHCP服务器进行动态分配的，机制其实与外网IP的分配相似，但在不引起IP地址冲突的情况下，可以设置成固定IP。</p><a id="more"></a><h2 id="IP和域名"><a href="#IP和域名" class="headerlink" title="IP和域名"></a>IP和域名</h2><p>下面只讨论因特网IP</p><p>网络中的地址方案分为两套：IP地址系统和域名地址系统。这两套地址系统其实是一一对应的关系。</p><p>1.IP (Internet Protocol) “网络之间互连的协议”或”因特网协议”，计算机在因特网上进行通信时应当遵守的规则。</p><p>2.IP地址 (Internet Protocol Address) ：”互联网协议地址”，IP地址就是给每个连接在Internet上的主机分配的一个32bit地址，即每一个与网络相连接的计算机和服务器都被指派了一个独一无二的地址。IP地址用二进制数来表示，每个IP地址长32比特，由4个小于256的数字组成，数字之间用点间隔。</p><font color="gray" size="2">举个栗子 ：100.10.0.1表示一个IP地址。</font><p><strong>理解误区</strong>：一台计算机只能有一个IP地址这个观点是错误的，可以指定一台计算机具有多个IP地址，也可以使多台服务器共用一个IP地址，看起来就像一台主机。</p><p>全世界的IP地址是由国际组织NIC（Network Information Center）负责统一分配。</p><p>3.域名：由于IP地址是数字标识，使用时难以记忆和书写，因此在IP地址的基础上又发展出一种符号化的地址方案，且与特定的IP地址对应，这样网络上的资源访问起来就容易得多。这个与网络上的<strong>数字型地址</strong>相对应的<strong>字符型地址</strong>，就被称为域名。相对IP地址不仅便于记忆，而且即使在IP地址发生变化的情况下，通过改变解析对应关系，域名仍可保持不变。</p><p>4.域名解析：域名到IP地址的转换过程，该工作由DNS服务器完成。DNS是进行域名和与之相对应的IP地址转换的服务器。</p><h2 id="IP和MAC地址"><a href="#IP和MAC地址" class="headerlink" title="IP和MAC地址"></a>IP和MAC地址</h2><p>1.MAC地址 (Media Access Control)，意译为媒体访问控制，或称为物理地址、硬件地址。是网卡生产商出厂时烧录进去的 ，物理上一般不可改变，每个网卡理论上都是全球唯一的。</p><p>在OSI模型中，MAC对应于第二层数据链路层，而IP对应于第三层网络层。</p><font color="gray" size="2">举个栗子 ：IP地址就像家里的门牌号，MAC地址就像身份证号，只知道MAC地址，却无法知道具体的位置</font><p>2.网卡：实现联网计算机和网络电缆之间的物理连接，为计算机之间相互通信提供一条物理通道。</p><p>网卡分有线和无线两种：</p><p>(1)有线网卡，需要一根光纤电缆线，将宽带接入主机</p><p>(2)无线网卡，他可以不需要电缆直接连接电脑，而通过接收无线路由器发出的电信号，来连接网络的。</p><font color="gray" size="2">PS：因为从来没有接触过这部分知识，实在看不懂为什么要分IP地址和MAC地址，网上有很多大神有相关的解释。</font><h2 id="IP、子网掩码、网关"><a href="#IP、子网掩码、网关" class="headerlink" title="IP、子网掩码、网关"></a>IP、子网掩码、网关</h2><p>1.子网掩码</p><p>(1)子网掩码不能单独存在，必须结合IP地址， 将某个IP地址划分成网络地址和主机地址两部分，网络号标识的是Internet上的一个子网，而主机号标识的是子网中的某台主机。</p><p>​<font color="gray" size="2">举个栗子 :poultry_leg: ：192.168.1.199   子网掩码：255.255.255.0   那么192.168.1是网络号，199是主机号</font></p><p>(2)子网掩码可以用来判断任意两台计算机的IP地址是否属于同一子网络。最简单的理解就是两台计算机各自的IP地址与子网掩码进行与运算后，得出的结果是相同的，则说明这两台计算机是处于同一个子网络上的，可以进行直接的通讯。</p><p>2.网关：是一个网络通向其他网络的IP地址，网关是与你直接相连的路由器的地址。</p><p>​<font color="gray" size="2">举个栗子 ：有网络A和网络B，网络A的IP地址范围为“192.168.1.1~192. 168.1.254”，子网掩码为255.255.255.0，网络B的IP地址范围为“192.168.2.1~192.168.2.254”，子网掩码为255.255.255.0。要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。</font></p><h2 id="域名、网站名、URL"><a href="#域名、网站名、URL" class="headerlink" title="域名、网站名、URL"></a>域名、网站名、URL</h2><p>http: //mail.163.com/index.html</p><p>1) http://  是协议，HTTP超文本传输协议，网页在网上传输的协议</p><p>2) mail  是服务器名，代表一个邮箱服务器，所以是mail</p><p>3)163.com  是域名</p><p>4) mail.163.com  是网站名，由服务器名+域名组成</p><p>5）/  表示根目录，也就是说，通过网站名找到服务器，然后在服务器存放网页的根目录</p><p>6:）index.html  表示根目录下的默认网页</p><p>7）http:// mail.163.com/index.html  叫做URL，统一资源定位符，全球性地址，用于定位网上的资源。</p><hr><p>PS:师兄看完后给的一下建议，这里再加一点东西喽~</p><p>1.http超文本传输协议 ， https是其加密版本。</p><p>2.主机(host):表示能够同其他机器互相访问的本地计算机，一台本地机有唯一标志代码，同网络掩码一起组成IP地址。</p><p>3.端口(port):数据通过它在计算机和其它设备(如打印机、鼠标、键盘或监视器)之间、网络之间或和其它直接连接的计算机之间传递。端口对CPU来说，是作为它用来发送或接收数据的一个或多个内存地址的。</p><hr><h2 id="宽带和路由器"><a href="#宽带和路由器" class="headerlink" title="宽带和路由器"></a>宽带和路由器</h2><p>想让人看懂的解释</p><p>宽带：就是自来水公司通往各家的管道。     </p><p>路由器：连到你家的主送水管道，通过这个你家这个主管道，可以让你家接水管的地方都出水。 </p><p>不想让人看懂的解释</p><p>宽带：当地运营商提供给各家上网的线路。      </p><p>路由器：控制你家机器上网的主线路，几台机器都想上网就得通过这个路由器。</p><font color="gray" size="2">PS：直接贴百度知道上的大神的回答，简直精辟了！</font><h2 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h2><p>OSI模型，该模型定义了不同计算机互联的标准，是设计和描述计算机网络通信的基本框架。</p><p>模型把网络通信分为7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><p>网络通讯协议(Transmission Control Protocol/Internet Protocol) 是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。TCP/IP 定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。</p><h2 id="Hexo搭建博客托管到GitHub"><a href="#Hexo搭建博客托管到GitHub" class="headerlink" title="Hexo搭建博客托管到GitHub"></a>Hexo搭建博客托管到GitHub</h2><p>Github是国外免费的Git代码托管平，利用Github Page服务可以免费创建一个静态网站。</p><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，生成</p><p>静态网页，托管在GitHub服务器上。</p>]]></content>
    
    <summary type="html">
    
      &lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;PS：写这片博客的起因是，我只是想知道为什么用GitHub搭建自己的博客，自己不需要买域名，之前从来没有接触过网络方面的知识，看了很多大神的博客，复制粘贴成自己的理解。&lt;/font&gt;

&lt;h2 id=&quot;外网IP和内网IP&quot;&gt;&lt;a href=&quot;#外网IP和内网IP&quot; class=&quot;headerlink&quot; title=&quot;外网IP和内网IP&quot;&gt;&lt;/a&gt;外网IP和内网IP&lt;/h2&gt;&lt;p&gt;IP可以不严谨的分为外网IP和内网IP(局域网)。 &lt;/p&gt;
&lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;PS：这样分好像是不对的，我也不理解，网上的大神说入门级的小白可以先这样理解。&lt;/font&gt;

&lt;p&gt;1.外网IP：即因特网IP，其IP地址具有全球唯一性。但是全世界的IP地址数量是有限资源，日益增加的上网用户人数使得有限的IP地址资源紧张。为此，网络服务商采用了动态分配的办法，在用户上网的时侯分配一个IP，当不上网时，之前用的ip又很可能分配给别的上网用户。这样大大提高了IP的利用效率。&lt;br&gt;2.内网IP：相当于电脑在局域网里面的地址标识，一般是通过DHCP服务器进行动态分配的，机制其实与外网IP的分配相似，但在不引起IP地址冲突的情况下，可以设置成固定IP。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Hello GitHub</title>
    <link href="http://yoursite.com/2018/05/03/Hello-GitHub/"/>
    <id>http://yoursite.com/2018/05/03/Hello-GitHub/</id>
    <published>2018-05-03T10:35:23.000Z</published>
    <updated>2018-05-08T07:22:32.541Z</updated>
    
    <content type="html"><![CDATA[<p>绿小蕤的第一篇Blog，花了一个下午+晚上，但是都是值得的~</p><p>开启小白之旅~</p><p>需要博客搭建教程的盆友，具体可以看我另一片博文 </p><p><a href="https://sophia0130.github.io/2018/05/04/GitHub-Hexo-%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">https://sophia0130.github.io/2018/05/04/GitHub-Hexo-%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;绿小蕤的第一篇Blog，花了一个下午+晚上，但是都是值得的~&lt;/p&gt;
&lt;p&gt;开启小白之旅~&lt;/p&gt;
&lt;p&gt;需要博客搭建教程的盆友，具体可以看我另一片博文 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sophia0130.github.io/2018/05/04/Git
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="纪念第一篇文章" scheme="http://yoursite.com/tags/%E7%BA%AA%E5%BF%B5%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
</feed>
